#!/usr/bin/env python
##
#
# DO NOT EDIT - generated by simspec!
#

packets           = {}
registers         = {}
defines           = {}
addr_spaces       = {}

# --------------------------------------------------------------------------
#
# Copyright (c) 2004-2008, NVIDIA Corp.
# All Rights Reserved.
#
# This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
# the contents of this file may not be disclosed to third parties, copied or
# duplicated in any form, in whole or in part, without the prior written
# permission of NVIDIA Corp.
#
# RESTRICTED RIGHTS LEGEND:
# Use, duplication or disclosure by the Government is subject to restrictions
# as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
# and Computer Software clause at DFARS 252.227-7013, and/or in similar or
# successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
# rights reserved under the Copyright Laws of the United States.
#
# --------------------------------------------------------------------------
#
# External Memory Controller register definition
#
# Protection levels:
#   public    - HW/SW/customer visible
#   protected - HW/SW          visible
#   private   - HW             visible
#
# Default is private.
# EMC pad macros parameters
defines['EMC_FBIO_DATA_MAX'] = 63
defines['EMC_FBIO_DATA_WIDTH'] = 64
defines['EMC_FBIO_DATA_32_MAX'] = 31
defines['EMC_FBIO_DATA_32_WIDTH'] = 32
defines['EMC_FBIO_DOE_MAX'] = 7
defines['EMC_FBIO_DOE_WIDTH'] = 8
defines['MAX_EMC_TIMING_WDV_1X'] = 15
defines['MAX_EMC_TIMING_WDV'] = 40
defines['MAX_EMC_TIMING_RDV'] = 75
defines['MAX_EMC_TIMING_RDV_2TO1'] = 150
# boot rom packets
# put single-bit swizzle flags into a single word

# Packet SWIZZLE_BIT6_GT_BIT7_0
packets['SWIZZLE_BIT6_GT_BIT7_0'] = {
    'size' :  8,
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK0_BYTE0
    'CH0_RANK0_BYTE0' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK0_BYTE1
    'CH0_RANK0_BYTE1' : {
        'lsb'        : 1,
        'msb'        : 1,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK0_BYTE2
    'CH0_RANK0_BYTE2' : {
        'lsb'        : 2,
        'msb'        : 2,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK0_BYTE3
    'CH0_RANK0_BYTE3' : {
        'lsb'        : 3,
        'msb'        : 3,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK1_BYTE0
    'CH0_RANK1_BYTE0' : {
        'lsb'        : 4,
        'msb'        : 4,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK1_BYTE1
    'CH0_RANK1_BYTE1' : {
        'lsb'        : 5,
        'msb'        : 5,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK1_BYTE2
    'CH0_RANK1_BYTE2' : {
        'lsb'        : 6,
        'msb'        : 6,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SWIZZLE_BIT6_GT_BIT7_0.CH0_RANK1_BYTE3
    'CH0_RANK1_BYTE3' : {
        'lsb'        : 7,
        'msb'        : 7,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'CH0_RANK0_BYTE0',
        'CH0_RANK0_BYTE1',
        'CH0_RANK0_BYTE2',
        'CH0_RANK0_BYTE3',
        'CH0_RANK1_BYTE0',
        'CH0_RANK1_BYTE1',
        'CH0_RANK1_BYTE2',
        'CH0_RANK1_BYTE3',
    ],
} # End of packet: SWIZZLE_BIT6_GT_BIT7_0

# pack enable, base, and offset for patch
# offset is in 32-bit words and is added to 0x7000_0000
# this covers the address range 0x7000_0000 to 0x7001_FFFF
# (MC, EMC, APB_PMC, etc.)
defines['BOOT_ROM_PATCH_BASE_ADDR'] = 1879048192

# Packet BOOT_ROM_PATCH_0
packets['BOOT_ROM_PATCH_0'] = {
    'size' :  32,
    # Field: BOOT_ROM_PATCH_0.OFFSET
    'OFFSET' : {
        'lsb'        : 0,
        'msb'        : 29,
        'size'       : 30,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: BOOT_ROM_PATCH_0.ENABLE
    'ENABLE' : {
        'lsb'        : 31,
        'msb'        : 31,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'OFFSET',
        'ENABLE',
    ],
} # End of packet: BOOT_ROM_PATCH_0


# Packet EMCZCAL_BOOT_ENABLE_0
packets['EMCZCAL_BOOT_ENABLE_0'] = {
    'size' :  2,
    # Field: EMCZCAL_BOOT_ENABLE_0.COLDBOOT
    'COLDBOOT' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: EMCZCAL_BOOT_ENABLE_0.WARMBOOT
    'WARMBOOT' : {
        'lsb'        : 1,
        'msb'        : 1,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'COLDBOOT',
        'WARMBOOT',
    ],
} # End of packet: EMCZCAL_BOOT_ENABLE_0


# Packet MSS_ENCRYPT_GEN
packets['MSS_ENCRYPT_GEN'] = {
    'size' :  32,
    # Field: MSS_ENCRYPT_GEN.GEN0
    'GEN0' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_GEN.GEN1
    'GEN1' : {
        'lsb'        : 1,
        'msb'        : 1,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_GEN.GEN2
    'GEN2' : {
        'lsb'        : 2,
        'msb'        : 2,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_GEN.GEN3
    'GEN3' : {
        'lsb'        : 3,
        'msb'        : 3,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_GEN.SKIP_LOCK
    'SKIP_LOCK' : {
        'lsb'        : 29,
        'msb'        : 29,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_GEN.SKIP_ENCRYPT
    'SKIP_ENCRYPT' : {
        'lsb'        : 30,
        'msb'        : 30,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_GEN.SKIP_CLK_SRC
    'SKIP_CLK_SRC' : {
        'lsb'        : 31,
        'msb'        : 31,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'GEN0',
        'GEN1',
        'GEN2',
        'GEN3',
        'SKIP_LOCK',
        'SKIP_ENCRYPT',
        'SKIP_CLK_SRC',
    ],
} # End of packet: MSS_ENCRYPT_GEN


# Packet MSS_ENCRYPT_DIST
packets['MSS_ENCRYPT_DIST'] = {
    'size' :  20,
    # Field: MSS_ENCRYPT_DIST.DIST0
    'DIST0' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_DIST.DIST1
    'DIST1' : {
        'lsb'        : 1,
        'msb'        : 1,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_DIST.DIST2
    'DIST2' : {
        'lsb'        : 2,
        'msb'        : 2,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_DIST.DIST3
    'DIST3' : {
        'lsb'        : 3,
        'msb'        : 3,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_DIST.EN0
    'EN0' : {
        'lsb'        : 16,
        'msb'        : 16,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_DIST.EN1
    'EN1' : {
        'lsb'        : 17,
        'msb'        : 17,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_DIST.EN2
    'EN2' : {
        'lsb'        : 18,
        'msb'        : 18,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSS_ENCRYPT_DIST.EN3
    'EN3' : {
        'lsb'        : 19,
        'msb'        : 19,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'DIST0',
        'DIST1',
        'DIST2',
        'DIST3',
        'EN0',
        'EN1',
        'EN2',
        'EN3',
    ],
} # End of packet: MSS_ENCRYPT_DIST

#
#
# NOTE: Please use EMC_WINCR definition to specify incr1/incr4 based on the project defines.
#
#
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
# USAGE NOTE: Many EMC register fields are shadowed.
#
#   Writes to shadowed register fields update the shadow copy (this is default, assumes DBG.WRITE_MUX==ASSEMBLY).
#
#   Reads to shadowed register fields return the currently-active copy (this is default, assumes DBG.READ_MUX==ACTIVE).
#
#   This allows a new set frequency-dependant timing parameters to be written to the shadow registers while memory traffic is ongoing,
#   then when the parameters are completely written, the EMC hardware can perform a timing-safe switch.
#
#   Such switches can be triggered via two methods: TIMING_CONTROL.TIMING_UPDATE (generally used during initialization), or
#   the automatic CAR/EMC handshake on a clock-frequency or divider change (assuming CFG_2.CLKCHANGE_REQ_ENABLE==ENABLED).
#
#   Registers that are shadowed are marked by a comment:
#                 // This register is shadowed: see usage note at top of spec file.
#   Occassionally, only certain fields in the register will be shadowed, if so they are noted after the above comment.
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
# USAGE NOTE: Many EMC registers play crucial roles in warmboot (aka "wake from LP0") and
#             coldboot (aka "power up") sequences. Suggested actions for the BootROM/Bootloader
#             are noted in comments labelled "Boot requirements: ...".
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
# USAGE NOTE: The EMC register fields to be stored in PMC must have "[PMC]", "[PMC2]", or
#             "[PMC3]"... in their comments. ([PMC2] registers are packed/unpacked after [PMC]
#             register group in SW code. [PMC3] is even later.)
#             The fields that need to be stored in PMC Secure Scratch
#             registers need to have [PMC_SECURE] in their comments. //
#             Internal note: After adding
#             and removing such PMC or PMC_SECURE flag, the tool warmboot_code_gen & warmboot_secure_code_gen
#             must be rerun to generate new bootrom code.
#
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
#////////////////////////////////////////////////////////////////////////////////////////////
# Clear on 1-write. Init value is clear.
#  this register is "sticky"


# Register EMC_INTSTATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['INTSTATUS_0'] = {
    'addr'            : 0x0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff8,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x3ff8,
    'read_mask'       : 0x3ff8,
    'write_mask'      : 0x3ff8,
    'REFRESH_OVERFLOW_INT' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'CLKCHANGE_COMPLETE_INT' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'MRR_DIVLD_INT' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'ACCESS_TO_SR_DPD_DEV_INT' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'DLL_ALARM_INT' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'CCFIFO_OVERFLOW_INT' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'DLL_LOCK_TIMEOUT_INT' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'ECC_UNCORR_ERR_INT' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'ECC_CORR_ERR_INT' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'ECC_ERR_BUF_OVF_INT' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    'TWEAK_UNDERFLOW_INT' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "CLEAR",
        'enums' : {
            'CLEAR' : 0,
            'SET' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REFRESH_OVERFLOW_INT',
        'CLKCHANGE_COMPLETE_INT',
        'MRR_DIVLD_INT',
        'ACCESS_TO_SR_DPD_DEV_INT',
        'DLL_ALARM_INT',
        'CCFIFO_OVERFLOW_INT',
        'DLL_LOCK_TIMEOUT_INT',
        'ECC_UNCORR_ERR_INT',
        'ECC_CORR_ERR_INT',
        'ECC_ERR_BUF_OVF_INT',
        'TWEAK_UNDERFLOW_INT',
    ],
} # End of register: INTSTATUS_0

registers['EMC']['register_list'].append('INTSTATUS_0')
# Init value is masked.

# Register EMC_INTMASK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['INTMASK_0'] = {
    'addr'            : 0x4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff8,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x3ff8,
    'read_mask'       : 0x3ff8,
    'write_mask'      : 0x3ff8,
    'REFRESH_OVERFLOW_INTMASK' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'CLKCHANGE_COMPLETE_INTMASK' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'MRR_DIVLD_INTMASK' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ACCESS_TO_SR_DPD_DEV_INTMASK' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'DLL_ALARM_INTMASK' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'CCFIFO_OVERFLOW_INTMASK' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'DLL_LOCK_TIMEOUT_INTMASK' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ECC_UNCORR_ERR_INTMASK' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ECC_CORR_ERR_INTMASK' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ECC_ERR_BUF_OVF_INTMASK' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'TWEAK_UNDERFLOW_INTMASK' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REFRESH_OVERFLOW_INTMASK',
        'CLKCHANGE_COMPLETE_INTMASK',
        'MRR_DIVLD_INTMASK',
        'ACCESS_TO_SR_DPD_DEV_INTMASK',
        'DLL_ALARM_INTMASK',
        'CCFIFO_OVERFLOW_INTMASK',
        'DLL_LOCK_TIMEOUT_INTMASK',
        'ECC_UNCORR_ERR_INTMASK',
        'ECC_CORR_ERR_INTMASK',
        'ECC_ERR_BUF_OVF_INTMASK',
        'TWEAK_UNDERFLOW_INTMASK',
    ],
} # End of register: INTMASK_0

registers['EMC']['register_list'].append('INTMASK_0')
# The DBG register is used to reconfigure the EMC during debug or chip testing.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Implementation note: Do not shadow any field here, there's no way to program READ_MUX without affecting the value of such shadowed field.

# Register EMC_DBG_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DBG_0'] = {
    'addr'            : 0x8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x1000c00,
    'array'           : False,
    'reset_mask'      : 0xffe03e1f,
    'sw_default_val'  : 0x1000c00,
    'sw_default_mask' : 0xffe03e1f,
    'read_mask'       : 0xffe03e1f,
    'write_mask'      : 0xffe03e1f,
    'READ_MUX' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ACTIVE",
        'enums' : {
            'ACTIVE' : 0,
            'ASSEMBLY' : 1,
        },
    },
    'WRITE_MUX' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ASSEMBLY",
        'enums' : {
            'ASSEMBLY' : 0,
            'ACTIVE' : 1,
        },
    },
    'FORCE_UPDATE' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'FORCE_IDLE' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'IGNORE_MC_IDLE_FOR_CLKEN' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'READ_DQM_CTRL' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MANAGED",
        'enums' : {
            'MANAGED' : 0,
            'ALWAYS_ON' : 1,
        },
    },
    'AP_REQ_BUSY_CTRL' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'STRETCH_MRW_RESET' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'SUPPRESS_READ_CMD' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'SUPPRESS_WRITE_CMD' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'TR_WR_ALL' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DLLCAL_ALLOW_WRITE_MUX' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DISABLE_TR_MUX' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CFG_PRIORITY' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'AUTOCAL_ALLOW_WRITE_MUX' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CFG_SWAP' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ACTIVE_ONLY",
        'enums' : {
            'ACTIVE_ONLY' : 0,
            'SWAP' : 1,
            'ASSEMBLY_ONLY' : 2,
        },
    },
    'ALLOW_EMC1_PMACRO_CFG_ACCESS' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ALLOW_HOSTIF_DURING_CCFIFO' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'WRITE_ACTIVE_ONLY' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'AUTOCAL_IGNORE_SWAP' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'READ_MUX',
        'WRITE_MUX',
        'FORCE_UPDATE',
        'FORCE_IDLE',
        'IGNORE_MC_IDLE_FOR_CLKEN',
        'READ_DQM_CTRL',
        'AP_REQ_BUSY_CTRL',
        'STRETCH_MRW_RESET',
        'SUPPRESS_READ_CMD',
        'SUPPRESS_WRITE_CMD',
        'TR_WR_ALL',
        'DLLCAL_ALLOW_WRITE_MUX',
        'DISABLE_TR_MUX',
        'CFG_PRIORITY',
        'AUTOCAL_ALLOW_WRITE_MUX',
        'CFG_SWAP',
        'ALLOW_EMC1_PMACRO_CFG_ACCESS',
        'ALLOW_HOSTIF_DURING_CCFIFO',
        'WRITE_ACTIVE_ONLY',
        'AUTOCAL_IGNORE_SWAP',
    ],
} # End of register: DBG_0

registers['EMC']['register_list'].append('DBG_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Some fields in this register are shadowed: see usage note at top of spec file.

# Register EMC_CONFIG_SAMPLE_DELAY_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CONFIG_SAMPLE_DELAY_0'] = {
    'addr'            : 0x5f0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x20,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'PMACRO_SAMPLE_DELAY' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PMACRO_SAMPLE_DELAY',
    ],
} # End of register: CONFIG_SAMPLE_DELAY_0

registers['EMC']['register_list'].append('CONFIG_SAMPLE_DELAY_0')
# CFG_UPDATE is used to control special features of the timing updates.

# Register EMC_CFG_UPDATE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_UPDATE_0'] = {
    'addr'            : 0x5f4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x70000501,
    'array'           : False,
    'reset_mask'      : 0xf0000707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0000707,
    'write_mask'      : 0xf0000707,
    'UPDATE_AUTO_CAL_IN_CLKCHANGE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'UPDATE_AUTO_CAL_IN_UPDATE' : {
        'lsb'               : 1,
        'msb'               : 2,
        'size'              : 2,
        'field'             : (0x3 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "NEVER",
        'enums' : {
            'NEVER' : 0,
            'WRITTEN' : 1,
            'ALWAYS' : 2,
        },
    },
    'UPDATE_DLL_IN_CLKCHANGE' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'UPDATE_DLL_IN_UPDATE' : {
        'lsb'               : 9,
        'msb'               : 10,
        'size'              : 2,
        'field'             : (0x3 << 9),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ALWAYS",
        'enums' : {
            'NEVER' : 0,
            'WRITTEN' : 1,
            'ALWAYS' : 2,
        },
    },
    'LINKED_TIMING_UPDATE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'LINKED_TIMING_UPDATE_TIMEOUT' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'STALL_WRITES_DURING_TIMING_UPDATE' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'STALL_READS_DURING_TIMING_UPDATE' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'UPDATE_AUTO_CAL_IN_CLKCHANGE',
        'UPDATE_AUTO_CAL_IN_UPDATE',
        'UPDATE_DLL_IN_CLKCHANGE',
        'UPDATE_DLL_IN_UPDATE',
        'LINKED_TIMING_UPDATE',
        'LINKED_TIMING_UPDATE_TIMEOUT',
        'STALL_WRITES_DURING_TIMING_UPDATE',
        'STALL_READS_DURING_TIMING_UPDATE',
    ],
} # End of register: CFG_UPDATE_0

registers['EMC']['register_list'].append('CFG_UPDATE_0')
# Init value is masked.

# Register EMC_CRITICAL_INTMASK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CRITICAL_INTMASK_0'] = {
    'addr'            : 0x510,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff8,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xff8,
    'read_mask'       : 0xff8,
    'write_mask'      : 0xff8,
    'REFRESH_OVERFLOW_CRITICAL_INTMASK' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'CLKCHANGE_COMPLETE_CRITICAL_INTMASK' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'MRR_DIVLD_CRITICAL_INTMASK' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ACCESS_TO_SR_DPD_DEV_CRITICAL_INTMASK' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'DLL_ALARM_CRITICAL_INTMASK' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'CCFIFO_OVERFLOW_CRITICAL_INTMASK' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'DLL_LOCK_TIMEOUT_CRITICAL_INTMASK' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ECC_UNCORR_ERR_CRITICAL_INTMASK' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'TWEAK_UNDERFLOW_CRITICAL_INTMASK' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REFRESH_OVERFLOW_CRITICAL_INTMASK',
        'CLKCHANGE_COMPLETE_CRITICAL_INTMASK',
        'MRR_DIVLD_CRITICAL_INTMASK',
        'ACCESS_TO_SR_DPD_DEV_CRITICAL_INTMASK',
        'DLL_ALARM_CRITICAL_INTMASK',
        'CCFIFO_OVERFLOW_CRITICAL_INTMASK',
        'DLL_LOCK_TIMEOUT_CRITICAL_INTMASK',
        'ECC_UNCORR_ERR_CRITICAL_INTMASK',
        'TWEAK_UNDERFLOW_CRITICAL_INTMASK',
    ],
} # End of register: CRITICAL_INTMASK_0

registers['EMC']['register_list'].append('CRITICAL_INTMASK_0')
# Init value is masked.

# Register EMC_NONCRITICAL_INTMASK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['NONCRITICAL_INTMASK_0'] = {
    'addr'            : 0x514,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff8,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x3ff8,
    'read_mask'       : 0x3ff8,
    'write_mask'      : 0x3ff8,
    'REFRESH_OVERFLOW_NONCRITICAL_INTMASK' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'CLKCHANGE_COMPLETE_NONCRITICAL_INTMASK' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'MRR_DIVLD_NONCRITICAL_INTMASK' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ACCESS_TO_SR_DPD_DEV_NONCRITICAL_INTMASK' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'DLL_ALARM_NONCRITICAL_INTMASK' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'CCFIFO_OVERFLOW_NONCRITICAL_INTMASK' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'DLL_LOCK_TIMEOUT_NONCRITICAL_INTMASK' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ECC_UNCORR_ERR_NONCRITICAL_INTMASK' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ECC_CORR_ERR_NONCRITICAL_INTMASK' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'ECC_ERR_BUF_OVF_NONCRITICAL_INTMASK' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    'TWEAK_UNDERFLOW_NONCRITICAL_INTMASK' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MASKED",
        'enums' : {
            'MASKED' : 0,
            'UNMASKED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REFRESH_OVERFLOW_NONCRITICAL_INTMASK',
        'CLKCHANGE_COMPLETE_NONCRITICAL_INTMASK',
        'MRR_DIVLD_NONCRITICAL_INTMASK',
        'ACCESS_TO_SR_DPD_DEV_NONCRITICAL_INTMASK',
        'DLL_ALARM_NONCRITICAL_INTMASK',
        'CCFIFO_OVERFLOW_NONCRITICAL_INTMASK',
        'DLL_LOCK_TIMEOUT_NONCRITICAL_INTMASK',
        'ECC_UNCORR_ERR_NONCRITICAL_INTMASK',
        'ECC_CORR_ERR_NONCRITICAL_INTMASK',
        'ECC_ERR_BUF_OVF_NONCRITICAL_INTMASK',
        'TWEAK_UNDERFLOW_NONCRITICAL_INTMASK',
    ],
} # End of register: NONCRITICAL_INTMASK_0

registers['EMC']['register_list'].append('NONCRITICAL_INTMASK_0')
# The CFG register is used to configure the external memory interface.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Some fields in this register are shadowed: see usage note at top of spec file.

# Register EMC_CFG_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_0'] = {
    'addr'            : 0xc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x3c00000,
    'array'           : False,
    'reset_mask'      : 0xf7ef01ce,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf7ef01ce,
    'write_mask'      : 0xf7ef01ce,
    'EMC2PMACRO_CFG_BYPASS_ADDRPIPE' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_DATAPIPE1' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_DATAPIPE2' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'INVERT_DQM' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'WAIT_FOR_ISP2_READY_B4_CC' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'WAIT_FOR_VI2_READY_B4_CC' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2MC_CLK_RATIO' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "TWOX",
        'enums' : {
            'TWOX' : 0,
            'ONEX' : 1,
            'FOURX' : 2,
            'RESERVED' : 3,
        },
    },
    'DSR_VTTGEN_DRV_EN' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'WAIT_FOR_NVDISPLAY_READY_B4_CC' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PERIODIC_QRST' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'MAN_PRE_RD' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'MAN_PRE_WR' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'AUTO_PRE_RD' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'AUTO_PRE_WR' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'REQACT_ASYNC' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DYN_SELF_REF' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DRAM_ACPD' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "NO_POWERDOWN",
        'enums' : {
            'NO_POWERDOWN' : 0,
            'ACTIVE_POWERDOWN' : 1,
        },
    },
    'DRAM_CLKSTOP_SR' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DRAM_CLKSTOP_PD' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC2PMACRO_CFG_BYPASS_ADDRPIPE',
        'EMC2PMACRO_CFG_BYPASS_DATAPIPE1',
        'EMC2PMACRO_CFG_BYPASS_DATAPIPE2',
        'INVERT_DQM',
        'WAIT_FOR_ISP2_READY_B4_CC',
        'WAIT_FOR_VI2_READY_B4_CC',
        'EMC2MC_CLK_RATIO',
        'DSR_VTTGEN_DRV_EN',
        'WAIT_FOR_NVDISPLAY_READY_B4_CC',
        'PERIODIC_QRST',
        'MAN_PRE_RD',
        'MAN_PRE_WR',
        'AUTO_PRE_RD',
        'AUTO_PRE_WR',
        'REQACT_ASYNC',
        'DYN_SELF_REF',
        'DRAM_ACPD',
        'DRAM_CLKSTOP_SR',
        'DRAM_CLKSTOP_PD',
    ],
} # End of register: CFG_0

registers['EMC']['register_list'].append('CFG_0')
# External Memory Address Configuration, System
#
# The ADR_CFG register is used to specify the number of DRAM devices.  DRAM density and geometry parameters are
# specified by the EMEM_ADR_CFG* registers in MC.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#

# Register EMC_ADR_CFG_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ADR_CFG_0'] = {
    'addr'            : 0x10,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x1,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'EMEM_NUMDEV' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "N2",
        'enums' : {
            'N1' : 0,
            'N2' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMEM_NUMDEV',
    ],
} # End of register: ADR_CFG_0

registers['EMC']['register_list'].append('ADR_CFG_0')
# The REFCTRL register allows SW to enable or disable the refresh controller.
# REF_VALID should be enabled after the initialization sequence is completed.
#
# Boot requirements: If per-device DPD is used, the DEVICE_REFRESH_DISABLE field should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: If per-device DPD is used, the DEVICE_REFRESH_DISABLE field should be parameterized the scratch registers registers and restored by the BootROM during warmboot.
# Boot requirements: REF_VALID field should always be set to ENABLED for normal use, no need to parameterize in BCT/scratch.

# Register EMC_REFCTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['REFCTRL_0'] = {
    'addr'            : 0x20,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x80000003,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x80000003,
    'write_mask'      : 0x80000003,
    'DEVICE_REFRESH_DISABLE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'REF_VALID' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEVICE_REFRESH_DISABLE',
        'REF_VALID',
    ],
} # End of register: REFCTRL_0

registers['EMC']['register_list'].append('REFCTRL_0')
# The PIN register allows SW to control the state of the selected external DRAM pins.
#
# Boot requirements: Both fields in this register should be set to NORMAL during coldboot.
# Boot requirements: Both fields in this register should be set to NORMAL during warmboot.

# Register EMC_PIN_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PIN_0'] = {
    'addr'            : 0x24,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x12,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x33117,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x33117,
    'read_mask'       : 0x33117,
    'write_mask'      : 0x33117,
    'PIN_CKE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "POWERDOWN",
        'enums' : {
            'POWERDOWN' : 0,
            'NORMAL' : 1,
        },
    },
    'PIN_CKEB' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "POWERDOWN",
        'enums' : {
            'POWERDOWN' : 0,
            'NORMAL' : 1,
        },
    },
    'PIN_CKE_PER_DEV' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'PIN_DQM' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "NORMAL",
        'enums' : {
            'NORMAL' : 0,
            'INACTIVE' : 1,
        },
    },
    'PIN_RESET' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ACTIVE",
        'enums' : {
            'ACTIVE' : 0,
            'INACTIVE' : 1,
        },
    },
    'PIN_GPIO' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "INACTIVE",
        'enums' : {
            'INACTIVE' : 0,
            'ACTIVE' : 1,
        },
    },
    'PIN_GPIO_EN' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PIN_CKE',
        'PIN_CKEB',
        'PIN_CKE_PER_DEV',
        'PIN_DQM',
        'PIN_RESET',
        'PIN_GPIO',
        'PIN_GPIO_EN',
    ],
} # End of register: PIN_0

registers['EMC']['register_list'].append('PIN_0')
# The TIMING_CONTROL register is used by SW to trigger parameter updates for timing parameter
#   registers, rdqs/quse delay controls, and some DLL controls.  Writing the TIMING_UPDATE field updates
#   the active state of these registers with the programmed assembly state.  The active state is
#   updated during a safe interval determined by the EMC.  If CLKCHANGE_REQ_ENABLE is enabled,
#   the active value will automatically be updated on completion of the clock change.
# Note: Programming of this register does not trigger the shadow register update event immediately.
#   To prevent shadow register programming issued after programming this register from being latched
#   accidentally, always poll for TIMING_UPDATE_STALLED==0 after programming this register.
#
# Boot requirements: Writing this register with 0x1 will trigger a timing update event, which should be used in both warmboot and coldboot sequences.

# Register EMC_TIMING_CONTROL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TIMING_CONTROL_0'] = {
    'addr'            : 0x28,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'TIMING_UPDATE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwt',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TIMING_UPDATE',
    ],
} # End of register: TIMING_CONTROL_0

registers['EMC']['register_list'].append('TIMING_CONTROL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RC_0'] = {
    'addr'            : 0x2c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0xff,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'RC' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0xff,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RC',
    ],
} # End of register: RC_0

registers['EMC']['register_list'].append('RC_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RFC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RFC_0'] = {
    'addr'            : 0x30,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xa,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x3ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff,
    'write_mask'      : 0x3ff,
    'RFC' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RFC',
    ],
} # End of register: RFC_0

registers['EMC']['register_list'].append('RFC_0')

# Register EMC_RFCPB_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RFCPB_0'] = {
    'addr'            : 0x590,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x1ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ff,
    'write_mask'      : 0x1ff,
    'RFCPB' : {
        'lsb'               : 0,
        'msb'               : 8,
        'size'              : 9,
        'field'             : (0x1ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RFCPB',
    ],
} # End of register: RFCPB_0

registers['EMC']['register_list'].append('RFCPB_0')

# Register EMC_PBR2PBR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PBR2PBR_0'] = {
    'addr'            : 0x13c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x1ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ff,
    'write_mask'      : 0x1ff,
    'PBR2PBR' : {
        'lsb'               : 0,
        'msb'               : 8,
        'size'              : 9,
        'field'             : (0x1ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PBR2PBR',
    ],
} # End of register: PBR2PBR_0

registers['EMC']['register_list'].append('PBR2PBR_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RAS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RAS_0'] = {
    'addr'            : 0x34,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x7f,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'RAS' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x7f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RAS',
    ],
} # End of register: RAS_0

registers['EMC']['register_list'].append('RAS_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RP_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RP_0'] = {
    'addr'            : 0x38,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'RP' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RP',
    ],
} # End of register: RP_0

registers['EMC']['register_list'].append('RP_0')
#
#
#
# R2something and W2something registers are independent of burst length, and are relative to the last virtual CAS_ of a command.
# We start counting from the last data transfer as related to where CAS_ would be if BL = 4.
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_R2W_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['R2W_0'] = {
    'addr'            : 0x3c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'R2W' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'R2W',
    ],
} # End of register: R2W_0

registers['EMC']['register_list'].append('R2W_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_W2R_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['W2R_0'] = {
    'addr'            : 0x40,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'W2R' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'W2R',
    ],
} # End of register: W2R_0

registers['EMC']['register_list'].append('W2R_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_R2P_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['R2P_0'] = {
    'addr'            : 0x44,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'R2P' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'R2P',
    ],
} # End of register: R2P_0

registers['EMC']['register_list'].append('R2P_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_W2P_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['W2P_0'] = {
    'addr'            : 0x48,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x7f,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'W2P' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x7f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'W2P',
    ],
} # End of register: W2P_0

registers['EMC']['register_list'].append('W2P_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CCDMW_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CCDMW_0'] = {
    'addr'            : 0x5c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'CCDMW' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CCDMW',
    ],
} # End of register: CCDMW_0

registers['EMC']['register_list'].append('CCDMW_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RD_RCD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RD_RCD_0'] = {
    'addr'            : 0x4c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'RD_RCD' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RD_RCD',
    ],
} # End of register: RD_RCD_0

registers['EMC']['register_list'].append('RD_RCD_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WR_RCD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WR_RCD_0'] = {
    'addr'            : 0x50,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WR_RCD' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WR_RCD',
    ],
} # End of register: WR_RCD_0

registers['EMC']['register_list'].append('WR_RCD_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RRD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RRD_0'] = {
    'addr'            : 0x54,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0x1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f,
    'write_mask'      : 0x1f,
    'RRD' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RRD',
    ],
} # End of register: RRD_0

registers['EMC']['register_list'].append('RRD_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_REXT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['REXT_0'] = {
    'addr'            : 0x58,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0x1,
    'array'           : False,
    'reset_mask'      : 0x1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f,
    'write_mask'      : 0x1f,
    'REXT' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REXT',
    ],
} # End of register: REXT_0

registers['EMC']['register_list'].append('REXT_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WDV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WDV_0'] = {
    'addr'            : 0x5c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WDV' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX' : 40,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WDV',
    ],
} # End of register: WDV_0

registers['EMC']['register_list'].append('WDV_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#

# Register EMC_QUSE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['QUSE_0'] = {
    'addr'            : 0x60,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x2,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'QUSE' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE',
    ],
} # End of register: QUSE_0

registers['EMC']['register_list'].append('QUSE_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_QRST_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['QRST_0'] = {
    'addr'            : 0x64,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x15,
    'reset_val'       : 0x1,
    'array'           : False,
    'reset_mask'      : 0x1f00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f00ff,
    'write_mask'      : 0x1f00ff,
    'QRST' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QRST_DURATION' : {
        'lsb'               : 16,
        'msb'               : 20,
        'size'              : 5,
        'field'             : (0x1f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QRST',
        'QRST_DURATION',
    ],
} # End of register: QRST_0

registers['EMC']['register_list'].append('QRST_0')

# Register EMC_ISSUE_QRST_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ISSUE_QRST_0'] = {
    'addr'            : 0x428,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'ISSUE_QRST' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ISSUE_QRST',
    ],
} # End of register: ISSUE_QRST_0

registers['EMC']['register_list'].append('ISSUE_QRST_0')
# When PERIODIC_QRST is enabled, the QSAFE parameter is intended to guarantee that the
# QRSTs will not interfere with pending reads (e.g. the queue is empty).
# This field must be set to at least (RDV - QRST).
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_QSAFE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['QSAFE_0'] = {
    'addr'            : 0x68,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x7,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'QSAFE' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QSAFE',
    ],
} # End of register: QSAFE_0

registers['EMC']['register_list'].append('QSAFE_0')
# RDV is the read latency register. This register value is not
# negotiable, it will work with the right value and will not with the wrong value.
# It is sequential timing, not combinational (i.e., maybe the silicon is fast enough type) timing.
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RDV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RDV_0'] = {
    'addr'            : 0x6c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x8,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'RDV' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RDV',
    ],
} # End of register: RDV_0

registers['EMC']['register_list'].append('RDV_0')
# The value of REFRESH is calculated using the following formula:
#
#      {REFRESH, REFRESH_LO} = max[(tREF/#_of_rows) / (emc_clk_period) - 64,
#                                  (tREF/#_of_rows) / (emc_clk_period) * 97%]
#
# For example, if the clock frequency is 133MHz, and the refresh requirement
# is 64ms per 4096 rows.  The programming value is 0x7e3.
#
# This should always be programmed using the all-bank refresh timings, and does not need to change
#   for per-bank refresh operation
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_REFRESH_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['REFRESH_0'] = {
    'addr'            : 0x70,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'REFRESH_LO' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'REFRESH' : {
        'lsb'               : 6,
        'msb'               : 15,
        'size'              : 10,
        'field'             : (0x3ff << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REFRESH_LO',
        'REFRESH',
    ],
} # End of register: REFRESH_0

registers['EMC']['register_list'].append('REFRESH_0')
# BURST_REFRESH_NUM is used to specify the refresh burst count.  The refresh controller
# will wait until BURST_REFRESH_NUM refreshes have been scheduled, then issue them all
# at once.  This can result in a performance improvement in many cases.
# Note: If tRAS(max) is less than the refresh interval (tREF/#_of_rows),
# tRAS(max) must be used instead of the refresh interval in the formula above.  This
# is because refresh is used to satisfy tRAS(max) timing.  Accordingly, BURST_REFRESH_NUM
# must be programmed in such a way that queueing up multiple refreshes does not violate
# tRAS(max) timing.  Burst length = 2^BURST_REFRESH_NUM.
# Refreshes will be throttled to meet TREFBW limitation (8/window) if TREFBW > 0.
# *Note:  Do not program this register to value non-zero unless for testing.
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_BURST_REFRESH_NUM_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['BURST_REFRESH_NUM_0'] = {
    'addr'            : 0x74,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'BURST_REFRESH_NUM' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "BR1",
        'enums' : {
            'BR1' : 0,
            'BR2' : 1,
            'BR4' : 2,
            'BR8' : 3,
            'BR16' : 4,
            'BR32' : 5,
            'BR64' : 6,
            'BR128' : 7,
            'BR256' : 8,
            'BR512' : 9,
            'MAX' : 9,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BURST_REFRESH_NUM',
    ],
} # End of register: BURST_REFRESH_NUM_0

registers['EMC']['register_list'].append('BURST_REFRESH_NUM_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PDEX2WR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PDEX2WR_0'] = {
    'addr'            : 0x78,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3e,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'PDEX2WR' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3e,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PDEX2WR',
    ],
} # End of register: PDEX2WR_0

registers['EMC']['register_list'].append('PDEX2WR_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PDEX2RD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PDEX2RD_0'] = {
    'addr'            : 0x7c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3e,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'PDEX2RD' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3e,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PDEX2RD',
    ],
} # End of register: PDEX2RD_0

registers['EMC']['register_list'].append('PDEX2RD_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PDEX2CKE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PDEX2CKE_0'] = {
    'addr'            : 0x118,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'PDEX2CKE' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PDEX2CKE',
    ],
} # End of register: PDEX2CKE_0

registers['EMC']['register_list'].append('PDEX2CKE_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PCHG2PDEN_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PCHG2PDEN_0'] = {
    'addr'            : 0x80,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'PCHG2PDEN' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PCHG2PDEN',
    ],
} # End of register: PCHG2PDEN_0

registers['EMC']['register_list'].append('PCHG2PDEN_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_ACT2PDEN_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ACT2PDEN_0'] = {
    'addr'            : 0x84,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'ACT2PDEN' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ACT2PDEN',
    ],
} # End of register: ACT2PDEN_0

registers['EMC']['register_list'].append('ACT2PDEN_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_AR2PDEN_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AR2PDEN_0'] = {
    'addr'            : 0x88,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0x1ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ff,
    'write_mask'      : 0x1ff,
    'AR2PDEN' : {
        'lsb'               : 0,
        'msb'               : 8,
        'size'              : 9,
        'field'             : (0x1ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AR2PDEN',
    ],
} # End of register: AR2PDEN_0

registers['EMC']['register_list'].append('AR2PDEN_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RW2PDEN_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RW2PDEN_0'] = {
    'addr'            : 0x8c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x1f,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'RW2PDEN' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RW2PDEN',
    ],
} # End of register: RW2PDEN_0

registers['EMC']['register_list'].append('RW2PDEN_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CKE2PDEN_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CKE2PDEN_0'] = {
    'addr'            : 0x11c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'CKE2PDEN' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CKE2PDEN',
    ],
} # End of register: CKE2PDEN_0

registers['EMC']['register_list'].append('CKE2PDEN_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TXSR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TXSR_0'] = {
    'addr'            : 0x90,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xa,
    'reset_val'       : 0x3fe,
    'array'           : False,
    'reset_mask'      : 0x3ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff,
    'write_mask'      : 0x3ff,
    'TXSR' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3fe,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TXSR',
    ],
} # End of register: TXSR_0

registers['EMC']['register_list'].append('TXSR_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TCKE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TCKE_0'] = {
    'addr'            : 0x94,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3e,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'TCKE' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3e,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TCKE',
    ],
} # End of register: TCKE_0

registers['EMC']['register_list'].append('TCKE_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TFAW_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TFAW_0'] = {
    'addr'            : 0x98,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'TFAW' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TFAW',
    ],
} # End of register: TFAW_0

registers['EMC']['register_list'].append('TFAW_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TRPAB_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRPAB_0'] = {
    'addr'            : 0x9c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'TRPAB' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TRPAB',
    ],
} # End of register: TRPAB_0

registers['EMC']['register_list'].append('TRPAB_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TCLKSTABLE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TCLKSTABLE_0'] = {
    'addr'            : 0xa0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0xf,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'TCLKSTABLE' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TCLKSTABLE',
    ],
} # End of register: TCLKSTABLE_0

registers['EMC']['register_list'].append('TCLKSTABLE_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TCLKSTOP_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TCLKSTOP_0'] = {
    'addr'            : 0xa4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0xf,
    'array'           : False,
    'reset_mask'      : 0x1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f,
    'write_mask'      : 0x1f,
    'TCLKSTOP' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TCLKSTOP',
    ],
} # End of register: TCLKSTOP_0

registers['EMC']['register_list'].append('TCLKSTOP_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TREFBW_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TREFBW_0'] = {
    'addr'            : 0xa8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xe,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3fff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3fff,
    'write_mask'      : 0x3fff,
    'TREFBW' : {
        'lsb'               : 0,
        'msb'               : 13,
        'size'              : 14,
        'field'             : (0x3fff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TREFBW',
    ],
} # End of register: TREFBW_0

registers['EMC']['register_list'].append('TREFBW_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TPPD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TPPD_0'] = {
    'addr'            : 0xac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'TPPD' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TPPD',
    ],
} # End of register: TPPD_0

registers['EMC']['register_list'].append('TPPD_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TRTM_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRTM_0'] = {
    'addr'            : 0xbc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'TRTM' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TRTM',
    ],
} # End of register: TRTM_0

registers['EMC']['register_list'].append('TRTM_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TWTM_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TWTM_0'] = {
    'addr'            : 0xf8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'TWTM' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TWTM',
    ],
} # End of register: TWTM_0

registers['EMC']['register_list'].append('TWTM_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TRATM_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRATM_0'] = {
    'addr'            : 0xfc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'TRATM' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TRATM',
    ],
} # End of register: TRATM_0

registers['EMC']['register_list'].append('TRATM_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TWATM_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TWATM_0'] = {
    'addr'            : 0x108,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'TWATM' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TWATM',
    ],
} # End of register: TWATM_0

registers['EMC']['register_list'].append('TWATM_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TR2REF_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR2REF_0'] = {
    'addr'            : 0x10c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'TR2REF' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR2REF',
    ],
} # End of register: TR2REF_0

registers['EMC']['register_list'].append('TR2REF_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PDEX2MRR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PDEX2MRR_0'] = {
    'addr'            : 0xb4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x7f,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'PDEX2MRR' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x7f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PDEX2MRR',
    ],
} # End of register: PDEX2MRR_0

registers['EMC']['register_list'].append('PDEX2MRR_0')
# ODT may be enabled during writes via control of ODT pin.
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#

# Register EMC_ODT_WRITE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ODT_WRITE_0'] = {
    'addr'            : 0xb0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x80000f3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x80000f3f,
    'write_mask'      : 0x80000f3f,
    'ODT_WR_DELAY' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DRIVE_BOTH_ODT' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'SHARE_ONE_ODT' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ODT_WR_DURATION' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ENABLE_ODT_DURING_WRITE' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ODT_WR_DELAY',
        'DRIVE_BOTH_ODT',
        'SHARE_ONE_ODT',
        'ODT_WR_DURATION',
        'ENABLE_ODT_DURING_WRITE',
    ],
} # End of register: ODT_WRITE_0

registers['EMC']['register_list'].append('ODT_WRITE_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WEXT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WEXT_0'] = {
    'addr'            : 0xb8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f,
    'write_mask'      : 0x1f,
    'WEXT' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WEXT',
    ],
} # End of register: WEXT_0

registers['EMC']['register_list'].append('WEXT_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RFC_SLR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RFC_SLR_0'] = {
    'addr'            : 0xc0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ff,
    'write_mask'      : 0x1ff,
    'RFC_SLR' : {
        'lsb'               : 0,
        'msb'               : 8,
        'size'              : 9,
        'field'             : (0x1ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RFC_SLR',
    ],
} # End of register: RFC_SLR_0

registers['EMC']['register_list'].append('RFC_SLR_0')
# This register is shadowed: see usage note at top of spec file.
#
# This register allows the delay between a MRS/EMRS/MRW/MRR command and the following DRAM command
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRS_WAIT_CNT2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRS_WAIT_CNT2_0'] = {
    'addr'            : 0xc4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x208000f,
    'array'           : False,
    'reset_mask'      : 0xfff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff07ff,
    'write_mask'      : 0xfff07ff,
    'MRS_EXT1_WAIT_CNT' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MRS_EXT2_WAIT_CNT' : {
        'lsb'               : 16,
        'msb'               : 27,
        'size'              : 12,
        'field'             : (0xfff << 16),
        'woffset'           : 0x0,
        'default'           : 0x208,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRS_EXT1_WAIT_CNT',
        'MRS_EXT2_WAIT_CNT',
    ],
} # End of register: MRS_WAIT_CNT2_0

registers['EMC']['register_list'].append('MRS_WAIT_CNT2_0')
# This register is shadowed: see usage note at top of spec file.
#
# This register allows the delay between a MRS/EMRS/MRW/MRR command and the following DRAM command
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRS_WAIT_CNT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRS_WAIT_CNT_0'] = {
    'addr'            : 0xc8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x208000f,
    'array'           : False,
    'reset_mask'      : 0xfff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff07ff,
    'write_mask'      : 0xfff07ff,
    'MRS_SHORT_WAIT_CNT' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MRS_LONG_WAIT_CNT' : {
        'lsb'               : 16,
        'msb'               : 27,
        'size'              : 12,
        'field'             : (0xfff << 16),
        'woffset'           : 0x0,
        'default'           : 0x208,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRS_SHORT_WAIT_CNT',
        'MRS_LONG_WAIT_CNT',
    ],
} # End of register: MRS_WAIT_CNT_0

registers['EMC']['register_list'].append('MRS_WAIT_CNT_0')
# The MRS register allows SW to issue an MRS command.
#
# BA0, BA1 are used to address MRS or EMRS registers in DRAM.  Although this register can also program EMRS, use
# the EMRS register so that the HW registers can shadow what is in the DRAM.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRS_0'] = {
    'addr'            : 0xcc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcc303fff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcc303fff,
    'read_mask'       : 0xcc303fff,
    'write_mask'      : 0xcc303fff,
    'MRS_ADR' : {
        'lsb'               : 0,
        'msb'               : 13,
        'size'              : 14,
        'field'             : (0x3fff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRS_BA' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRS_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRS_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRS_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRS_ADR',
        'MRS_BA',
        'USE_MRS_LONG_CNT',
        'USE_MRS_EXT_CNT',
        'MRS_DEV_SELECTN',
    ],
} # End of register: MRS_0

registers['EMC']['register_list'].append('MRS_0')
# The EMRS register allows SW to issue an EMRS command.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_EMRS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['EMRS_0'] = {
    'addr'            : 0xd0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcc303fff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcc303fff,
    'read_mask'       : 0xcc303fff,
    'write_mask'      : 0xcc303fff,
    'EMRS_ADR' : {
        'lsb'               : 0,
        'msb'               : 13,
        'size'              : 14,
        'field'             : (0x3fff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMRS_BA' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_EMRS_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_EMRS_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMRS_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMRS_ADR',
        'EMRS_BA',
        'USE_EMRS_LONG_CNT',
        'USE_EMRS_EXT_CNT',
        'EMRS_DEV_SELECTN',
    ],
} # End of register: EMRS_0

registers['EMC']['register_list'].append('EMRS_0')
# The REF register allows SW to issue refresh commands.  This is done to ensure proper DRAM initialization.
#
# Boot requirements: This register triggers a refresh command. REF_CMD should be written with 0x1 during coldboot to trigger refresh commands during DRAM initialization.

# Register EMC_REF_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['REF_0'] = {
    'addr'            : 0xd4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xc007ff03,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xc007ff03,
    'read_mask'       : 0xc007ff03,
    'write_mask'      : 0xc007ff03,
    'REF_CMD' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'REF_NORMAL' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'REF_NUM' : {
        'lsb'               : 8,
        'msb'               : 18,
        'size'              : 11,
        'field'             : (0x7ff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'REF_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REF_CMD',
        'REF_NORMAL',
        'REF_NUM',
        'REF_DEV_SELECTN',
    ],
} # End of register: REF_0

registers['EMC']['register_list'].append('REF_0')
# The PRE register allows SW to issue a precharge all command. This command may be used to ensure proper DRAM initialization.
#
# Boot requirements: This register triggers a precharge-all command. PRE_CMD should be written with 0x1 during coldboot to trigger precharge commands during DRAM initialization.
# Boot requirements: If per-device DPD is used, the PRE_DEV_SELECTN field should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_PRE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PRE_0'] = {
    'addr'            : 0xd8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xc0000001,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xc0000001,
    'read_mask'       : 0xc0000001,
    'write_mask'      : 0xc0000001,
    'PRE_CMD' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PRE_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PRE_CMD',
        'PRE_DEV_SELECTN',
    ],
} # End of register: PRE_0

registers['EMC']['register_list'].append('PRE_0')
# The NOP register allows SW to issue an explicit nop command. This command may be used to ensure proper DRAM initialization.
#
# Boot requirements: This register triggers a no-operation command. NOP_CMD should be written with 0x1 during coldboot to trigger no-op commands during DRAM initialization.

# Register EMC_NOP_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['NOP_0'] = {
    'addr'            : 0xdc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xc0000001,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xc0000001,
    'read_mask'       : 0xc0000001,
    'write_mask'      : 0xc0000001,
    'NOP_CMD' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'NOP_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'NOP_CMD',
        'NOP_DEV_SELECTN',
    ],
} # End of register: NOP_0

registers['EMC']['register_list'].append('NOP_0')
# The SELF_REF register allows SW to issue self refresh commands.
#  LP4:  CKE follows SELF_REF_CMD
# Do not program this register when a clock change sequence is on-going: check CLKCHANGE_COMPLETE_INT value if not sure.

# Register EMC_SELF_REF_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SELF_REF_0'] = {
    'addr'            : 0xe0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xc0000101,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xc0000101,
    'read_mask'       : 0xc0000101,
    'write_mask'      : 0xc0000101,
    'SELF_REF_CMD' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ACTIVE_SELF_REF' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'SREF_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SELF_REF_CMD',
        'ACTIVE_SELF_REF',
        'SREF_DEV_SELECTN',
    ],
} # End of register: SELF_REF_0

registers['EMC']['register_list'].append('SELF_REF_0')
# The DPD register allows SW to issue a deep power down command.

# Register EMC_DPD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DPD_0'] = {
    'addr'            : 0xe4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xc0000001,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xc0000001,
    'read_mask'       : 0xc0000001,
    'write_mask'      : 0xc0000001,
    'DPD_CMD' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DPD_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DPD_CMD',
        'DPD_DEV_SELECTN',
    ],
} # End of register: DPD_0

registers['EMC']['register_list'].append('DPD_0')
#  Mode Register Write:  LPDDRx-only version of MRS/EMRS
#
# Boot requirements: This register triggers a mode register write command. Multiple mode-register writes may be required by the coldboot sequence. Such commands should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRW_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW_0'] = {
    'addr'            : 0xe8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xccff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xccff00ff,
    'read_mask'       : 0xccff00ff,
    'write_mask'      : 0xccff00ff,
    'MRW_OP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW_OP',
        'MRW_MA',
        'USE_MRW_LONG_CNT',
        'USE_MRW_EXT_CNT',
        'MRW_DEV_SELECTN',
    ],
} # End of register: MRW_0

registers['EMC']['register_list'].append('MRW_0')
# Mode Register Read:  For DRAM types supporting MRR (LPDDRx)
#     Sequence: 1. read MRR until EMC_STATUS.MRR_DIVLD=0 (ok to skip if it is sure there is no pending MRR reads)
#               2. write this register with the desired addr (MA) and device (DEV_SELECTN),
#                  device needs to be either DEV0 or DEV1: writing to both is illegal
#               3. poll EMC_STATUS.MRR_DIVLD=1, or if using interrupt, wait for MRR_DIVLD_INT
#               4. read back MRR. The value is in MRR_DATA field.
#     Note: It is ok to issue new MRR requests while there are on-going requests. e.g. to issue 3 MRR,
#           follow these steps: 1,2,2,2,3,4,3,4,3,4. Data read back in step 4 are in the same order requested in step 2.
#           To make sure EMC is avaialbe for new MRR requests, poll for EMC_STATUS.MRR_FIFO_SPACE > 0 before step 2.
# If using 2 x16 DRAM, MRR_DATA[15:8] can be used to store MRR from 2nd DRAM on same CS (configured via CFG_3.MRR_BYTESEL_X16)

# Register EMC_MRR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRR_0'] = {
    'addr'            : 0xec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xccff0000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xccff0000,
    'read_mask'       : 0xccffffff,
    'write_mask'      : 0xccff0000,
    'MRR_DATA' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'MRR_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRR_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRR_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRR_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'ILLEGAL' : 0,
            'DEV1' : 1,
            'DEV0' : 2,
            'RESERVED' : 3,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRR_DATA',
        'MRR_MA',
        'USE_MRR_LONG_CNT',
        'USE_MRR_EXT_CNT',
        'MRR_DEV_SELECTN',
    ],
} # End of register: MRR_0

registers['EMC']['register_list'].append('MRR_0')
# The CMDQ register controls the depth of the bank command queues.
# There are 3 queues.  One for R/W, one for precharge, and one for activate.
# They are read by the DRAM controller.  The hardware has queue depths
# of 16, 4, 4 respectively.  Restricting queue depth improves the latency time
# of the real time requestor.
# Note -- for the highest bandwidth utilization using 667MHz DDR3, RW_DEPTH should be set to 16
#  Better perf & utilization wll be realized w/ RW_WD_DEPTH > RW_DEPTH  (+WDV/2)? to prevent seamless write bursts
#  from stopping due to lack of space in data fifo. If RW_WD_DEPTH is set to 0, will use RW_DEPTH instead.
#  Probably no reason to limit RW_WD this depth as it would have minimal impact on latency.
#
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This arbitration configuration register should be parameterized in the BCT and written by the OS during coldboot and warmboot.

# Register EMC_CMDQ_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMDQ_0'] = {
    'addr'            : 0xf0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x10004408,
    'array'           : False,
    'reset_mask'      : 0x1f00771f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f00771f,
    'write_mask'      : 0x1f00771f,
    'RW_DEPTH' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ACT_DEPTH' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PRE_DEPTH' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RW_WD_DEPTH' : {
        'lsb'               : 24,
        'msb'               : 28,
        'size'              : 5,
        'field'             : (0x1f << 24),
        'woffset'           : 0x0,
        'default'           : 0x10,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RW_DEPTH',
        'ACT_DEPTH',
        'PRE_DEPTH',
        'RW_WD_DEPTH',
    ],
} # End of register: CMDQ_0

registers['EMC']['register_list'].append('CMDQ_0')
# The MC2EMC register controls the depth of the reqfifo/actfifo/wdfifo.
# Boot requirements: This arbitration configuration register should be parameterized in the BCT and written by the OS during coldboot and warmboot.
# This register is shadowed: see usage note at top of spec file.

# Register EMC_MC2EMCQ_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MC2EMCQ_0'] = {
    'addr'            : 0xf4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x6000404,
    'array'           : False,
    'reset_mask'      : 0xf000707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf000707,
    'write_mask'      : 0xf000707,
    'MCREQ_DEPTH' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MCACT_DEPTH' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MCWD_DEPTH' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MCREQ_DEPTH',
        'MCACT_DEPTH',
        'MCWD_DEPTH',
    ],
} # End of register: MC2EMCQ_0

registers['EMC']['register_list'].append('MC2EMCQ_0')
# removed DQS_STR_PULL_CTRL
# The FBIO_DQSIB_DLY registers have been removed.
# The trimmer value may be overridden by setting using MULT==0 and OFFS = val <<4
# The FBIO_SPARE register provides extra bits for future needs.
# They are connected to FBIO at the "common" pad macro, which is near the center of each fbio partition.
#
# NOTE: CFG_FBIO_SPARE_0[0]   = FBIO_SPARE[0]      = swap "dll_testdll[1:0]" bits.
# NOTE: CFG_FBIO_SPARE_0[1]   = FBIO_SPARE[1]      = lock further change to ADR_CFG, EMC_CMD_MAPPING_BYTE and EMC_CMD_MAPPING_CMD* registers.
# NOTE: CFG_FBIO_SPARE_3[3]   = FBIO_SPARE[27]    = CFG_EINPUT_FORCE_ON - when enabled, sets the EINPUT to 1
# NOTE: CFG_FBIO_SPARE_3[4]   = FBIO_SPARE[28]    = CFG_STATIC_PUTERM_DQ
# NOTE: CFG_FBIO_SPARE_3[5]   = FBIO_SPARE[29]    = CFG_SW_DLL_RST_N
# NOTE: CFG_FBIO_SPARE_3[7]   = FBIO_SPARE[31]    = disables DSR VTTGEN settings in single rank system
#
#
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: The CFG_FBIO_SPARE_3 should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_FBIO_SPARE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FBIO_SPARE_0'] = {
    'addr'            : 0x100,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'CFG_FBIO_SPARE_3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_FBIO_SPARE_2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_FBIO_SPARE_1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_FBIO_SPARE_0' : {
        'lsb'               : 2,
        'msb'               : 7,
        'size'              : 6,
        'field'             : (0x3f << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_ADR_EN' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_SWAP_DLL' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CFG_FBIO_SPARE_3',
        'CFG_FBIO_SPARE_2',
        'CFG_FBIO_SPARE_1',
        'CFG_FBIO_SPARE_0',
        'CFG_ADR_EN',
        'CFG_SWAP_DLL',
    ],
} # End of register: FBIO_SPARE_0

registers['EMC']['register_list'].append('FBIO_SPARE_0')
# The FBIO_CFG5 register controls the FBIO I/O cells.
#
# The following fields are shadowed: DIFFERENTIAL_DQS, CTT_TERMINATION, DQS_PULLD, CMD_2T_TIMING.
# Writes to these fields will not take effect until the active value is updated via TIMING_UPDATE or (if enabled) CLKCHANGE_REQ.
#
#
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register (except for field DISABLE_CONCURRENT_AUTOPRE) should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register (except for field DISABLE_CONCURRENT_AUTOPRE) should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_FBIO_CFG5_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FBIO_CFG5_0'] = {
    'addr'            : 0x104,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x10400015,
    'array'           : False,
    'reset_mask'      : 0xdff0f53f,
    'sw_default_val'  : 0x400010,
    'sw_default_mask' : 0xf00130,
    'read_mask'       : 0xdff0f53f,
    'write_mask'      : 0xdff0f53f,
    'DRAM_TYPE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
            'init_enum'  : "LPDDR4",
        'enums' : {
            'DDR3' : 0,
            'LPDDR4' : 1,
            'LPDDR2' : 2,
            'DDR2' : 3,
        },
    },
    'DRAM_BURST' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "BURST8",
        'enums' : {
            'BURST4' : 0,
            'BURST8' : 1,
            'ON_THE_FLY' : 2,
            'BURST16' : 3,
        },
    },
    'DRAM_WIDTH' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "X64",
        'enums' : {
            'X32' : 0,
            'X64' : 1,
            'X16' : 2,
        },
    },
    'CMD_TX_EN' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'ENABLED' : 0,
            'DISABLED' : 1,
        },
    },
    'DISABLE_CONCURRENT_AUTOPRE' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CMD_2T_TIMING' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'EMC2PMACRO_CFG_QUSE_MODE' : {
        'lsb'               : 13,
        'msb'               : 15,
        'size'              : 3,
        'field'             : (0x7 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "NORMAL",
        'enums' : {
            'NORMAL' : 0,
            'ALWAYS_ON' : 1,
            'INTERNAL_LPBK' : 2,
            'PULSE_INT' : 3,
            'RESERVED' : 4,
            'DIRECT_QUSE' : 5,
            'RESERVED1' : 6,
        },
    },
    'ERR_RD_BUBBLE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x4,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'LPDDR3_WR_PREAMBLE_TOGGLE' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'LPDDR3_DRAM' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CMD_BUS_RETURN_TO_ONE' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CMD_BUS_RETURN_TO_ZERO' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'MASK_PUTERM_N_DQS_PULLD_DURING_ZQCAL' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DATA_BUS_RETURN_TO_ONE' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DATA_BUS_RETURN_TO_ZERO' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_TYPE',
        'DRAM_BURST',
        'DRAM_WIDTH',
        'CMD_TX_EN',
        'DISABLE_CONCURRENT_AUTOPRE',
        'CMD_2T_TIMING',
        'EMC2PMACRO_CFG_QUSE_MODE',
        'ERR_RD_BUBBLE',
        'LPDDR3_WR_PREAMBLE_TOGGLE',
        'LPDDR3_DRAM',
        'CMD_BUS_RETURN_TO_ONE',
        'CMD_BUS_RETURN_TO_ZERO',
        'MASK_PUTERM_N_DQS_PULLD_DURING_ZQCAL',
        'DATA_BUS_RETURN_TO_ONE',
        'DATA_BUS_RETURN_TO_ZERO',
    ],
} # End of register: FBIO_CFG5_0

registers['EMC']['register_list'].append('FBIO_CFG5_0')
# QUSE_LATE  determine how much added delay fbio
# should add to the QUSE path.  QUSE needs to align (approximately)
# with the incoming DQS in order to qualify it, since the
# incoming DQS/feedback clock is not always valid.
#
# DRAMC can position QUSE with m2clk granularity (2 bit
# times).  QUSE_LATE provides finer granularity of 1/2 an
# m2clk cycle (1/2 bit time).  The amount of delay we add will be primarily a
# function of the round trip wire delay to/from the DRAM.  Other
# portions of the delay (driver and receiver delay) are compensated for
# by delay through a non-bonded QUSE pad cell.
#
# additional delay can be added to QUSE vi XFORM_QUSEx_MULT and XFORM_QUSEx_OFFS (applied to DLL offset).
#
# EMC configuration Reserved
#
# These bits are not connected to anything and are reserved for ECO's.
#
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_CFG_RSV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_RSV_0'] = {
    'addr'            : 0x120,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xff00ff00,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'CFG_RESERVED_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_RESERVED_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0xff,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_RESERVED_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_RESERVED_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0xff,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CFG_RESERVED_BYTE0',
        'CFG_RESERVED_BYTE1',
        'CFG_RESERVED_BYTE2',
        'CFG_RESERVED_BYTE3',
    ],
} # End of register: CFG_RSV_0

registers['EMC']['register_list'].append('CFG_RSV_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_ACPD_CONTROL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ACPD_CONTROL_0'] = {
    'addr'            : 0x124,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'ACPD_THRESHOLD' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ACPD_THRESHOLD',
    ],
} # End of register: ACPD_CONTROL_0

registers['EMC']['register_list'].append('ACPD_CONTROL_0')
#MPC cmd is only supported for LP4

# Register EMC_MPC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MPC_0'] = {
    'addr'            : 0x128,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcc0003ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcc0003ff,
    'read_mask'       : 0xcc0003ff,
    'write_mask'      : 0xcc0003ff,
    'MPC_OP' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MPC_CAS2' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MPC_RD' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MPC_WR' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MPC_SUBP_SELECTN' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MPC_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MPC_OP',
        'MPC_CAS2',
        'MPC_RD',
        'MPC_WR',
        'MPC_SUBP_SELECTN',
        'MPC_DEV_SELECTN',
    ],
} # End of register: MPC_0

registers['EMC']['register_list'].append('MPC_0')
# The EMRS2 register allows SW to issue an EMRS2 command.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_EMRS2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['EMRS2_0'] = {
    'addr'            : 0x12c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcc303fff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcc303fff,
    'read_mask'       : 0xcc303fff,
    'write_mask'      : 0xcc303fff,
    'EMRS2_ADR' : {
        'lsb'               : 0,
        'msb'               : 13,
        'size'              : 14,
        'field'             : (0x3fff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMRS2_BA' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_EMRS2_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_EMRS2_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMRS2_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMRS2_ADR',
        'EMRS2_BA',
        'USE_EMRS2_LONG_CNT',
        'USE_EMRS2_EXT_CNT',
        'EMRS2_DEV_SELECTN',
    ],
} # End of register: EMRS2_0

registers['EMC']['register_list'].append('EMRS2_0')
# The EMRS3 register allows SW to issue an EMRS3 command.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_EMRS3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['EMRS3_0'] = {
    'addr'            : 0x130,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcc303fff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcc303fff,
    'read_mask'       : 0xcc303fff,
    'write_mask'      : 0xcc303fff,
    'EMRS3_ADR' : {
        'lsb'               : 0,
        'msb'               : 13,
        'size'              : 14,
        'field'             : (0x3fff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMRS3_BA' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_EMRS3_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_EMRS3_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMRS3_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMRS3_ADR',
        'EMRS3_BA',
        'USE_EMRS3_LONG_CNT',
        'USE_EMRS3_EXT_CNT',
        'EMRS3_DEV_SELECTN',
    ],
} # End of register: EMRS3_0

registers['EMC']['register_list'].append('EMRS3_0')
#  Mode Register Write:  LPDDRx-only version of MRS/EMRS
#
# Boot requirements: This register triggers a mode register write command. Multiple mode-register writes may be required by the coldboot sequence. Such commands should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRW2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW2_0'] = {
    'addr'            : 0x134,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xccff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xccff00ff,
    'read_mask'       : 0xccff00ff,
    'write_mask'      : 0xccff00ff,
    'MRW2_OP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW2_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW2_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW2_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW2_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW2_OP',
        'MRW2_MA',
        'USE_MRW2_LONG_CNT',
        'USE_MRW2_EXT_CNT',
        'MRW2_DEV_SELECTN',
    ],
} # End of register: MRW2_0

registers['EMC']['register_list'].append('MRW2_0')
#  Mode Register Write:  LPDDRx-only version of MRS/EMRS
#
# Boot requirements: This register triggers a mode register write command. Multiple mode-register writes may be required by the coldboot sequence. Such commands should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRW3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW3_0'] = {
    'addr'            : 0x138,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xccff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xccff00ff,
    'read_mask'       : 0xccff00ff,
    'write_mask'      : 0xccff00ff,
    'MRW3_OP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW3_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW3_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW3_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW3_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW3_OP',
        'MRW3_MA',
        'USE_MRW3_LONG_CNT',
        'USE_MRW3_EXT_CNT',
        'MRW3_DEV_SELECTN',
    ],
} # End of register: MRW3_0

registers['EMC']['register_list'].append('MRW3_0')
#  Mode Register Write:  LPDDRx-only version of MRS/EMRS
#
# Boot requirements: This register triggers a mode register write command. Multiple mode-register writes may be required by the coldboot sequence. Such commands should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRW4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW4_0'] = {
    'addr'            : 0x13c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xccff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xccff00ff,
    'read_mask'       : 0xccff00ff,
    'write_mask'      : 0xccff00ff,
    'MRW4_OP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW4_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW4_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW4_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW4_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW4_OP',
        'MRW4_MA',
        'USE_MRW4_LONG_CNT',
        'USE_MRW4_EXT_CNT',
        'MRW4_DEV_SELECTN',
    ],
} # End of register: MRW4_0

registers['EMC']['register_list'].append('MRW4_0')
#  Mode Register Write:  LPDDRx-only version of MRS/EMRS
#

# Register EMC_MRW5_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW5_0'] = {
    'addr'            : 0x4a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xccff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xccff00ff,
    'read_mask'       : 0xccff00ff,
    'write_mask'      : 0xccff00ff,
    'MRW5_OP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW5_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW5_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW5_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW5_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW5_OP',
        'MRW5_MA',
        'USE_MRW5_LONG_CNT',
        'USE_MRW5_EXT_CNT',
        'MRW5_DEV_SELECTN',
    ],
} # End of register: MRW5_0

registers['EMC']['register_list'].append('MRW5_0')
#  The following Mode Registers (MRW6-MRW15) are added for LPDDR4 support; however, they can be used for LPDDRx. They add sub-partition support.
#  They always use short MRS wait count to satisfy tMRW.
#
# Boot requirements: This register triggers a mode register write command. Multiple mode-register writes may be required by the coldboot sequence. Such commands should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_MRW6_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW6_0'] = {
    'addr'            : 0x4a4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW6_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW6_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW6_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW6_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW6_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW6_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW6_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW6_OP_SP0',
        'MRW6_OP_SP1',
        'MRW6_MA',
        'MRW6_SP_SELECTN',
        'USE_MRW6_LONG_CNT',
        'USE_MRW6_EXT_CNT',
        'MRW6_DEV_SELECTN',
    ],
} # End of register: MRW6_0

registers['EMC']['register_list'].append('MRW6_0')

# Register EMC_MRW7_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW7_0'] = {
    'addr'            : 0x4a8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW7_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW7_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW7_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW7_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW7_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW7_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW7_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW7_OP_SP0',
        'MRW7_OP_SP1',
        'MRW7_MA',
        'MRW7_SP_SELECTN',
        'USE_MRW7_LONG_CNT',
        'USE_MRW7_EXT_CNT',
        'MRW7_DEV_SELECTN',
    ],
} # End of register: MRW7_0

registers['EMC']['register_list'].append('MRW7_0')

# Register EMC_MRW8_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW8_0'] = {
    'addr'            : 0x4ac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW8_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW8_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW8_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW8_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW8_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW8_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW8_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW8_OP_SP0',
        'MRW8_OP_SP1',
        'MRW8_MA',
        'MRW8_SP_SELECTN',
        'USE_MRW8_LONG_CNT',
        'USE_MRW8_EXT_CNT',
        'MRW8_DEV_SELECTN',
    ],
} # End of register: MRW8_0

registers['EMC']['register_list'].append('MRW8_0')

# Register EMC_MRW9_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW9_0'] = {
    'addr'            : 0x4b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW9_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW9_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW9_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW9_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW9_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW9_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW9_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW9_OP_SP0',
        'MRW9_OP_SP1',
        'MRW9_MA',
        'MRW9_SP_SELECTN',
        'USE_MRW9_LONG_CNT',
        'USE_MRW9_EXT_CNT',
        'MRW9_DEV_SELECTN',
    ],
} # End of register: MRW9_0

registers['EMC']['register_list'].append('MRW9_0')

# Register EMC_MRW10_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW10_0'] = {
    'addr'            : 0x4b4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW10_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW10_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW10_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW10_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW10_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW10_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW10_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW10_OP_SP0',
        'MRW10_OP_SP1',
        'MRW10_MA',
        'MRW10_SP_SELECTN',
        'USE_MRW10_LONG_CNT',
        'USE_MRW10_EXT_CNT',
        'MRW10_DEV_SELECTN',
    ],
} # End of register: MRW10_0

registers['EMC']['register_list'].append('MRW10_0')

# Register EMC_MRW11_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW11_0'] = {
    'addr'            : 0x4b8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW11_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW11_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW11_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW11_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW11_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW11_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW11_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW11_OP_SP0',
        'MRW11_OP_SP1',
        'MRW11_MA',
        'MRW11_SP_SELECTN',
        'USE_MRW11_LONG_CNT',
        'USE_MRW11_EXT_CNT',
        'MRW11_DEV_SELECTN',
    ],
} # End of register: MRW11_0

registers['EMC']['register_list'].append('MRW11_0')

# Register EMC_MRW12_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW12_0'] = {
    'addr'            : 0x4bc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW12_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW12_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW12_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW12_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW12_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW12_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW12_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW12_OP_SP0',
        'MRW12_OP_SP1',
        'MRW12_MA',
        'MRW12_SP_SELECTN',
        'USE_MRW12_LONG_CNT',
        'USE_MRW12_EXT_CNT',
        'MRW12_DEV_SELECTN',
    ],
} # End of register: MRW12_0

registers['EMC']['register_list'].append('MRW12_0')

# Register EMC_MRW13_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW13_0'] = {
    'addr'            : 0x4c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW13_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW13_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW13_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW13_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW13_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW13_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW13_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW13_OP_SP0',
        'MRW13_OP_SP1',
        'MRW13_MA',
        'MRW13_SP_SELECTN',
        'USE_MRW13_LONG_CNT',
        'USE_MRW13_EXT_CNT',
        'MRW13_DEV_SELECTN',
    ],
} # End of register: MRW13_0

registers['EMC']['register_list'].append('MRW13_0')

# Register EMC_MRW14_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW14_0'] = {
    'addr'            : 0x4c4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xcfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xcfffffff,
    'read_mask'       : 0xcfffffff,
    'write_mask'      : 0xcfffffff,
    'MRW14_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW14_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW14_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW14_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW14_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW14_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW14_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW14_OP_SP0',
        'MRW14_OP_SP1',
        'MRW14_MA',
        'MRW14_SP_SELECTN',
        'USE_MRW14_LONG_CNT',
        'USE_MRW14_EXT_CNT',
        'MRW14_DEV_SELECTN',
    ],
} # End of register: MRW14_0

registers['EMC']['register_list'].append('MRW14_0')

# Register EMC_MRW15_0   -- modified by Gil Jung. just for dvfs_editor 
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MRW15_0'] = {
    'addr'            : 0x4d0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x000000ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x000000ff,
    'read_mask'       : 0x000000ff,
    'write_mask'      : 0x000000ff,
    'MRW15_OP_SP0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW15_OP_SP1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW15_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW15_SP_SELECTN' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'USE_MRW15_LONG_CNT' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SHORT",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'USE_MRW15_EXT_CNT' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRW15_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRW15_OP_SP0',
    #    'MRW15_OP_SP1',
    #    'MRW15_MA',
    #    'MRW15_SP_SELECTN',
    #    'USE_MRW15_LONG_CNT',
    #    'USE_MRW15_EXT_CNT',
    #    'MRW15_DEV_SELECTN',
    ],
} # End of register: MRW15_0

registers['EMC']['register_list'].append('MRW15_0')

# Register EMC_CFG_SYNC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_SYNC_0'] = {
    'addr'            : 0x4d4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x2,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x3,
    'read_mask'       : 0x3,
    'write_mask'      : 0x3,
    'CHANNEL_SYNC' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PARTITION_SYNC' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CHANNEL_SYNC',
        'PARTITION_SYNC',
    ],
} # End of register: CFG_SYNC_0

registers['EMC']['register_list'].append('CFG_SYNC_0')
# Second-level clock enable override register
#
# This can override the 2nd level clock enables in case of malfunction.
# Of course it precludes that it is possible to access this register.
# Only expose to SW when needed.

# Register EMC_CLKEN_OVERRIDE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CLKEN_OVERRIDE_0'] = {
    'addr'            : 0x140,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x10200,
    'array'           : False,
    'reset_mask'      : 0x80130fce,
    'sw_default_val'  : 0x10200,
    'sw_default_mask' : 0x80130fce,
    'read_mask'       : 0x80130fce,
    'write_mask'      : 0x80130fce,
    'CMDQ_CLKEN_OVR' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DRAMC_CLKEN_OVR' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RR_CLKEN_OVR' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'STATS_CLKEN_OVR' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'TR_CLKEN_OVR' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'PAD_CONFIG_OVR' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'BIST_CLKEN_OVR' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_ALWAYS_ON",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'REG_CLKEN_OVR' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'PMREG_CLKEN_OVR' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RDRSP_CLKEN_OVR' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_ALWAYS_ON",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CPU_RDRSP_CLKEN_OVR' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'EMC_CLK_OVR_ON' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_GATED",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'OBS_BUS_CLKEN' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMDQ_CLKEN_OVR',
        'DRAMC_CLKEN_OVR',
        'RR_CLKEN_OVR',
        'STATS_CLKEN_OVR',
        'TR_CLKEN_OVR',
        'PAD_CONFIG_OVR',
        'BIST_CLKEN_OVR',
        'REG_CLKEN_OVR',
        'PMREG_CLKEN_OVR',
        'RDRSP_CLKEN_OVR',
        'CPU_RDRSP_CLKEN_OVR',
        'EMC_CLK_OVR_ON',
        'OBS_BUS_CLKEN',
    ],
} # End of register: CLKEN_OVERRIDE_0

registers['EMC']['register_list'].append('CLKEN_OVERRIDE_0')
# Include mc2emc and emc2host1x packet definitions
# --------------------------------------------------------------------------
#
# Copyright (c) 2006, NVIDIA Corp.
# All Rights Reserved.
#
# This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
# the contents of this file may not be disclosed to third parties, copied or
# duplicated in any form, in whole or in part, without the prior written
# permission of NVIDIA Corp.
#
# RESTRICTED RIGHTS LEGEND:
# Use, duplication or disclosure by the Government is subject to restrictions
# as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
# and Computer Software clause at DFARS 252.227-7013, and/or in similar or
# successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
# rights reserved under the Copyright Laws of the United States.
#
# --------------------------------------------------------------------------
#
#     Direct-client is: mll_mpcorer
# User defined flags for AXI AR read address channel
# Tegra AXI Socket Specification, revision 0.58

# Packet AXI_AR_USER_PKT
packets['AXI_AR_USER_PKT'] = {
    'size' :  29,
    # Field: AXI_AR_USER_PKT.STREAM_ID
    'STREAM_ID' : {
        'lsb'        : 0,
        'msb'        : 7,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.COH_IO_ACC
    'COH_IO_ACC' : {
        'lsb'        : 8,
        'msb'        : 8,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.RSB_NS
    'RSB_NS' : {
        'lsb'        : 9,
        'msb'        : 9,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 1,
        },
    },
    # Field: AXI_AR_USER_PKT.VPR_RD
    'VPR_RD' : {
        'lsb'        : 10,
        'msb'        : 10,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.GSC_AID
    'GSC_AID' : {
        'lsb'        : 11,
        'msb'        : 15,
        'size'       : 5,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.GSC_AL
    'GSC_AL' : {
        'lsb'        : 16,
        'msb'        : 17,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.ADR5
    'ADR5' : {
        'lsb'        : 18,
        'msb'        : 18,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.ADR1
    'ADR1' : {
        'lsb'        : 19,
        'msb'        : 21,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.SP_AWARE
    'SP_AWARE' : {
        'lsb'        : 22,
        'msb'        : 22,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AR_USER_PKT.RESERVED
    'RESERVED' : {
        'lsb'        : 23,
        'msb'        : 28,
        'size'       : 6,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'STREAM_ID',
        'COH_IO_ACC',
        'RSB_NS',
        'VPR_RD',
        'GSC_AID',
        'GSC_AL',
        'ADR5',
        'ADR1',
        'SP_AWARE',
        'RESERVED',
    ],
} # End of packet: AXI_AR_USER_PKT

# User defined flags for AXI AW write address channel
# Tegra AXI Socket Specification, revision 0.58

# Packet AXI_AW_USER_PKT
packets['AXI_AW_USER_PKT'] = {
    'size' :  29,
    # Field: AXI_AW_USER_PKT.STREAM_ID
    'STREAM_ID' : {
        'lsb'        : 0,
        'msb'        : 7,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.COH_IO_ACC
    'COH_IO_ACC' : {
        'lsb'        : 8,
        'msb'        : 8,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.WSB_NS
    'WSB_NS' : {
        'lsb'        : 9,
        'msb'        : 9,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 1,
        },
    },
    # Field: AXI_AW_USER_PKT.VPR_WR
    'VPR_WR' : {
        'lsb'        : 10,
        'msb'        : 10,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.GSC_AID
    'GSC_AID' : {
        'lsb'        : 11,
        'msb'        : 15,
        'size'       : 5,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.GSC_AL
    'GSC_AL' : {
        'lsb'        : 16,
        'msb'        : 17,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.ADR5
    'ADR5' : {
        'lsb'        : 18,
        'msb'        : 18,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.ADR1
    'ADR1' : {
        'lsb'        : 19,
        'msb'        : 21,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.SP_AWARE
    'SP_AWARE' : {
        'lsb'        : 22,
        'msb'        : 22,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_AW_USER_PKT.RESERVED
    'RESERVED' : {
        'lsb'        : 23,
        'msb'        : 28,
        'size'       : 6,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'STREAM_ID',
        'COH_IO_ACC',
        'WSB_NS',
        'VPR_WR',
        'GSC_AID',
        'GSC_AL',
        'ADR5',
        'ADR1',
        'SP_AWARE',
        'RESERVED',
    ],
} # End of packet: AXI_AW_USER_PKT

# User defined flags for AXI R read data channel
# Tegra AXI Socket Specification, revision 0.58

# Packet AXI_R_USER_PKT
packets['AXI_R_USER_PKT'] = {
    'size' :  2,
    # Field: AXI_R_USER_PKT.VPR_RD
    'VPR_RD' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Field: AXI_R_USER_PKT.VPR_ID
    'VPR_ID' : {
        'lsb'        : 1,
        'msb'        : 1,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'INIT' : 0,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'VPR_RD',
        'VPR_ID',
    ],
} # End of packet: AXI_R_USER_PKT

# axi_ar/aw packet macro
# axi_w packet macro
# axi_b packet macro
# axi_r packet macro
# LOWERCASE VERSIONS
# axi_ar/aw packet macro
# axi_w packet macro
# axi_b packet macro
# axi_r packet macro
# axi_ar/aw reg macro
# Internal/external memory sequencer data fifo depth
#   The depth should be equal to the number of pipe stages between when
#   we send a dordy to a client till we receive the data from the client,
#   plus 1 (because the fifo wr_ready signal is registered).
#   The external memory arbiter can only produce one request every other
#   cycle, so we can divide the number of pipe stages by 2, i.e. ceil(3/2) = 2,
#   plus 1 (same reason as above). However, need to add one more for GART, since
#   that adds an extra cycle before DFIFO can be popped.
#   For the internal memory sequencer, we need at add 1 more to absorb
#   the bubble created by requesting to the wrong bank.
#   If we have two banks, we have one fifo per bank and we can decrease
#   the fifo depth by 1 or 2. Smaller depths would decrease performance
#   significantly.
defines['NV_MC_EMEM_DFIFO_DEPTH'] = 3
defines['NV_MC_IMEM_DFIFO_DEPTH'] = 5
# Clear auto-precharge bit fifo depth
#   The depth should be equal to the data fifo depth plus 1 because the
#   data fifo has a bypass register. We only push in one entry per request
#   even for wide requests.
defines['NV_MC_EMEM_APFIFO_DEPTH'] = 4
# External memory arbiter
#   Level where the binary competition tree is divided for timing reasons.
#   Results at this level are registered before being used by subsequent levels.
defines['NV_MC_ARB_EMEM_REGLEVEL'] = 3
# External memory request/return data ID sideband bits
# WIDEREQ: Indicates that this request is for a (NV_MC_EMEM_MW*2)-bit client
#          (note that normal clients are NV_MC_EMEM_MW-bits data width).
#          Used by MC to delay return data to partition client
#          until full (NV_MC_EMEM_MW*2)-bits are available.
# ILLEGALACC: Indicates that this request should be dropped
#             by the EMC. Drops will occur due to out-of-bounds
#             address or (for writes) all-zero byte-enable. Used
#             by MC to force 1's on return data. Used by EMC to
#             drop.
# LLRAWDECR: Indicates that the EMC's LL logic should decrement
#            it's Read-After-Write coherency counters for this
#            request. Used in conjunction with MC2EMC_ARBINFO_* bus.
# APCIGNORE: Indicates that the EMC's APC logic should ignore
#            this request. Used in conjunction with MC2EMC_APC_* bus.
defines['NV_MC_EMEM_REQ_ID_WIDEREQ'] = 8
defines['NV_MC_EMEM_RDI_ID_WIDERDI'] = 8
defines['NV_MC_EMEM_REQ_ID_ILLEGALACC'] = 7
defines['NV_MC_EMEM_RDI_ID_ILLEGALACC'] = 7
defines['NV_MC_EMEM_REQ_ID_LLRAWDECR'] = 6
defines['NV_MC_EMEM_RDI_ID_LLRAWDECR'] = 6
defines['NV_MC_EMEM_REQ_ID_APCIGNORE'] = 5
defines['NV_MC_EMEM_RDI_ID_APCIGNORE'] = 5
# ########################## Internal packet definitions ######################
# Packet for dvs_mc2emc bus
# MC2EMC_*: This is the request path for EMEM requests, paired with EMC2MC_*.
# mc2emc_rdy : response portion of handshake (~stall)
# mc2emc_req : request portion of handshake (valid)
#              Each request corresponds to NV_MC_EMEM_WR_MW-bits of data.
# mc2emc_we  : write indication. if 0, request is a read. if 1, request is a write.
# mc2emc_wdo : write data out, only valid on write requests.
# mc2emc_be  : byte enables, only valid on write requests?
# mc2emc_dev : DRAM address: device number, when there's more than one DRAM chip attached
# mc2emc_bank: DRAM address: bank
# mc2emc_row : DRAM address: row
# mc2emc_col : DRAM address: col
# mc2emc_req_id : request id, used for return-data routing and sideband bits (see above)
# mc2emc_tag : low-latency tag, used for merge.
#              if tag==0, this request is not a duplicate of a low-latency path request
#              else, this request is a duplicate, EMC may kill the request if
#                    it has already been serviced
# mc2emc_ap  : auto-precharge suggested for this request

# Packet MC2EMC
packets['MC2EMC'] = {
    'size' :  375,
    # Field: MC2EMC.WDO
    'WDO' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.WDO_0
    'WDO_0' : {
        'lsb'        : 0,
        'msb'        : 63,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.WDO_1
    'WDO_1' : {
        'lsb'        : 64,
        'msb'        : 127,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.WDO_2
    'WDO_2' : {
        'lsb'        : 128,
        'msb'        : 191,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.WDO_3
    'WDO_3' : {
        'lsb'        : 192,
        'msb'        : 255,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.BE
    'BE' : {
        'lsb'        : 256,
        'msb'        : 287,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.DEV
    'DEV' : {
        'lsb'        : 320,
        'msb'        : 320,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.BANK
    'BANK' : {
        'lsb'        : 321,
        'msb'        : 323,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.ROW
    'ROW' : {
        'lsb'        : 324,
        'msb'        : 340,
        'size'       : 17,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.COL
    'COL' : {
        'lsb'        : 341,
        'msb'        : 352,
        'size'       : 12,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.REQ_ID
    'REQ_ID' : {
        'lsb'        : 353,
        'msb'        : 361,
        'size'       : 9,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.AP
    'AP' : {
        'lsb'        : 362,
        'msb'        : 362,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.WE
    'WE' : {
        'lsb'        : 363,
        'msb'        : 363,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC.TAG
    'TAG' : {
        'lsb'        : 364,
        'msb'        : 374,
        'size'       : 11,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'WDO',
        'WDO_0',
        'WDO_1',
        'WDO_2',
        'WDO_3',
        'BE',
        'DEV',
        'BANK',
        'ROW',
        'COL',
        'REQ_ID',
        'AP',
        'WE',
        'TAG',
    ],
} # End of packet: MC2EMC

# Packet for dv_emc2mc bus
# EMC2MC_*: This is the response path for EMEM requests, paired with MC2EMC_*.
# mc2emc_divld  : data in valid, indicates rdi and rdi_id are valid this cycle
# mc2emc_rdi    : read data in
# mc2emc_rdi_id : the req_id corresponding to the current rdi, used to route return
#                 data to the appropriate client

# Packet EMC2MC
packets['EMC2MC'] = {
    'size' :  265,
    # Field: EMC2MC.RDI
    'RDI' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: EMC2MC.RDI_0
    'RDI_0' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: EMC2MC.RDI_1
    'RDI_1' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: EMC2MC.RDI_2
    'RDI_2' : {
        'lsb'        : 64,
        'msb'        : 95,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: EMC2MC.RDI_3
    'RDI_3' : {
        'lsb'        : 96,
        'msb'        : 127,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: EMC2MC.RDI_ID
    'RDI_ID' : {
        'lsb'        : 256,
        'msb'        : 264,
        'size'       : 9,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDI',
        'RDI_0',
        'RDI_1',
        'RDI_2',
        'RDI_3',
        'RDI_ID',
    ],
} # End of packet: EMC2MC

# Packet for dvs_mc2emc_ll bus
# MC2EMC_LL_<CLIENT>_*: This is the low-latency bypass request, paired with EMC2MC_LL_<CLIENT>_*.
# mc2emc_ll_*_rdy  : response portion of handshake (~stall)
# mc2emc_ll_*_req  : request portion of handshake (valid)
#                    Each request corresponds to NV_MC_EMEM_MW-bits of data, except...
# mc2emc_ll_*_doublereq : Indicates that this request is for (2*NV_MC_EMEM_MW-bits) of data.
#                    If !doublereq, the col address must be aligned to NV_MC_EMEM_MW.
#                    If doublereq, the col address may be aligned to NV_MC_EMEM_MW/4 to
#                    take advantage of DRAM critical-word first data ordering.
# mc2emc_ll_*_dev  : DRAM address: device number, when there's more than one DRAM chip attached
# mc2emc_ll_*_bank : DRAM address: bank
# mc2emc_ll_*_row  : DRAM address: row
# mc2emc_ll_*_col  : DRAM address: col
# mc2emc_ll_*_tag  : low-latency tag, used for merge.
#              if tag==0, this request is not a duplicate of a low-latency path request
#              else, this request is a duplicate, EMC may kill the request if
#                    it has already been serviced

# Packet MC2EMC_LL
packets['MC2EMC_LL'] = {
    'size' :  45,
    # Field: MC2EMC_LL.DEV
    'DEV' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC_LL.BANK
    'BANK' : {
        'lsb'        : 1,
        'msb'        : 3,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC_LL.ROW
    'ROW' : {
        'lsb'        : 4,
        'msb'        : 20,
        'size'       : 17,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC_LL.COL
    'COL' : {
        'lsb'        : 21,
        'msb'        : 32,
        'size'       : 12,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC_LL.TAG
    'TAG' : {
        'lsb'        : 33,
        'msb'        : 43,
        'size'       : 11,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC2EMC_LL.DOUBLEREQ
    'DOUBLEREQ' : {
        'lsb'        : 44,
        'msb'        : 44,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'DEV',
        'BANK',
        'ROW',
        'COL',
        'TAG',
        'DOUBLEREQ',
    ],
} # End of packet: MC2EMC_LL

# Packet for dv_emc2mc_ll bus
# EMC2MC_LL_<CLIENT>_*: This is the low-latency bypass response, paired with MC2MC_LL_<CLIENT>_*.
# mc2emc_ll_*_divld : data in valid, indicates rdi is valid this cycle
# mc2emc_ll_*_rdi   : read data in

# Packet EMC2MC_LL
packets['EMC2MC_LL'] = {
    'size' :  256,
    # Field: EMC2MC_LL.RDI
    'RDI' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDI',
    ],
} # End of packet: EMC2MC_LL

# Definitions for cmc2mc_axi packets
# Packet for cmc2mc_axi_ar/cmc2mc_axi_aw

# Packet CMC2MC_AXI_A
packets['CMC2MC_AXI_A'] = {
    'size' :  63,
    # Field: CMC2MC_AXI_A.AADDR
    'AADDR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_A.AID
    'AID' : {
        'lsb'        : 32,
        'msb'        : 44,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_A.ALEN
    'ALEN' : {
        'lsb'        : 45,
        'msb'        : 48,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'ONEDATA' : 0,
            'TWODATA' : 1,
            'THREEDATA' : 2,
            'FOURDATA' : 3,
            'FIVEDATA' : 4,
            'SIXDATA' : 5,
            'SEVENDATA' : 6,
            'EIGHTDATA' : 7,
            'NINEDATA' : 8,
            'TENDATA' : 9,
            'ELEVENDATA' : 10,
            'TWELVEDATA' : 11,
            'THIRTEENDATA' : 12,
            'FOURTEENDATA' : 13,
            'FIFTHTEENDATA' : 14,
            'SIXTEENDATA' : 15,
        },
    },
    # Field: CMC2MC_AXI_A.ASIZE
    'ASIZE' : {
        'lsb'        : 49,
        'msb'        : 51,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'ONEBYTE' : 0,
            'TWOBYTES' : 1,
            'FOURBYTES' : 2,
            'EIGHTBYTES' : 3,
            'SIXTEENBYTES' : 4,
            'THIRTYTWOBYTES' : 5,
            'SIXTYFOURBYTES' : 6,
            'ONEHUNDREDTWENTYEIGHTBYTES' : 7,
        },
    },
    # Field: CMC2MC_AXI_A.ABURST
    'ABURST' : {
        'lsb'        : 52,
        'msb'        : 53,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'FIXED' : 0,
            'INCR' : 1,
            'WRAP' : 2,
            'RSVD' : 3,
        },
    },
    # Field: CMC2MC_AXI_A.ALOCK
    'ALOCK' : {
        'lsb'        : 54,
        'msb'        : 55,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'NORMAL' : 0,
            'EXCLUSIVE' : 1,
            'LOCKED' : 2,
            'RSVD' : 3,
        },
    },
    # Field: CMC2MC_AXI_A.ACACHE
    'ACACHE' : {
        'lsb'        : 56,
        'msb'        : 59,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'NONCACHEABLE_NONBUFFERABLE' : 0,
            'BUFFERABLE' : 1,
            'CACHEABLE_DONOTALLOCATE' : 2,
            'CACHEABLE_BUFFERABLE_DONOTALLOCATE' : 3,
            'CACHEABLEWRITETHROUGH_ALLOCATEONREAD' : 6,
            'CACHEABLEWRITEBACK_ALLOCATEONREAD' : 7,
            'CACHEABLEWRITETHROUGH_ALLOCATEONWRITE' : 10,
            'CACHEABLEWRITEBACK_ALLOCATEONWRITE' : 11,
            'CACHEABLEWRITETHROUGH_ALLOCATEONREADWRITE' : 14,
            'CACHEABLEWRITEBACK_ALLOCATEONREADWRITE' : 15,
        },
    },
    # Field: CMC2MC_AXI_A.APROT
    'APROT' : {
        'lsb'        : 60,
        'msb'        : 62,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DATA_SECURE_NORMAL' : 0,
            'DATA_SECURE_PRIVILEGED' : 1,
            'DATA_NONSECURE_NORMAL' : 2,
            'DATA_NONSECURE_PRIVILEGED' : 3,
            'INST_SECURE_NORMAL' : 4,
            'INST_SECURE_PRIVILEGED' : 5,
            'INST_NONSECURE_NORMAL' : 6,
            'INST_NONSECURE_PRIVILEGED' : 7,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'AADDR',
        'AID',
        'ALEN',
        'ASIZE',
        'ABURST',
        'ALOCK',
        'ACACHE',
        'APROT',
    ],
} # End of packet: CMC2MC_AXI_A

# Packet for cmc2mc_axi_w

# Packet CMC2MC_AXI_W
packets['CMC2MC_AXI_W'] = {
    'size' :  86,
    # Field: CMC2MC_AXI_W.WDATA
    'WDATA' : {
        'lsb'        : 0,
        'msb'        : 63,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_W.WID
    'WID' : {
        'lsb'        : 64,
        'msb'        : 76,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_W.WSTRB
    'WSTRB' : {
        'lsb'        : 77,
        'msb'        : 84,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_W.WLAST
    'WLAST' : {
        'lsb'        : 85,
        'msb'        : 85,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'WDATA',
        'WID',
        'WSTRB',
        'WLAST',
    ],
} # End of packet: CMC2MC_AXI_W

# Packet for cmc2mc_axi_b

# Packet CMC2MC_AXI_B
packets['CMC2MC_AXI_B'] = {
    'size' :  15,
    # Field: CMC2MC_AXI_B.BID
    'BID' : {
        'lsb'        : 0,
        'msb'        : 12,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_B.BRESP
    'BRESP' : {
        'lsb'        : 13,
        'msb'        : 14,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'OKAY' : 0,
            'EXOKAY' : 1,
            'SLVERR' : 2,
            'DECERR' : 3,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'BID',
        'BRESP',
    ],
} # End of packet: CMC2MC_AXI_B

# Packet for cmc2mc_axi_r

# Packet CMC2MC_AXI_R
packets['CMC2MC_AXI_R'] = {
    'size' :  80,
    # Field: CMC2MC_AXI_R.RDATA
    'RDATA' : {
        'lsb'        : 0,
        'msb'        : 63,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_R.RID
    'RID' : {
        'lsb'        : 64,
        'msb'        : 76,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CMC2MC_AXI_R.RRESP
    'RRESP' : {
        'lsb'        : 77,
        'msb'        : 78,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'OKAY' : 0,
            'EXOKAY' : 1,
            'SLVERR' : 2,
            'DECERR' : 3,
        },
    },
    # Field: CMC2MC_AXI_R.RLAST
    'RLAST' : {
        'lsb'        : 79,
        'msb'        : 79,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDATA',
        'RID',
        'RRESP',
        'RLAST',
    ],
} # End of packet: CMC2MC_AXI_R

# Definitions for mselect2mc_axi packets
# Packet for mselect2mc_axi_ar/mselect2mc_axi_aw

# Packet MSELECT2MC_AXI_A
packets['MSELECT2MC_AXI_A'] = {
    'size' :  63,
    # Field: MSELECT2MC_AXI_A.AADDR
    'AADDR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_A.AID
    'AID' : {
        'lsb'        : 32,
        'msb'        : 44,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_A.ALEN
    'ALEN' : {
        'lsb'        : 45,
        'msb'        : 48,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'ONEDATA' : 0,
            'TWODATA' : 1,
            'THREEDATA' : 2,
            'FOURDATA' : 3,
            'FIVEDATA' : 4,
            'SIXDATA' : 5,
            'SEVENDATA' : 6,
            'EIGHTDATA' : 7,
            'NINEDATA' : 8,
            'TENDATA' : 9,
            'ELEVENDATA' : 10,
            'TWELVEDATA' : 11,
            'THIRTEENDATA' : 12,
            'FOURTEENDATA' : 13,
            'FIFTHTEENDATA' : 14,
            'SIXTEENDATA' : 15,
        },
    },
    # Field: MSELECT2MC_AXI_A.ASIZE
    'ASIZE' : {
        'lsb'        : 49,
        'msb'        : 51,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'ONEBYTE' : 0,
            'TWOBYTES' : 1,
            'FOURBYTES' : 2,
            'EIGHTBYTES' : 3,
            'SIXTEENBYTES' : 4,
            'THIRTYTWOBYTES' : 5,
            'SIXTYFOURBYTES' : 6,
            'ONEHUNDREDTWENTYEIGHTBYTES' : 7,
        },
    },
    # Field: MSELECT2MC_AXI_A.ABURST
    'ABURST' : {
        'lsb'        : 52,
        'msb'        : 53,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'FIXED' : 0,
            'INCR' : 1,
            'WRAP' : 2,
            'RSVD' : 3,
        },
    },
    # Field: MSELECT2MC_AXI_A.ALOCK
    'ALOCK' : {
        'lsb'        : 54,
        'msb'        : 55,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'NORMAL' : 0,
            'EXCLUSIVE' : 1,
            'LOCKED' : 2,
            'RSVD' : 3,
        },
    },
    # Field: MSELECT2MC_AXI_A.ACACHE
    'ACACHE' : {
        'lsb'        : 56,
        'msb'        : 59,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'NONCACHEABLE_NONBUFFERABLE' : 0,
            'BUFFERABLE' : 1,
            'CACHEABLE_DONOTALLOCATE' : 2,
            'CACHEABLE_BUFFERABLE_DONOTALLOCATE' : 3,
            'CACHEABLEWRITETHROUGH_ALLOCATEONREAD' : 6,
            'CACHEABLEWRITEBACK_ALLOCATEONREAD' : 7,
            'CACHEABLEWRITETHROUGH_ALLOCATEONWRITE' : 10,
            'CACHEABLEWRITEBACK_ALLOCATEONWRITE' : 11,
            'CACHEABLEWRITETHROUGH_ALLOCATEONREADWRITE' : 14,
            'CACHEABLEWRITEBACK_ALLOCATEONREADWRITE' : 15,
        },
    },
    # Field: MSELECT2MC_AXI_A.APROT
    'APROT' : {
        'lsb'        : 60,
        'msb'        : 62,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DATA_SECURE_NORMAL' : 0,
            'DATA_SECURE_PRIVILEGED' : 1,
            'DATA_NONSECURE_NORMAL' : 2,
            'DATA_NONSECURE_PRIVILEGED' : 3,
            'INST_SECURE_NORMAL' : 4,
            'INST_SECURE_PRIVILEGED' : 5,
            'INST_NONSECURE_NORMAL' : 6,
            'INST_NONSECURE_PRIVILEGED' : 7,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'AADDR',
        'AID',
        'ALEN',
        'ASIZE',
        'ABURST',
        'ALOCK',
        'ACACHE',
        'APROT',
    ],
} # End of packet: MSELECT2MC_AXI_A

# Packet for mselect2mc_axi_w

# Packet MSELECT2MC_AXI_W
packets['MSELECT2MC_AXI_W'] = {
    'size' :  86,
    # Field: MSELECT2MC_AXI_W.WDATA
    'WDATA' : {
        'lsb'        : 0,
        'msb'        : 63,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_W.WID
    'WID' : {
        'lsb'        : 64,
        'msb'        : 76,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_W.WSTRB
    'WSTRB' : {
        'lsb'        : 77,
        'msb'        : 84,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_W.WLAST
    'WLAST' : {
        'lsb'        : 85,
        'msb'        : 85,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'WDATA',
        'WID',
        'WSTRB',
        'WLAST',
    ],
} # End of packet: MSELECT2MC_AXI_W

# Packet for mselect2emc_axi_b

# Packet MSELECT2MC_AXI_B
packets['MSELECT2MC_AXI_B'] = {
    'size' :  15,
    # Field: MSELECT2MC_AXI_B.BID
    'BID' : {
        'lsb'        : 0,
        'msb'        : 12,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_B.BRESP
    'BRESP' : {
        'lsb'        : 13,
        'msb'        : 14,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'OKAY' : 0,
            'EXOKAY' : 1,
            'SLVERR' : 2,
            'DECERR' : 3,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'BID',
        'BRESP',
    ],
} # End of packet: MSELECT2MC_AXI_B

# Packet for mselect2mc_axi_r

# Packet MSELECT2MC_AXI_R
packets['MSELECT2MC_AXI_R'] = {
    'size' :  80,
    # Field: MSELECT2MC_AXI_R.RDATA
    'RDATA' : {
        'lsb'        : 0,
        'msb'        : 63,
        'size'       : 64,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_R.RID
    'RID' : {
        'lsb'        : 64,
        'msb'        : 76,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MSELECT2MC_AXI_R.RRESP
    'RRESP' : {
        'lsb'        : 77,
        'msb'        : 78,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'OKAY' : 0,
            'EXOKAY' : 1,
            'SLVERR' : 2,
            'DECERR' : 3,
        },
    },
    # Field: MSELECT2MC_AXI_R.RLAST
    'RLAST' : {
        'lsb'        : 79,
        'msb'        : 79,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDATA',
        'RID',
        'RRESP',
        'RLAST',
    ],
} # End of packet: MSELECT2MC_AXI_R

# Packets for MC internal usage

# Packet AXI2MC_AXI_A
packets['AXI2MC_AXI_A'] = {
    'size' :  63,
    # Field: AXI2MC_AXI_A.AADDR
    'AADDR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_A.AID
    'AID' : {
        'lsb'        : 32,
        'msb'        : 44,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_A.ALEN
    'ALEN' : {
        'lsb'        : 45,
        'msb'        : 48,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'ONEDATA' : 0,
            'TWODATA' : 1,
            'THREEDATA' : 2,
            'FOURDATA' : 3,
            'FIVEDATA' : 4,
            'SIXDATA' : 5,
            'SEVENDATA' : 6,
            'EIGHTDATA' : 7,
            'NINEDATA' : 8,
            'TENDATA' : 9,
            'ELEVENDATA' : 10,
            'TWELVEDATA' : 11,
            'THIRTEENDATA' : 12,
            'FOURTEENDATA' : 13,
            'FIFTHTEENDATA' : 14,
            'SIXTEENDATA' : 15,
        },
    },
    # Field: AXI2MC_AXI_A.ASIZE
    'ASIZE' : {
        'lsb'        : 49,
        'msb'        : 51,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'ONEBYTE' : 0,
            'TWOBYTES' : 1,
            'FOURBYTES' : 2,
            'EIGHTBYTES' : 3,
            'SIXTEENBYTES' : 4,
            'THIRTYTWOBYTES' : 5,
            'SIXTYFOURBYTES' : 6,
            'ONEHUNDREDTWENTYEIGHTBYTES' : 7,
        },
    },
    # Field: AXI2MC_AXI_A.ABURST
    'ABURST' : {
        'lsb'        : 52,
        'msb'        : 53,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'FIXED' : 0,
            'INCR' : 1,
            'WRAP' : 2,
            'RSVD' : 3,
        },
    },
    # Field: AXI2MC_AXI_A.ALOCK
    'ALOCK' : {
        'lsb'        : 54,
        'msb'        : 55,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'NORMAL' : 0,
            'EXCLUSIVE' : 1,
            'LOCKED' : 2,
            'RSVD' : 3,
        },
    },
    # Field: AXI2MC_AXI_A.ACACHE
    'ACACHE' : {
        'lsb'        : 56,
        'msb'        : 59,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'NONCACHEABLE_NONBUFFERABLE' : 0,
            'BUFFERABLE' : 1,
            'CACHEABLE_DONOTALLOCATE' : 2,
            'CACHEABLE_BUFFERABLE_DONOTALLOCATE' : 3,
            'CACHEABLEWRITETHROUGH_ALLOCATEONREAD' : 6,
            'CACHEABLEWRITEBACK_ALLOCATEONREAD' : 7,
            'CACHEABLEWRITETHROUGH_ALLOCATEONWRITE' : 10,
            'CACHEABLEWRITEBACK_ALLOCATEONWRITE' : 11,
            'CACHEABLEWRITETHROUGH_ALLOCATEONREADWRITE' : 14,
            'CACHEABLEWRITEBACK_ALLOCATEONREADWRITE' : 15,
        },
    },
    # Field: AXI2MC_AXI_A.APROT
    'APROT' : {
        'lsb'        : 60,
        'msb'        : 62,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DATA_SECURE_NORMAL' : 0,
            'DATA_SECURE_PRIVILEGED' : 1,
            'DATA_NONSECURE_NORMAL' : 2,
            'DATA_NONSECURE_PRIVILEGED' : 3,
            'INST_SECURE_NORMAL' : 4,
            'INST_SECURE_PRIVILEGED' : 5,
            'INST_NONSECURE_NORMAL' : 6,
            'INST_NONSECURE_PRIVILEGED' : 7,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'AADDR',
        'AID',
        'ALEN',
        'ASIZE',
        'ABURST',
        'ALOCK',
        'ACACHE',
        'APROT',
    ],
} # End of packet: AXI2MC_AXI_A


# Packet AXI2MC_AXI_W
packets['AXI2MC_AXI_W'] = {
    'size' :  302,
    # Field: AXI2MC_AXI_W.WDATA
    'WDATA' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_W.WID
    'WID' : {
        'lsb'        : 256,
        'msb'        : 268,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_W.WSTRB
    'WSTRB' : {
        'lsb'        : 269,
        'msb'        : 300,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_W.WLAST
    'WLAST' : {
        'lsb'        : 301,
        'msb'        : 301,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'WDATA',
        'WID',
        'WSTRB',
        'WLAST',
    ],
} # End of packet: AXI2MC_AXI_W


# Packet AXI2MC_AXI_B
packets['AXI2MC_AXI_B'] = {
    'size' :  15,
    # Field: AXI2MC_AXI_B.BID
    'BID' : {
        'lsb'        : 0,
        'msb'        : 12,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_B.BRESP
    'BRESP' : {
        'lsb'        : 13,
        'msb'        : 14,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'OKAY' : 0,
            'EXOKAY' : 1,
            'SLVERR' : 2,
            'DECERR' : 3,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'BID',
        'BRESP',
    ],
} # End of packet: AXI2MC_AXI_B


# Packet AXI2MC_AXI_R
packets['AXI2MC_AXI_R'] = {
    'size' :  272,
    # Field: AXI2MC_AXI_R.RDATA
    'RDATA' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_R.RID
    'RID' : {
        'lsb'        : 256,
        'msb'        : 268,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: AXI2MC_AXI_R.RRESP
    'RRESP' : {
        'lsb'        : 269,
        'msb'        : 270,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'OKAY' : 0,
            'EXOKAY' : 1,
            'SLVERR' : 2,
            'DECERR' : 3,
        },
    },
    # Field: AXI2MC_AXI_R.RLAST
    'RLAST' : {
        'lsb'        : 271,
        'msb'        : 271,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDATA',
        'RID',
        'RRESP',
        'RLAST',
    ],
} # End of packet: AXI2MC_AXI_R


# Packet MC_AXI_RWREQ
packets['MC_AXI_RWREQ'] = {
    'size' :  118,
    # Field: MC_AXI_RWREQ.AADDR
    'AADDR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.AID
    'AID' : {
        'lsb'        : 32,
        'msb'        : 44,
        'size'       : 13,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ALEN
    'ALEN' : {
        'lsb'        : 45,
        'msb'        : 48,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ASIZE
    'ASIZE' : {
        'lsb'        : 49,
        'msb'        : 51,
        'size'       : 3,
        'row'        : 2,
        'default'    : 2,
        'sw_default' : 2,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ABURST
    'ABURST' : {
        'lsb'        : 52,
        'msb'        : 53,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'FIXED' : 0,
            'INCR' : 1,
            'WRAP' : 2,
            'RSVD' : 3,
        },
    },
    # Field: MC_AXI_RWREQ.ALOCK
    'ALOCK' : {
        'lsb'        : 54,
        'msb'        : 55,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ACACHE
    'ACACHE' : {
        'lsb'        : 56,
        'msb'        : 59,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.APROT
    'APROT' : {
        'lsb'        : 60,
        'msb'        : 62,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ASB
    'ASB' : {
        'lsb'        : 63,
        'msb'        : 64,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ARW
    'ARW' : {
        'lsb'        : 65,
        'msb'        : 65,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ACT_AADDR
    'ACT_AADDR' : {
        'lsb'        : 66,
        'msb'        : 97,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ACT_ALEN
    'ACT_ALEN' : {
        'lsb'        : 98,
        'msb'        : 101,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ACT_ASIZE
    'ACT_ASIZE' : {
        'lsb'        : 102,
        'msb'        : 104,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.DOUBLEREQ
    'DOUBLEREQ' : {
        'lsb'        : 105,
        'msb'        : 105,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.ILLEGALACC
    'ILLEGALACC' : {
        'lsb'        : 106,
        'msb'        : 106,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: MC_AXI_RWREQ.TAG
    'TAG' : {
        'lsb'        : 107,
        'msb'        : 117,
        'size'       : 11,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'AADDR',
        'AID',
        'ALEN',
        'ASIZE',
        'ABURST',
        'ALOCK',
        'ACACHE',
        'APROT',
        'ASB',
        'ARW',
        'ACT_AADDR',
        'ACT_ALEN',
        'ACT_ASIZE',
        'DOUBLEREQ',
        'ILLEGALACC',
        'TAG',
    ],
} # End of packet: MC_AXI_RWREQ

# Packets for mccif single read
#client clk_en

# Packet CSR_C2MC_CLKEN
packets['CSR_C2MC_CLKEN'] = {
    'size' :  1,
    # Field: CSR_C2MC_CLKEN.CLKEN
    'CLKEN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'CLKEN',
    ],
} # End of packet: CSR_C2MC_CLKEN


# Packet CSR_C2MC_RESET
packets['CSR_C2MC_RESET'] = {
    'size' :  1,
    # Field: CSR_C2MC_RESET.RSTN
    'RSTN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RSTN',
    ],
} # End of packet: CSR_C2MC_RESET


# Packet C2MC_FLUSH_REQ
packets['C2MC_FLUSH_REQ'] = {
    'size' :  1,
    # Field: C2MC_FLUSH_REQ.FLUSH_REQ
    'FLUSH_REQ' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'FLUSH_REQ',
    ],
} # End of packet: C2MC_FLUSH_REQ


# Packet C2MC_FLUSH_DONE
packets['C2MC_FLUSH_DONE'] = {
    'size' :  1,
    # Field: C2MC_FLUSH_DONE.FLUSH_DONE
    'FLUSH_DONE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'FLUSH_DONE',
    ],
} # End of packet: C2MC_FLUSH_DONE


# Packet CSR_C2MC_REQ
packets['CSR_C2MC_REQ'] = {
    'size' :  35,
    # Field: CSR_C2MC_REQ.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ.SWID
    'SWID' : {
        'lsb'        : 32,
        'msb'        : 32,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ.VPR
    'VPR' : {
        'lsb'        : 33,
        'msb'        : 33,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ.IPC
    'IPC' : {
        'lsb'        : 34,
        'msb'        : 34,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'SWID',
        'VPR',
        'IPC',
    ],
} # End of packet: CSR_C2MC_REQ


# Packet CSR_C2MC_REQ2
packets['CSR_C2MC_REQ2'] = {
    'size' :  68,
    # Field: CSR_C2MC_REQ2.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.ADRH
    'ADRH' : {
        'lsb'        : 32,
        'msb'        : 39,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.CSIZE
    'CSIZE' : {
        'lsb'        : 40,
        'msb'        : 41,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.ADR1
    'ADR1' : {
        'lsb'        : 42,
        'msb'        : 44,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.SWID
    'SWID' : {
        'lsb'        : 45,
        'msb'        : 46,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.VPR
    'VPR' : {
        'lsb'        : 47,
        'msb'        : 47,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.IPC
    'IPC' : {
        'lsb'        : 48,
        'msb'        : 48,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.STREAM_ID
    'STREAM_ID' : {
        'lsb'        : 49,
        'msb'        : 56,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.SMMU_NS
    'SMMU_NS' : {
        'lsb'        : 57,
        'msb'        : 57,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.COH_IO_ACC
    'COH_IO_ACC' : {
        'lsb'        : 58,
        'msb'        : 58,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.AXI_ID
    'AXI_ID' : {
        'lsb'        : 59,
        'msb'        : 66,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_REQ2.SO_DEV
    'SO_DEV' : {
        'lsb'        : 67,
        'msb'        : 67,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'ADRH',
        'CSIZE',
        'ADR1',
        'SWID',
        'VPR',
        'IPC',
        'STREAM_ID',
        'SMMU_NS',
        'COH_IO_ACC',
        'AXI_ID',
        'SO_DEV',
    ],
} # End of packet: CSR_C2MC_REQ2


# Packet CSR_C2MC_SIZE
packets['CSR_C2MC_SIZE'] = {
    'size' :  1,
    # Field: CSR_C2MC_SIZE.SIZE
    'SIZE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'SIZE',
    ],
} # End of packet: CSR_C2MC_SIZE


# Packet CSR_C2MC_SECURE
packets['CSR_C2MC_SECURE'] = {
    'size' :  1,
    # Field: CSR_C2MC_SECURE.SECURE
    'SECURE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'SECURE',
    ],
} # End of packet: CSR_C2MC_SECURE


# Packet CSR_C2MC_TAG
packets['CSR_C2MC_TAG'] = {
    'size' :  11,
    # Field: CSR_C2MC_TAG.TAG
    'TAG' : {
        'lsb'        : 0,
        'msb'        : 10,
        'size'       : 11,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'TAG',
    ],
} # End of packet: CSR_C2MC_TAG

# client base/pitch request

# Packet CSR_C2MC_BP_REQ
packets['CSR_C2MC_BP_REQ'] = {
    'size' :  56,
    # Field: CSR_C2MC_BP_REQ.BASEADR
    'BASEADR' : {
        'lsb'        : 0,
        'msb'        : 39,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_BP_REQ.PITCH
    'PITCH' : {
        'lsb'        : 40,
        'msb'        : 55,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'BASEADR',
        'PITCH',
    ],
} # End of packet: CSR_C2MC_BP_REQ

# combined with a BP_REQ packet

# Packet CSR_C2MC_ADRXY
packets['CSR_C2MC_ADRXY'] = {
    'size' :  30,
    # Field: CSR_C2MC_ADRXY.OFFX
    'OFFX' : {
        'lsb'        : 0,
        'msb'        : 15,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_ADRXY.OFFY
    'OFFY' : {
        'lsb'        : 16,
        'msb'        : 29,
        'size'       : 14,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'OFFX',
        'OFFY',
    ],
} # End of packet: CSR_C2MC_ADRXY

# combined with a BP_REQ packet

# Packet CSR_C2MC_TILE
packets['CSR_C2MC_TILE'] = {
    'size' :  42,
    # Field: CSR_C2MC_TILE.LINADR
    'LINADR' : {
        'lsb'        : 0,
        'msb'        : 39,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_TILE.TMODE
    'TMODE' : {
        'lsb'        : 40,
        'msb'        : 40,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'LINEAR' : 0,
            'TILED' : 1,
        },
    },
    # Field: CSR_C2MC_TILE.VPR
    'VPR' : {
        'lsb'        : 41,
        'msb'        : 41,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'LINADR',
        'TMODE',
        'VPR',
    ],
} # End of packet: CSR_C2MC_TILE


# Packet CSR_C2MC_RDI
packets['CSR_C2MC_RDI'] = {
    'size' :  257,
    # Field: CSR_C2MC_RDI.RDI
    'RDI' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_RDI.RVPR
    'RVPR' : {
        'lsb'        : 256,
        'msb'        : 256,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDI',
        'RVPR',
    ],
} # End of packet: CSR_C2MC_RDI


# Packet CSR_C2MC_RDI2
packets['CSR_C2MC_RDI2'] = {
    'size' :  523,
    # Field: CSR_C2MC_RDI2.RDIL
    'RDIL' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_RDI2.RDIH
    'RDIH' : {
        'lsb'        : 256,
        'msb'        : 511,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_RDI2.RSIZE
    'RSIZE' : {
        'lsb'        : 512,
        'msb'        : 513,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_RDI2.RVPR
    'RVPR' : {
        'lsb'        : 514,
        'msb'        : 514,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_RDI2.RID
    'RID' : {
        'lsb'        : 515,
        'msb'        : 522,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDIL',
        'RDIH',
        'RSIZE',
        'RVPR',
        'RID',
    ],
} # End of packet: CSR_C2MC_RDI2

#packet CSR_C2MC_RDI2
#        512-1:0  0       RDI
#        513:512   0       RSIZE
#;

# Packet CSR_C2MC_HP
packets['CSR_C2MC_HP'] = {
    'size' :  38,
    # Field: CSR_C2MC_HP.HPTH
    'HPTH' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_HP.HPTM
    'HPTM' : {
        'lsb'        : 32,
        'msb'        : 37,
        'size'       : 6,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HPTH',
        'HPTM',
    ],
} # End of packet: CSR_C2MC_HP

# hysteresis control register

# Packet CSR_C2MC_HYST
packets['CSR_C2MC_HYST'] = {
    'size' :  32,
    # Field: CSR_C2MC_HYST.HYST_REQ_TM
    'HYST_REQ_TM' : {
        'lsb'        : 0,
        'msb'        : 7,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_HYST.DHYST_TM
    'DHYST_TM' : {
        'lsb'        : 8,
        'msb'        : 15,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_HYST.DHYST_TH
    'DHYST_TH' : {
        'lsb'        : 16,
        'msb'        : 23,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_HYST.HYST_TM
    'HYST_TM' : {
        'lsb'        : 24,
        'msb'        : 27,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_HYST.HYST_REQ_TH
    'HYST_REQ_TH' : {
        'lsb'        : 28,
        'msb'        : 30,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSR_C2MC_HYST.HYST_EN
    'HYST_EN' : {
        'lsb'        : 31,
        'msb'        : 31,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HYST_REQ_TM',
        'DHYST_TM',
        'DHYST_TH',
        'HYST_TM',
        'HYST_REQ_TH',
        'HYST_EN',
    ],
} # End of packet: CSR_C2MC_HYST

#client clk_en

# Packet CSW_C2MC_CLKEN
packets['CSW_C2MC_CLKEN'] = {
    'size' :  1,
    # Field: CSW_C2MC_CLKEN.CLKEN
    'CLKEN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'CLKEN',
    ],
} # End of packet: CSW_C2MC_CLKEN

# Packets for mccif single write

# Packet CSW_C2MC_RESET
packets['CSW_C2MC_RESET'] = {
    'size' :  1,
    # Field: CSW_C2MC_RESET.RSTN
    'RSTN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RSTN',
    ],
} # End of packet: CSW_C2MC_RESET


# Packet CSW_C2MC_REQ
packets['CSW_C2MC_REQ'] = {
    'size' :  324,
    # Field: CSW_C2MC_REQ.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ.BE
    'BE' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ.WDO
    'WDO' : {
        'lsb'        : 64,
        'msb'        : 319,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ.TAG
    'TAG' : {
        'lsb'        : 320,
        'msb'        : 320,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ.SWID
    'SWID' : {
        'lsb'        : 321,
        'msb'        : 321,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ.VPR
    'VPR' : {
        'lsb'        : 322,
        'msb'        : 322,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ.IPC
    'IPC' : {
        'lsb'        : 323,
        'msb'        : 323,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'BE',
        'WDO',
        'TAG',
        'SWID',
        'VPR',
        'IPC',
    ],
} # End of packet: CSW_C2MC_REQ

#packet CSW_C2MC_REQ2
#        31:0                                          0       ADR
#        NV_MC_BW+32-1:32                              0       BE
#        NV_MC_MW+NV_MC_BW+32-1:NV_MC_BW+32            0       WDO
#        NV_MC_MW+NV_MC_BW+32                          0       TAG
#        NV_MC_MW+NV_MC_BW+32+2:NV_MC_MW+NV_MC_BW+32+1 0       CSIZE
#;

# Packet CSW_C2MC_REQ2
packets['CSW_C2MC_REQ2'] = {
    'size' :  645,
    # Field: CSW_C2MC_REQ2.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.ADRH
    'ADRH' : {
        'lsb'        : 32,
        'msb'        : 39,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.BEL
    'BEL' : {
        'lsb'        : 40,
        'msb'        : 71,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.BEH
    'BEH' : {
        'lsb'        : 72,
        'msb'        : 103,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.WDOL
    'WDOL' : {
        'lsb'        : 104,
        'msb'        : 359,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.WDOH
    'WDOH' : {
        'lsb'        : 360,
        'msb'        : 615,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.TAG
    'TAG' : {
        'lsb'        : 616,
        'msb'        : 616,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.CSIZE
    'CSIZE' : {
        'lsb'        : 617,
        'msb'        : 618,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.ADR1
    'ADR1' : {
        'lsb'        : 619,
        'msb'        : 621,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.SWID
    'SWID' : {
        'lsb'        : 622,
        'msb'        : 623,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.VPR
    'VPR' : {
        'lsb'        : 624,
        'msb'        : 624,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.IPC
    'IPC' : {
        'lsb'        : 625,
        'msb'        : 625,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.STREAM_ID
    'STREAM_ID' : {
        'lsb'        : 626,
        'msb'        : 633,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.SMMU_NS
    'SMMU_NS' : {
        'lsb'        : 634,
        'msb'        : 634,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.COH_IO_ACC
    'COH_IO_ACC' : {
        'lsb'        : 635,
        'msb'        : 635,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.AXI_ID
    'AXI_ID' : {
        'lsb'        : 636,
        'msb'        : 643,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_REQ2.SO_DEV
    'SO_DEV' : {
        'lsb'        : 644,
        'msb'        : 644,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'ADRH',
        'BEL',
        'BEH',
        'WDOL',
        'WDOH',
        'TAG',
        'CSIZE',
        'ADR1',
        'SWID',
        'VPR',
        'IPC',
        'STREAM_ID',
        'SMMU_NS',
        'COH_IO_ACC',
        'AXI_ID',
        'SO_DEV',
    ],
} # End of packet: CSW_C2MC_REQ2


# Packet CSW_C2MC_SECURE
packets['CSW_C2MC_SECURE'] = {
    'size' :  1,
    # Field: CSW_C2MC_SECURE.SECURE
    'SECURE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'SECURE',
    ],
} # End of packet: CSW_C2MC_SECURE

# client base/pitch request

# Packet CSW_C2MC_BP_REQ
packets['CSW_C2MC_BP_REQ'] = {
    'size' :  345,
    # Field: CSW_C2MC_BP_REQ.BASEADR
    'BASEADR' : {
        'lsb'        : 0,
        'msb'        : 39,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_BP_REQ.PITCH
    'PITCH' : {
        'lsb'        : 40,
        'msb'        : 55,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_BP_REQ.BE
    'BE' : {
        'lsb'        : 56,
        'msb'        : 87,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_BP_REQ.WDO
    'WDO' : {
        'lsb'        : 88,
        'msb'        : 343,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_BP_REQ.TAG
    'TAG' : {
        'lsb'        : 344,
        'msb'        : 344,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'BASEADR',
        'PITCH',
        'BE',
        'WDO',
        'TAG',
    ],
} # End of packet: CSW_C2MC_BP_REQ

# combined with a BP_REQ packet

# Packet CSW_C2MC_ADRXY
packets['CSW_C2MC_ADRXY'] = {
    'size' :  30,
    # Field: CSW_C2MC_ADRXY.OFFX
    'OFFX' : {
        'lsb'        : 0,
        'msb'        : 15,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_ADRXY.OFFY
    'OFFY' : {
        'lsb'        : 16,
        'msb'        : 29,
        'size'       : 14,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'OFFX',
        'OFFY',
    ],
} # End of packet: CSW_C2MC_ADRXY

# combined with a BP_REQ packet

# Packet CSW_C2MC_TILE
packets['CSW_C2MC_TILE'] = {
    'size' :  41,
    # Field: CSW_C2MC_TILE.LINADR
    'LINADR' : {
        'lsb'        : 0,
        'msb'        : 39,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CSW_C2MC_TILE.TMODE
    'TMODE' : {
        'lsb'        : 40,
        'msb'        : 40,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'LINEAR' : 0,
            'TILED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'LINADR',
        'TMODE',
    ],
} # End of packet: CSW_C2MC_TILE


# Packet CSW_C2MC_XDI
packets['CSW_C2MC_XDI'] = {
    'size' :  32,
    # Field: CSW_C2MC_XDI.XDI
    'XDI' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'XDI',
    ],
} # End of packet: CSW_C2MC_XDI


# Packet CSW_C2MC_HP
packets['CSW_C2MC_HP'] = {
    'size' :  32,
    # Field: CSW_C2MC_HP.HPTH
    'HPTH' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HPTH',
    ],
} # End of packet: CSW_C2MC_HP


# Packet CSW_C2MC_WCOAL
packets['CSW_C2MC_WCOAL'] = {
    'size' :  32,
    # Field: CSW_C2MC_WCOAL.WCOALTM
    'WCOALTM' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'WCOALTM',
    ],
} # End of packet: CSW_C2MC_WCOAL


# Packet CSW_C2MC_HYST
packets['CSW_C2MC_HYST'] = {
    'size' :  32,
    # Field: CSW_C2MC_HYST.HYST
    'HYST' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HYST',
    ],
} # End of packet: CSW_C2MC_HYST

# Packets for mccif block read

# Packet CBR_C2MC_CLKEN
packets['CBR_C2MC_CLKEN'] = {
    'size' :  1,
    # Field: CBR_C2MC_CLKEN.CLKEN
    'CLKEN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'CLKEN',
    ],
} # End of packet: CBR_C2MC_CLKEN


# Packet CBR_C2MC_RESET
packets['CBR_C2MC_RESET'] = {
    'size' :  1,
    # Field: CBR_C2MC_RESET.RSTN
    'RSTN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RSTN',
    ],
} # End of packet: CBR_C2MC_RESET


# Packet CBR_C2MC_REQP
packets['CBR_C2MC_REQP'] = {
    'size' :  264,
    # Field: CBR_C2MC_REQP.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.ADRU
    'ADRU' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.ADRV
    'ADRV' : {
        'lsb'        : 64,
        'msb'        : 95,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.LS
    'LS' : {
        'lsb'        : 96,
        'msb'        : 127,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.LSUV
    'LSUV' : {
        'lsb'        : 128,
        'msb'        : 159,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.HS
    'HS' : {
        'lsb'        : 160,
        'msb'        : 191,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.VS
    'VS' : {
        'lsb'        : 192,
        'msb'        : 223,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.DL
    'DL' : {
        'lsb'        : 224,
        'msb'        : 255,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.HD
    'HD' : {
        'lsb'        : 256,
        'msb'        : 256,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.VD
    'VD' : {
        'lsb'        : 257,
        'msb'        : 257,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.VX2
    'VX2' : {
        'lsb'        : 258,
        'msb'        : 258,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.LP
    'LP' : {
        'lsb'        : 259,
        'msb'        : 259,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.YUV
    'YUV' : {
        'lsb'        : 260,
        'msb'        : 262,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_REQP.VPR
    'VPR' : {
        'lsb'        : 263,
        'msb'        : 263,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'ADRU',
        'ADRV',
        'LS',
        'LSUV',
        'HS',
        'VS',
        'DL',
        'HD',
        'VD',
        'VX2',
        'LP',
        'YUV',
        'VPR',
    ],
} # End of packet: CBR_C2MC_REQP


# Packet CBR_C2MC_SECURE
packets['CBR_C2MC_SECURE'] = {
    'size' :  1,
    # Field: CBR_C2MC_SECURE.SECURE
    'SECURE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'SECURE',
    ],
} # End of packet: CBR_C2MC_SECURE

# combined with a REQP packet

# Packet CBR_C2MC_ADRXY
packets['CBR_C2MC_ADRXY'] = {
    'size' :  44,
    # Field: CBR_C2MC_ADRXY.OFFX
    'OFFX' : {
        'lsb'        : 0,
        'msb'        : 15,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_ADRXY.OFFY
    'OFFY' : {
        'lsb'        : 16,
        'msb'        : 29,
        'size'       : 14,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_ADRXY.OFFYUV
    'OFFYUV' : {
        'lsb'        : 30,
        'msb'        : 43,
        'size'       : 14,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'OFFX',
        'OFFY',
        'OFFYUV',
    ],
} # End of packet: CBR_C2MC_ADRXY

# combined with a REQP packet

# Packet CBR_C2MC_TILE
packets['CBR_C2MC_TILE'] = {
    'size' :  122,
    # Field: CBR_C2MC_TILE.LINADR
    'LINADR' : {
        'lsb'        : 0,
        'msb'        : 39,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_TILE.LINADRU
    'LINADRU' : {
        'lsb'        : 40,
        'msb'        : 79,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_TILE.LINADRV
    'LINADRV' : {
        'lsb'        : 80,
        'msb'        : 119,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_TILE.TMODE
    'TMODE' : {
        'lsb'        : 120,
        'msb'        : 120,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'LINEAR' : 0,
            'TILED' : 1,
        },
    },
    # Field: CBR_C2MC_TILE.TMODEUV
    'TMODEUV' : {
        'lsb'        : 121,
        'msb'        : 121,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'LINEAR' : 0,
            'TILED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'LINADR',
        'LINADRU',
        'LINADRV',
        'TMODE',
        'TMODEUV',
    ],
} # End of packet: CBR_C2MC_TILE


# Packet CBR_C2MC_RDYP
packets['CBR_C2MC_RDYP'] = {
    'size' :  1,
    # Field: CBR_C2MC_RDYP.RDYP
    'RDYP' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDYP',
    ],
} # End of packet: CBR_C2MC_RDYP


# Packet CBR_C2MC_OUTSTD
packets['CBR_C2MC_OUTSTD'] = {
    'size' :  1,
    # Field: CBR_C2MC_OUTSTD.OUTSTD
    'OUTSTD' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'OUTSTD',
    ],
} # End of packet: CBR_C2MC_OUTSTD


# Packet CBR_C2MC_STOP
packets['CBR_C2MC_STOP'] = {
    'size' :  1,
    # Field: CBR_C2MC_STOP.STOP
    'STOP' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'STOP',
    ],
} # End of packet: CBR_C2MC_STOP


# Packet CBR_C2MC_RDI
packets['CBR_C2MC_RDI'] = {
    'size' :  263,
    # Field: CBR_C2MC_RDI.RDI
    'RDI' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_RDI.RDILST
    'RDILST' : {
        'lsb'        : 256,
        'msb'        : 256,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_RDI.RDINB
    'RDINB' : {
        'lsb'        : 257,
        'msb'        : 261,
        'size'       : 5,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_RDI.RVPR
    'RVPR' : {
        'lsb'        : 262,
        'msb'        : 262,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDI',
        'RDILST',
        'RDINB',
        'RVPR',
    ],
} # End of packet: CBR_C2MC_RDI

# For single read inside block read or byte enables

# Packet CBR_C2MC_DOREQ
packets['CBR_C2MC_DOREQ'] = {
    'size' :  65,
    # Field: CBR_C2MC_DOREQ.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_DOREQ.LS
    'LS' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_DOREQ.VPR
    'VPR' : {
        'lsb'        : 64,
        'msb'        : 64,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'LS',
        'VPR',
    ],
} # End of packet: CBR_C2MC_DOREQ


# Packet CBR_C2MC_HP
packets['CBR_C2MC_HP'] = {
    'size' :  71,
    # Field: CBR_C2MC_HP.HPTH
    'HPTH' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HP.HPTM
    'HPTM' : {
        'lsb'        : 32,
        'msb'        : 37,
        'size'       : 6,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HP.HPSOF
    'HPSOF' : {
        'lsb'        : 38,
        'msb'        : 38,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HP.HPCPW
    'HPCPW' : {
        'lsb'        : 39,
        'msb'        : 54,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HP.HPCBNPW
    'HPCBNPW' : {
        'lsb'        : 55,
        'msb'        : 70,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HPTH',
        'HPTM',
        'HPSOF',
        'HPCPW',
        'HPCBNPW',
    ],
} # End of packet: CBR_C2MC_HP

# hysteresis control register

# Packet CBR_C2MC_HYST
packets['CBR_C2MC_HYST'] = {
    'size' :  32,
    # Field: CBR_C2MC_HYST.HYST_REQ_TM
    'HYST_REQ_TM' : {
        'lsb'        : 0,
        'msb'        : 7,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HYST.DHYST_TM
    'DHYST_TM' : {
        'lsb'        : 8,
        'msb'        : 15,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HYST.DHYST_TH
    'DHYST_TH' : {
        'lsb'        : 16,
        'msb'        : 23,
        'size'       : 8,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HYST.HYST_TM
    'HYST_TM' : {
        'lsb'        : 24,
        'msb'        : 27,
        'size'       : 4,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HYST.HYST_REQ_TH
    'HYST_REQ_TH' : {
        'lsb'        : 28,
        'msb'        : 30,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBR_C2MC_HYST.HYST_EN
    'HYST_EN' : {
        'lsb'        : 31,
        'msb'        : 31,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HYST_REQ_TM',
        'DHYST_TM',
        'DHYST_TH',
        'HYST_TM',
        'HYST_REQ_TH',
        'HYST_EN',
    ],
} # End of packet: CBR_C2MC_HYST

# Packets for mccif block write

# Packet CBW_C2MC_CLKEN
packets['CBW_C2MC_CLKEN'] = {
    'size' :  1,
    # Field: CBW_C2MC_CLKEN.CLKEN
    'CLKEN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'CLKEN',
    ],
} # End of packet: CBW_C2MC_CLKEN


# Packet CBW_C2MC_RESET
packets['CBW_C2MC_RESET'] = {
    'size' :  1,
    # Field: CBW_C2MC_RESET.RSTN
    'RSTN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RSTN',
    ],
} # End of packet: CBW_C2MC_RESET


# Packet CBW_C2MC_REQP
packets['CBW_C2MC_REQP'] = {
    'size' :  135,
    # Field: CBW_C2MC_REQP.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.LS
    'LS' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.HS
    'HS' : {
        'lsb'        : 64,
        'msb'        : 95,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.VS
    'VS' : {
        'lsb'        : 96,
        'msb'        : 127,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.HD
    'HD' : {
        'lsb'        : 128,
        'msb'        : 128,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.VD
    'VD' : {
        'lsb'        : 129,
        'msb'        : 129,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.BPP
    'BPP' : {
        'lsb'        : 130,
        'msb'        : 131,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.XY
    'XY' : {
        'lsb'        : 132,
        'msb'        : 132,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.PK
    'PK' : {
        'lsb'        : 133,
        'msb'        : 133,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_REQP.VPR
    'VPR' : {
        'lsb'        : 134,
        'msb'        : 134,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'LS',
        'HS',
        'VS',
        'HD',
        'VD',
        'BPP',
        'XY',
        'PK',
        'VPR',
    ],
} # End of packet: CBW_C2MC_REQP


# Packet CBW_C2MC_SECURE
packets['CBW_C2MC_SECURE'] = {
    'size' :  1,
    # Field: CBW_C2MC_SECURE.SECURE
    'SECURE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'SECURE',
    ],
} # End of packet: CBW_C2MC_SECURE

# combined with a REQP packet

# Packet CBW_C2MC_ADRXY
packets['CBW_C2MC_ADRXY'] = {
    'size' :  30,
    # Field: CBW_C2MC_ADRXY.OFFX
    'OFFX' : {
        'lsb'        : 0,
        'msb'        : 15,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_ADRXY.OFFY
    'OFFY' : {
        'lsb'        : 16,
        'msb'        : 29,
        'size'       : 14,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'OFFX',
        'OFFY',
    ],
} # End of packet: CBW_C2MC_ADRXY

# combined with a REQP packet

# Packet CBW_C2MC_TILE
packets['CBW_C2MC_TILE'] = {
    'size' :  41,
    # Field: CBW_C2MC_TILE.LINADR
    'LINADR' : {
        'lsb'        : 0,
        'msb'        : 39,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_TILE.TMODE
    'TMODE' : {
        'lsb'        : 40,
        'msb'        : 40,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'LINEAR' : 0,
            'TILED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'LINADR',
        'TMODE',
    ],
} # End of packet: CBW_C2MC_TILE


# Packet CBW_C2MC_RDYP
packets['CBW_C2MC_RDYP'] = {
    'size' :  1,
    # Field: CBW_C2MC_RDYP.RDYP
    'RDYP' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDYP',
    ],
} # End of packet: CBW_C2MC_RDYP


# Packet CBW_C2MC_STOP
packets['CBW_C2MC_STOP'] = {
    'size' :  1,
    # Field: CBW_C2MC_STOP.STOP
    'STOP' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'STOP',
    ],
} # End of packet: CBW_C2MC_STOP


# Packet CBW_C2MC_XDI
packets['CBW_C2MC_XDI'] = {
    'size' :  1,
    # Field: CBW_C2MC_XDI.XDI
    'XDI' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'XDI',
    ],
} # End of packet: CBW_C2MC_XDI


# Packet CBW_C2MC_DOREQ
packets['CBW_C2MC_DOREQ'] = {
    'size' :  322,
    # Field: CBW_C2MC_DOREQ.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_DOREQ.BE
    'BE' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_DOREQ.WDO
    'WDO' : {
        'lsb'        : 64,
        'msb'        : 319,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_DOREQ.TAG
    'TAG' : {
        'lsb'        : 320,
        'msb'        : 320,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_DOREQ.VPR
    'VPR' : {
        'lsb'        : 321,
        'msb'        : 321,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'BE',
        'WDO',
        'TAG',
        'VPR',
    ],
} # End of packet: CBW_C2MC_DOREQ


# Packet CBW_C2MC_HP
packets['CBW_C2MC_HP'] = {
    'size' :  32,
    # Field: CBW_C2MC_HP.HPTH
    'HPTH' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HPTH',
    ],
} # End of packet: CBW_C2MC_HP


# Packet CBW_C2MC_WCOAL
packets['CBW_C2MC_WCOAL'] = {
    'size' :  32,
    # Field: CBW_C2MC_WCOAL.WCOALTM
    'WCOALTM' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'WCOALTM',
    ],
} # End of packet: CBW_C2MC_WCOAL

# hysteresis control register

# Packet CBW_C2MC_HYST
packets['CBW_C2MC_HYST'] = {
    'size' :  32,
    # Field: CBW_C2MC_HYST.HYST_REQ_TM
    'HYST_REQ_TM' : {
        'lsb'        : 0,
        'msb'        : 11,
        'size'       : 12,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_HYST.HYST_REQ_TH
    'HYST_REQ_TH' : {
        'lsb'        : 28,
        'msb'        : 30,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CBW_C2MC_HYST.HYST_EN
    'HYST_EN' : {
        'lsb'        : 31,
        'msb'        : 31,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HYST_REQ_TM',
        'HYST_REQ_TH',
        'HYST_EN',
    ],
} # End of packet: CBW_C2MC_HYST

# Packets for mccif controlled read

# Packet CCR_C2MC_CLKEN
packets['CCR_C2MC_CLKEN'] = {
    'size' :  1,
    # Field: CCR_C2MC_CLKEN.CLKEN
    'CLKEN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'CLKEN',
    ],
} # End of packet: CCR_C2MC_CLKEN


# Packet CCR_C2MC_RESET
packets['CCR_C2MC_RESET'] = {
    'size' :  1,
    # Field: CCR_C2MC_RESET.RSTN
    'RSTN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RSTN',
    ],
} # End of packet: CCR_C2MC_RESET


# Packet CCR_C2MC_REQ
packets['CCR_C2MC_REQ'] = {
    'size' :  101,
    # Field: CCR_C2MC_REQ.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCR_C2MC_REQ.LS
    'LS' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCR_C2MC_REQ.HINC
    'HINC' : {
        'lsb'        : 64,
        'msb'        : 95,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCR_C2MC_REQ.ACMD
    'ACMD' : {
        'lsb'        : 96,
        'msb'        : 97,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCR_C2MC_REQ.LN
    'LN' : {
        'lsb'        : 98,
        'msb'        : 98,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCR_C2MC_REQ.HD
    'HD' : {
        'lsb'        : 99,
        'msb'        : 99,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCR_C2MC_REQ.VD
    'VD' : {
        'lsb'        : 100,
        'msb'        : 100,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'LS',
        'HINC',
        'ACMD',
        'LN',
        'HD',
        'VD',
    ],
} # End of packet: CCR_C2MC_REQ


# Packet CCR_C2MC_SECURE
packets['CCR_C2MC_SECURE'] = {
    'size' :  1,
    # Field: CCR_C2MC_SECURE.SECURE
    'SECURE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'SECURE',
    ],
} # End of packet: CCR_C2MC_SECURE


# Packet CCR_C2MC_RDI
packets['CCR_C2MC_RDI'] = {
    'size' :  256,
    # Field: CCR_C2MC_RDI.RDI
    'RDI' : {
        'lsb'        : 0,
        'msb'        : 255,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDI',
    ],
} # End of packet: CCR_C2MC_RDI


# Packet CCR_C2MC_HP
packets['CCR_C2MC_HP'] = {
    'size' :  38,
    # Field: CCR_C2MC_HP.HPTH
    'HPTH' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCR_C2MC_HP.HPTM
    'HPTM' : {
        'lsb'        : 32,
        'msb'        : 37,
        'size'       : 6,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HPTH',
        'HPTM',
    ],
} # End of packet: CCR_C2MC_HP


# Packet CCR_C2MC_HYST
packets['CCR_C2MC_HYST'] = {
    'size' :  32,
    # Field: CCR_C2MC_HYST.HYST
    'HYST' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HYST',
    ],
} # End of packet: CCR_C2MC_HYST

# Packets for mccif controlled write

# Packet CCW_C2MC_CLKEN
packets['CCW_C2MC_CLKEN'] = {
    'size' :  1,
    # Field: CCW_C2MC_CLKEN.CLKEN
    'CLKEN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'CLKEN',
    ],
} # End of packet: CCW_C2MC_CLKEN


# Packet CCW_C2MC_RESET
packets['CCW_C2MC_RESET'] = {
    'size' :  1,
    # Field: CCW_C2MC_RESET.RSTN
    'RSTN' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RSTN',
    ],
} # End of packet: CCW_C2MC_RESET


# Packet CCW_C2MC_REQ
packets['CCW_C2MC_REQ'] = {
    'size' :  418,
    # Field: CCW_C2MC_REQ.ADR
    'ADR' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.LS
    'LS' : {
        'lsb'        : 32,
        'msb'        : 63,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.HINC
    'HINC' : {
        'lsb'        : 64,
        'msb'        : 95,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.ACMD
    'ACMD' : {
        'lsb'        : 96,
        'msb'        : 97,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.LN
    'LN' : {
        'lsb'        : 98,
        'msb'        : 98,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.HD
    'HD' : {
        'lsb'        : 99,
        'msb'        : 99,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.VD
    'VD' : {
        'lsb'        : 100,
        'msb'        : 100,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.BPP
    'BPP' : {
        'lsb'        : 101,
        'msb'        : 102,
        'size'       : 2,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.XY
    'XY' : {
        'lsb'        : 103,
        'msb'        : 103,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.BE
    'BE' : {
        'lsb'        : 128,
        'msb'        : 159,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.WDO
    'WDO' : {
        'lsb'        : 160,
        'msb'        : 415,
        'size'       : 256,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.TAG
    'TAG' : {
        'lsb'        : 416,
        'msb'        : 416,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_REQ.VPR
    'VPR' : {
        'lsb'        : 417,
        'msb'        : 417,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'ADR',
        'LS',
        'HINC',
        'ACMD',
        'LN',
        'HD',
        'VD',
        'BPP',
        'XY',
        'BE',
        'WDO',
        'TAG',
        'VPR',
    ],
} # End of packet: CCW_C2MC_REQ


# Packet CCW_C2MC_SECURE
packets['CCW_C2MC_SECURE'] = {
    'size' :  1,
    # Field: CCW_C2MC_SECURE.SECURE
    'SECURE' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'SECURE',
    ],
} # End of packet: CCW_C2MC_SECURE

# combined with a REQP packet

# Packet CCW_C2MC_ADRXY
packets['CCW_C2MC_ADRXY'] = {
    'size' :  30,
    # Field: CCW_C2MC_ADRXY.OFFX
    'OFFX' : {
        'lsb'        : 0,
        'msb'        : 15,
        'size'       : 16,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_ADRXY.OFFY
    'OFFY' : {
        'lsb'        : 16,
        'msb'        : 29,
        'size'       : 14,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'OFFX',
        'OFFY',
    ],
} # End of packet: CCW_C2MC_ADRXY

# combined with a REQP packet

# Packet CCW_C2MC_TILE
packets['CCW_C2MC_TILE'] = {
    'size' :  41,
    # Field: CCW_C2MC_TILE.LINADR
    'LINADR' : {
        'lsb'        : 0,
        'msb'        : 39,
        'size'       : 40,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_TILE.TMODE
    'TMODE' : {
        'lsb'        : 40,
        'msb'        : 40,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
            'LINEAR' : 0,
            'TILED' : 1,
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'LINADR',
        'TMODE',
    ],
} # End of packet: CCW_C2MC_TILE


# Packet CCW_C2MC_XDI
packets['CCW_C2MC_XDI'] = {
    'size' :  1,
    # Field: CCW_C2MC_XDI.XDI
    'XDI' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'XDI',
    ],
} # End of packet: CCW_C2MC_XDI


# Packet CCW_C2MC_HP
packets['CCW_C2MC_HP'] = {
    'size' :  32,
    # Field: CCW_C2MC_HP.HPTH
    'HPTH' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HPTH',
    ],
} # End of packet: CCW_C2MC_HP


# Packet CCW_C2MC_WCOAL
packets['CCW_C2MC_WCOAL'] = {
    'size' :  32,
    # Field: CCW_C2MC_WCOAL.WCOALTM
    'WCOALTM' : {
        'lsb'        : 0,
        'msb'        : 31,
        'size'       : 32,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'WCOALTM',
    ],
} # End of packet: CCW_C2MC_WCOAL

# hysteresis control register

# Packet CCW_C2MC_HYST
packets['CCW_C2MC_HYST'] = {
    'size' :  32,
    # Field: CCW_C2MC_HYST.HYST_REQ_TM
    'HYST_REQ_TM' : {
        'lsb'        : 0,
        'msb'        : 11,
        'size'       : 12,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_HYST.HYST_REQ_TH
    'HYST_REQ_TH' : {
        'lsb'        : 28,
        'msb'        : 30,
        'size'       : 3,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: CCW_C2MC_HYST.HYST_EN
    'HYST_EN' : {
        'lsb'        : 31,
        'msb'        : 31,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'HYST_REQ_TM',
        'HYST_REQ_TH',
        'HYST_EN',
    ],
} # End of packet: CCW_C2MC_HYST

# Packet for mccif async fifo control

# Packet SC_MCCIF_ASYNC
packets['SC_MCCIF_ASYNC'] = {
    'size' :  4,
    # Field: SC_MCCIF_ASYNC.RDCL_RDFAST
    'RDCL_RDFAST' : {
        'lsb'        : 0,
        'msb'        : 0,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SC_MCCIF_ASYNC.RDMC_RDFAST
    'RDMC_RDFAST' : {
        'lsb'        : 1,
        'msb'        : 1,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SC_MCCIF_ASYNC.WRCL_MCLE2X
    'WRCL_MCLE2X' : {
        'lsb'        : 2,
        'msb'        : 2,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Field: SC_MCCIF_ASYNC.WRMC_CLLE2X
    'WRMC_CLLE2X' : {
        'lsb'        : 3,
        'msb'        : 3,
        'size'       : 1,
        'row'        : 0,
        'default'    : 0,
        'sw_default' : 0,
        'enums'      : {
        },
    },
    # Fields sorted in order of declaration in packet
    'field_list' : [
        'RDCL_RDFAST',
        'RDMC_RDFAST',
        'WRCL_MCLE2X',
        'WRMC_CLLE2X',
    ],
} # End of packet: SC_MCCIF_ASYNC

# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_R2R_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['R2R_0'] = {
    'addr'            : 0x144,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'R2R' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'R2R',
    ],
} # End of register: R2R_0

registers['EMC']['register_list'].append('R2R_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_W2W_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['W2W_0'] = {
    'addr'            : 0x148,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'W2W' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'W2W',
    ],
} # End of register: W2W_0

registers['EMC']['register_list'].append('W2W_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_EINPUT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['EINPUT_0'] = {
    'addr'            : 0x14c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'EINPUT' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EINPUT',
    ],
} # End of register: EINPUT_0

registers['EMC']['register_list'].append('EINPUT_0')
#
# The minimum for EINPUT_DURATION is 4.
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_EINPUT_DURATION_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['EINPUT_DURATION_0'] = {
    'addr'            : 0x150,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x4,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'EINPUT_DURATION' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EINPUT_DURATION',
    ],
} # End of register: EINPUT_DURATION_0

registers['EMC']['register_list'].append('EINPUT_DURATION_0')
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PUTERM_EXTRA_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PUTERM_EXTRA_0'] = {
    'addr'            : 0x154,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x1,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'RXTERM' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RXTERM',
    ],
} # End of register: PUTERM_EXTRA_0

registers['EMC']['register_list'].append('PUTERM_EXTRA_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TCKESR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TCKESR_0'] = {
    'addr'            : 0x158,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3e,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'TCKESR' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3e,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TCKESR',
    ],
} # End of register: TCKESR_0

registers['EMC']['register_list'].append('TCKESR_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_TPD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TPD_0'] = {
    'addr'            : 0x15c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x3e,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'TPD' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3e,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TPD',
    ],
} # End of register: TPD_0

registers['EMC']['register_list'].append('TPD_0')
# --------------------------------------------------------------------------
#
# Copyright (c) 2006, NVIDIA Corp.
# All Rights Reserved.
#
# This is UNPUBLISHED PROPRIETARY SOURCE CODE of NVIDIA Corp.;
# the contents of this file may not be disclosed to third parties, copied or
# duplicated in any form, in whole or in part, without the prior written
# permission of NVIDIA Corp.
#
# RESTRICTED RIGHTS LEGEND:
# Use, duplication or disclosure by the Government is subject to restrictions
# as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
# and Computer Software clause at DFARS 252.227-7013, and/or in similar or
# successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
# rights reserved under the Copyright Laws of the United States.
#
# --------------------------------------------------------------------------
#
# Derived from armc_stats.spec
#
# The emc statistics are for gathering statistics on the low-latency path.
# The registers are similar to those in armc_stat.spec where possible.
#
# Like the MC statistics, the DRAM  statistics are
# controlled by a STAT_CONTROL register.
#
# The DRAM group provides feedback on the exact activity occuring on
# the DRAM pins to a level of detail that should allow highly accurate
# estimation of power-consumption. Please note that the DRAM group uses
# 40-bit wide counters, with the LSBs in *_LO register and the MSBs in
# *_HI register. Also note that the counts are collected on a per-chip-select
# (aka "device") basis.
#
# If an EMC statistic register saturates, the statistic gathering
# will be halted for all statistics registers. Upon saturation, the
# appropriate bit will also be set in STAT_STATUS
# When the EMC statistics registers saturate, they will halt.
# The clock limit will not stop the EMC.
#
#    Similar to registers in mc for EMC:
#        rw STAT_CONTROL
#        r  STAT_STATUS
#
#    For external memory controller (DRAM):
#        rw STAT_DRAM_CLOCK_LIMIT
#        r  STAT_DRAM_CLOCKS
#        r  STAT_DRAM_DEV* (various counts)
#
# STAT_CONTROL is the control register for enabling/disabling the
# statistics collection for DRAM.
# STAT_CONTROL is the master switch that clears counter state,
# enables and disables all statistics collection for the low-latency controller.
#
# The *_GATHER bits are master control bits to turn collection on and off.
#
# The RST state for *_GATHER zeros out any counters.
# Once entered, *_GATHER stays in the RST state until software changes it.
#
# The CLEAR state for *_GATHER is similar to RST in that it zeros out
# any counters. Software an enter and exit the
# CLEAR state at will.  The CLEAR state persists until *_GATHER is
# changed under software control.
#
# The DISABLE state causes all statistics counters of a memory controller
# to freeze at their current value.  If the GATHER state goes back to
# ENABLE, the counters keep incrementing from their previous value.
#
# The ENABLE state is when the statistics counters increment.
# The counting activity is conditional on the LIMIT condition, described
# in the STAT_STATUS register.
#

# Register EMC_STAT_CONTROL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_CONTROL_0'] = {
    'addr'            : 0x160,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x2,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x30000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x30000,
    'write_mask'      : 0x30000,
    'DRAM_GATHER' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
            'init_enum'  : "RST",
        'enums' : {
            'RST' : 0,
            'CLEAR' : 1,
            'DISABLE' : 2,
            'ENABLE' : 3,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_GATHER',
    ],
} # End of register: STAT_CONTROL_0

registers['EMC']['register_list'].append('STAT_CONTROL_0')
# If the STAT_*_CLOCKS gets near (within 16 counts) the value of
# STAT_*_CLOCK_LIMIT, or if any of the STAT_*_COUNT or
# other counters gets near its maximum count
# of (2^40)-1, hardware will set the *_LIMIT field, below.  If this
# bit is set, statistics collection will be disabled until *_GATHER
# is set to the RST or CLEAR state.  It will NOT disable the EMC!  When
# hardware sets the LIMIT bit, the STAT_CONTROL.*_GATHER field will still
# read as ENABLE; hardware does not automatically flip it back to DISABLE.
#

# Register EMC_STAT_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_STATUS_0'] = {
    'addr'            : 0x164,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x10000,
    'write_mask'      : 0x0,
    'DRAM_LIMIT' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_LIMIT',
    ],
} # End of register: STAT_STATUS_0

registers['EMC']['register_list'].append('STAT_STATUS_0')
# This register controls the maximum number of cycles that data may be
# collected before the unit's STAT_STATUS.DRAM_LIMIT bit is set, freezing
# data collection.  It is useful for guaranteeing a fixed sampling interval.
# This limit isn't exact; hardware may stop things a few cycles early in
# order to account for potentially variable delays in stopping counting.
#

# Register EMC_STAT_DRAM_CLOCK_LIMIT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_CLOCK_LIMIT_LO_0'] = {
    'addr'            : 0x19c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xffffffff,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DRAM_CLOCK_LIMIT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0xffffffff,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
            'init_enum'  : "-1",
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_CLOCK_LIMIT_LO',
    ],
} # End of register: STAT_DRAM_CLOCK_LIMIT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_CLOCK_LIMIT_LO_0')

# Register EMC_STAT_DRAM_CLOCK_LIMIT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_CLOCK_LIMIT_HI_0'] = {
    'addr'            : 0x1a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0xff,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'DRAM_CLOCK_LIMIT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0xff,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_CLOCK_LIMIT_HI',
    ],
} # End of register: STAT_DRAM_CLOCK_LIMIT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_CLOCK_LIMIT_HI_0')
# This counts the total number of clocks that the corresponding
# STAT_CONTROL.DRAM_GATHER control was set to ENABLE.  It gets set to
# zero when STAT_CONTROL.DRAM_GATHER is set to either CLEAR or RST.
#

# Register EMC_STAT_DRAM_CLOCKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_CLOCKS_LO_0'] = {
    'addr'            : 0x1a4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DRAM_CLOCKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_CLOCKS_LO',
    ],
} # End of register: STAT_DRAM_CLOCKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_CLOCKS_LO_0')

# Register EMC_STAT_DRAM_CLOCKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_CLOCKS_HI_0'] = {
    'addr'            : 0x1a8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DRAM_CLOCKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_CLOCKS_HI',
    ],
} # End of register: STAT_DRAM_CLOCKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_CLOCKS_HI_0')
# The following applies to all the following register values:
# The value is cleared when STAT_CONTROL.DRAM_GATHER is set to CLEAR or
# RST.  If VAL is at or near the maximum count, the corresponding
# STAT_CONTROL.DRAM_LIMIT flag will be set and all counters in DRAM
# will freeze at their current count until cleared.
#The following registers track dram usage per chip-select.
#///////////////////////////////////////////////////////////////////////////////////
# DEV0:
#///////////////////////////////////////////////////////////////////////////////////
#  DEV0_ACTIVATE_CNT_*:  The number of activate commands sent to dram

# Register EMC_STAT_DRAM_DEV0_ACTIVATE_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_ACTIVATE_CNT_LO_0'] = {
    'addr'            : 0x1ac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_ACTIVATE_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_ACTIVATE_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV0_ACTIVATE_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_ACTIVATE_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV0_ACTIVATE_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_ACTIVATE_CNT_HI_0'] = {
    'addr'            : 0x1b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_ACTIVATE_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_ACTIVATE_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV0_ACTIVATE_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_ACTIVATE_CNT_HI_0')
#  DEV0_READ_CNT_*:  Number of read (any burst size) commands sent to dram

# Register EMC_STAT_DRAM_DEV0_READ_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_READ_CNT_LO_0'] = {
    'addr'            : 0x1b4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_READ_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_READ_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV0_READ_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_READ_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV0_READ_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_READ_CNT_HI_0'] = {
    'addr'            : 0x1b8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_READ_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_READ_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV0_READ_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_READ_CNT_HI_0')
#  DEV0_READ8_CNT_*:  Number of read (only burst size of 8) commands sent to dram

# Register EMC_STAT_DRAM_DEV0_READ8_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_READ8_CNT_LO_0'] = {
    'addr'            : 0x1bc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_READ8_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_READ8_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV0_READ8_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_READ8_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV0_READ8_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_READ8_CNT_HI_0'] = {
    'addr'            : 0x1c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_READ8_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_READ8_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV0_READ8_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_READ8_CNT_HI_0')
#  DEV0_WRITE_CNT_*:  Number of write (any burst size) commands sent to dram

# Register EMC_STAT_DRAM_DEV0_WRITE_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_WRITE_CNT_LO_0'] = {
    'addr'            : 0x1c4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_WRITE_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_WRITE_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV0_WRITE_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_WRITE_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV0_WRITE_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_WRITE_CNT_HI_0'] = {
    'addr'            : 0x1c8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_WRITE_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_WRITE_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV0_WRITE_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_WRITE_CNT_HI_0')
#  DEV0_WRITE8_CNT_*:  Number of write (only burst size of 8) commands sent to dram

# Register EMC_STAT_DRAM_DEV0_WRITE8_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_WRITE8_CNT_LO_0'] = {
    'addr'            : 0x1cc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_WRITE8_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_WRITE8_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV0_WRITE8_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_WRITE8_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV0_WRITE8_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_WRITE8_CNT_HI_0'] = {
    'addr'            : 0x1d0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_WRITE8_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_WRITE8_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV0_WRITE8_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_WRITE8_CNT_HI_0')
#DEV0_REF_CNT_*:  Number of all-bank refresh commands sent to dram

# Register EMC_STAT_DRAM_DEV0_REF_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_REF_CNT_LO_0'] = {
    'addr'            : 0x1d4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_REF_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_REF_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV0_REF_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_REF_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV0_REF_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_REF_CNT_HI_0'] = {
    'addr'            : 0x1d8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_REF_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_REF_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV0_REF_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_REF_CNT_HI_0')
#DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=0 (powerdown state)
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2P
# *   DDR3: IDD2P1

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x1dc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x1e0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=0 (powerdown state)
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2PS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x1e4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x1e8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=1
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2N
# *   DDR3: IDD2N

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x1ec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x1f0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=1
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2NS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x1f4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x1f8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=0 (powerdown state)
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3P
# *   DDR3: IDD3P

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x1fc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x200,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=0 (powerdown state)
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3PS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x204,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x208,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=1
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3N
# *   DDR3: IDD3N

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x20c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x210,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=1
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3NS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x214,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x218,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV0_SR_CKE_EQ0_CLKS_*:  Number of cycles dram is in self-refresh state

# Register EMC_STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_LO_0'] = {
    'addr'            : 0x21c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_SR_CKE_EQ0_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_SR_CKE_EQ0_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_HI_0'] = {
    'addr'            : 0x220,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_SR_CKE_EQ0_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_SR_CKE_EQ0_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_SR_CKE_EQ0_CLKS_HI_0')
# DEV0_DSR_STATS
# This register tracks stats that are useful for dynamic self-refresh optimization
# MIN_SREF_PERIOD is the shortest number of cycles that the DRAM is in self-refresh.

# Register EMC_STAT_DRAM_DEV0_DSR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_DSR_0'] = {
    'addr'            : 0x224,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_MIN_SREF_PERIOD' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_MIN_SREF_PERIOD',
    ],
} # End of register: STAT_DRAM_DEV0_DSR_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_DSR_0')
#The following registers track dram usage per chip-select.
#///////////////////////////////////////////////////////////////////////////////////
# DEV1:
#///////////////////////////////////////////////////////////////////////////////////
#  DEV1_ACTIVATE_CNT_*:  The number of activate commands sent to dram

# Register EMC_STAT_DRAM_DEV1_ACTIVATE_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_ACTIVATE_CNT_LO_0'] = {
    'addr'            : 0x228,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_ACTIVATE_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_ACTIVATE_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV1_ACTIVATE_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_ACTIVATE_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV1_ACTIVATE_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_ACTIVATE_CNT_HI_0'] = {
    'addr'            : 0x22c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_ACTIVATE_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_ACTIVATE_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV1_ACTIVATE_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_ACTIVATE_CNT_HI_0')
#  DEV1_READ_CNT_*:  Number of read (any burst size) commands sent to dram

# Register EMC_STAT_DRAM_DEV1_READ_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_READ_CNT_LO_0'] = {
    'addr'            : 0x230,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_READ_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_READ_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV1_READ_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_READ_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV1_READ_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_READ_CNT_HI_0'] = {
    'addr'            : 0x234,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_READ_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_READ_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV1_READ_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_READ_CNT_HI_0')
#  DEV1_READ8_CNT_*:  Number of read (only burst size of 8) commands sent to dram

# Register EMC_STAT_DRAM_DEV1_READ8_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_READ8_CNT_LO_0'] = {
    'addr'            : 0x238,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_READ8_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_READ8_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV1_READ8_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_READ8_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV1_READ8_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_READ8_CNT_HI_0'] = {
    'addr'            : 0x23c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_READ8_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_READ8_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV1_READ8_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_READ8_CNT_HI_0')
#  DEV1_WRITE_CNT_*:  Number of write (any burst size) commands sent to dram

# Register EMC_STAT_DRAM_DEV1_WRITE_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_WRITE_CNT_LO_0'] = {
    'addr'            : 0x240,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_WRITE_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_WRITE_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV1_WRITE_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_WRITE_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV1_WRITE_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_WRITE_CNT_HI_0'] = {
    'addr'            : 0x244,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_WRITE_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_WRITE_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV1_WRITE_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_WRITE_CNT_HI_0')
#  DEV1_WRITE_CNT_*:  Number of write (only burst size of 8) commands sent to dram

# Register EMC_STAT_DRAM_DEV1_WRITE8_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_WRITE8_CNT_LO_0'] = {
    'addr'            : 0x248,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_WRITE8_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_WRITE8_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV1_WRITE8_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_WRITE8_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV1_WRITE8_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_WRITE8_CNT_HI_0'] = {
    'addr'            : 0x24c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_WRITE8_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_WRITE8_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV1_WRITE8_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_WRITE8_CNT_HI_0')
#DEV1_REF_CNT_*:  Number of all-bank refresh commands sent to dram

# Register EMC_STAT_DRAM_DEV1_REF_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_REF_CNT_LO_0'] = {
    'addr'            : 0x250,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_REF_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_REF_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV1_REF_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_REF_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV1_REF_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_REF_CNT_HI_0'] = {
    'addr'            : 0x254,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_REF_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_REF_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV1_REF_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_REF_CNT_HI_0')
#DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=0 (powerdown state)
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2P
# *   DDR3: IDD2P1

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x258,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x25c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=0 (powerdown state)
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2PS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x260,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x264,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=1
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2N
# *   DDR3: IDD2N

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x268,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x26c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=1
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2NS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x270,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x274,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=0 (powerdown state)
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3P
# *   DDR3: IDD3P

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x278,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x27c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=0 (powerdown state)
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3PS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x280,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x284,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=1
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3N
# *   DDR3: IDD3N

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x288,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x28c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=1
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3NS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0x290,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0x294,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0')
#DEV1_SR_CKE_EQ0_CLKS_*:  Number of cycles dram is in self-refresh state

# Register EMC_STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_LO_0'] = {
    'addr'            : 0x298,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_SR_CKE_EQ0_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_SR_CKE_EQ0_CLKS_LO',
    ],
} # End of register: STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_LO_0')

# Register EMC_STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_HI_0'] = {
    'addr'            : 0x29c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_SR_CKE_EQ0_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_SR_CKE_EQ0_CLKS_HI',
    ],
} # End of register: STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_SR_CKE_EQ0_CLKS_HI_0')
# DEV1_DSR_STATS
# This register tracks stats that are useful for dynamic self-refresh optimization
# MIN_SREF_PERIOD is the shortest number of cycles that the DRAM is in self-refresh.

# Register EMC_STAT_DRAM_DEV1_DSR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_DSR_0'] = {
    'addr'            : 0x2a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_MIN_SREF_PERIOD' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_MIN_SREF_PERIOD',
    ],
} # End of register: STAT_DRAM_DEV1_DSR_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_DSR_0')
#offset 0x1000;
#I0_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=0 (powerdown state)
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2P
# *   DDR3: IDD2P1

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xc8c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xc90,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0')
#I0_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=0 (powerdown state)
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2PS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xc94,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xc98,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ0_NO_BANKS_ACTIVE_CLKS_HI_0')
#I0_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=1
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2N
# *   DDR3: IDD2N

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xc9c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xca0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0')
#I0_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=1
# * no banks active
#
# IDD condition:
# * LPDDR2: IDD2NS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xca4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xca8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ1_NO_BANKS_ACTIVE_CLKS_HI_0')
#I0_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=0 (powerdown state)
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3P
# *   DDR3: IDD3P

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xcac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xcb0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0')
#I0_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=0 (powerdown state)
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3PS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xcb4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xcb8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ0_SOME_BANKS_ACTIVE_CLKS_HI_0')
#I0_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is enabled
# * CKE=1
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3N
# *   DDR3: IDD3N

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xcbc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xcc0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_EXTCLKS_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0')
#I0_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_*:
# Number of cycles that:
# * external clock is stopped
# * CKE=1
# * at least 1 bank active
#
# IDD condition:
# * LPDDR2: IDD3NS
# *   DDR3: n/a

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0'] = {
    'addr'            : 0xcc4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0'] = {
    'addr'            : 0xcc8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_CLKSTOP_CKE_EQ1_SOME_BANKS_ACTIVE_CLKS_HI_0')
#I0_SR_CKE_EQ0_CLKS_*:  Number of cycles dram is in self-refresh state

# Register EMC_STAT_DRAM_IO_SR_CKE_EQ0_CLKS_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_SR_CKE_EQ0_CLKS_LO_0'] = {
    'addr'            : 0xccc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'IO_SR_CKE_EQ0_CLKS_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_SR_CKE_EQ0_CLKS_LO',
    ],
} # End of register: STAT_DRAM_IO_SR_CKE_EQ0_CLKS_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_SR_CKE_EQ0_CLKS_LO_0')

# Register EMC_STAT_DRAM_IO_SR_CKE_EQ0_CLKS_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_SR_CKE_EQ0_CLKS_HI_0'] = {
    'addr'            : 0xcd0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_SR_CKE_EQ0_CLKS_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_SR_CKE_EQ0_CLKS_HI',
    ],
} # End of register: STAT_DRAM_IO_SR_CKE_EQ0_CLKS_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_SR_CKE_EQ0_CLKS_HI_0')
# IO_DSR_STATS
# This register tracks stats that are useful for dynamic self-refresh optimization
# MIN_SREF_PERIOD is the shortest number of cycles that the DRAM is in self-refresh.

# Register EMC_STAT_DRAM_IO_DSR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_IO_DSR_0'] = {
    'addr'            : 0xcd4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'IO_MIN_SREF_PERIOD' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IO_MIN_SREF_PERIOD',
    ],
} # End of register: STAT_DRAM_IO_DSR_0

registers['EMC']['register_list'].append('STAT_DRAM_IO_DSR_0')
#DEV0_REFPB_CNT_*:  Number of per-bank refresh commands sent to dram

# Register EMC_STAT_DRAM_DEV0_REFPB_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_REFPB_CNT_LO_0'] = {
    'addr'            : 0x1000,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV0_REFPB_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_REFPB_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV0_REFPB_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_REFPB_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV0_REFPB_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV0_REFPB_CNT_HI_0'] = {
    'addr'            : 0x1004,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV0_REFPB_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV0_REFPB_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV0_REFPB_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV0_REFPB_CNT_HI_0')
#DEV1_REFPB_CNT_*:  Number of per-bank refresh commands sent to dram

# Register EMC_STAT_DRAM_DEV1_REFPB_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_REFPB_CNT_LO_0'] = {
    'addr'            : 0x1008,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DEV1_REFPB_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_REFPB_CNT_LO',
    ],
} # End of register: STAT_DRAM_DEV1_REFPB_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_REFPB_CNT_LO_0')

# Register EMC_STAT_DRAM_DEV1_REFPB_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_DEV1_REFPB_CNT_HI_0'] = {
    'addr'            : 0x100c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'DEV1_REFPB_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DEV1_REFPB_CNT_HI',
    ],
} # End of register: STAT_DRAM_DEV1_REFPB_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_DEV1_REFPB_CNT_HI_0')
#PERTR_CNT*:  Number of periodic trainings done

# Register EMC_STAT_DRAM_PERTR_CNT_LO_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_PERTR_CNT_LO_0'] = {
    'addr'            : 0x1010,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'PERTR_CNT_LO' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PERTR_CNT_LO',
    ],
} # End of register: STAT_DRAM_PERTR_CNT_LO_0

registers['EMC']['register_list'].append('STAT_DRAM_PERTR_CNT_LO_0')

# Register EMC_STAT_DRAM_PERTR_CNT_HI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STAT_DRAM_PERTR_CNT_HI_0'] = {
    'addr'            : 0x1014,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0x0,
    'PERTR_CNT_HI' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PERTR_CNT_HI',
    ],
} # End of register: STAT_DRAM_PERTR_CNT_HI_0

registers['EMC']['register_list'].append('STAT_DRAM_PERTR_CNT_HI_0')
# START Autocal registers
#
# *************************************
# Autocal master control registers
# *************************************
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG_0'] = {
    'addr'            : 0x2a4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xa195048,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'AUTO_CAL_COMPUTE_START' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_TRANSFER_START' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_UPDATE_START' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PU_VREF0_EN' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PU_VREF1_EN' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PU_VREF2_EN' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PD_VREF0_EN' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PD_VREF1_EN' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PD_VREF2_EN' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_MEASURE_STALL' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_UPDATE_STALL' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_UPDATE_DELAY' : {
        'lsb'               : 11,
        'msb'               : 15,
        'size'              : 5,
        'field'             : (0x1f << 11),
        'woffset'           : 0x0,
        'default'           : 0xa,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_STEP' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_WAIT_AFTER_EN' : {
        'lsb'               : 19,
        'msb'               : 23,
        'size'              : 5,
        'field'             : (0x1f << 19),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_CHECK_LOCK' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_NUM_SAMPLES' : {
        'lsb'               : 25,
        'msb'               : 28,
        'size'              : 4,
        'field'             : (0xf << 25),
        'woffset'           : 0x0,
        'default'           : 0x5,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_ENABLE' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'AUTO_CAL_COMP_PAD_FLIP' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_START' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_COMPUTE_START',
        'AUTO_CAL_TRANSFER_START',
        'AUTO_CAL_UPDATE_START',
        'AUTO_CAL_PU_VREF0_EN',
        'AUTO_CAL_PU_VREF1_EN',
        'AUTO_CAL_PU_VREF2_EN',
        'AUTO_CAL_PD_VREF0_EN',
        'AUTO_CAL_PD_VREF1_EN',
        'AUTO_CAL_PD_VREF2_EN',
        'AUTO_CAL_MEASURE_STALL',
        'AUTO_CAL_UPDATE_STALL',
        'AUTO_CAL_UPDATE_DELAY',
        'AUTO_CAL_STEP',
        'AUTO_CAL_WAIT_AFTER_EN',
        'AUTO_CAL_CHECK_LOCK',
        'AUTO_CAL_NUM_SAMPLES',
        'AUTO_CAL_ENABLE',
        'AUTO_CAL_COMP_PAD_FLIP',
        'AUTO_CAL_START',
    ],
} # End of register: AUTO_CAL_CONFIG_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG2_0'] = {
    'addr'            : 0x458,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfffffff,
    'write_mask'      : 0xfffffff,
    'AUTO_CAL_CLK_PU_CODE_SEL' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_CLK_PD_CODE_SEL' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_CA_PU_CODE_SEL' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_CA_PD_CODE_SEL' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_CMD_PU_CODE_SEL' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_CMD_PD_CODE_SEL' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQ_PU_CODE_SEL' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQ_PD_CODE_SEL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQS_PU_CODE_SEL' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQS_PD_CODE_SEL' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQ_PU_TERM_CODE_SEL' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQ_PD_TERM_CODE_SEL' : {
        'lsb'               : 22,
        'msb'               : 23,
        'size'              : 2,
        'field'             : (0x3 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQS_PU_TERM_CODE_SEL' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    'AUTO_CAL_DQS_PD_TERM_CODE_SEL' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "VREF0",
        'enums' : {
            'VREF0' : 0,
            'VREF1' : 1,
            'VREF2' : 2,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_CLK_PU_CODE_SEL',
        'AUTO_CAL_CLK_PD_CODE_SEL',
        'AUTO_CAL_CA_PU_CODE_SEL',
        'AUTO_CAL_CA_PD_CODE_SEL',
        'AUTO_CAL_CMD_PU_CODE_SEL',
        'AUTO_CAL_CMD_PD_CODE_SEL',
        'AUTO_CAL_DQ_PU_CODE_SEL',
        'AUTO_CAL_DQ_PD_CODE_SEL',
        'AUTO_CAL_DQS_PU_CODE_SEL',
        'AUTO_CAL_DQS_PD_CODE_SEL',
        'AUTO_CAL_DQ_PU_TERM_CODE_SEL',
        'AUTO_CAL_DQ_PD_TERM_CODE_SEL',
        'AUTO_CAL_DQS_PU_TERM_CODE_SEL',
        'AUTO_CAL_DQS_PD_TERM_CODE_SEL',
    ],
} # End of register: AUTO_CAL_CONFIG2_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG2_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG3_0'] = {
    'addr'            : 0x45c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x880000,
    'array'           : False,
    'reset_mask'      : 0xff7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff7f7f,
    'write_mask'      : 0xff7f7f,
    'AUTO_CAL_CLK_PU_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CLK_PD_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CLK_PU_SLOPE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CLK_PD_SLOPE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_CLK_PU_OFFSET',
        'AUTO_CAL_CLK_PD_OFFSET',
        'AUTO_CAL_CLK_PU_SLOPE',
        'AUTO_CAL_CLK_PD_SLOPE',
    ],
} # End of register: AUTO_CAL_CONFIG3_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG3_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG4_0'] = {
    'addr'            : 0x5b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x880000,
    'array'           : False,
    'reset_mask'      : 0xff7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff7f7f,
    'write_mask'      : 0xff7f7f,
    'AUTO_CAL_CA_PU_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CA_PD_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CA_PU_SLOPE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CA_PD_SLOPE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_CA_PU_OFFSET',
        'AUTO_CAL_CA_PD_OFFSET',
        'AUTO_CAL_CA_PU_SLOPE',
        'AUTO_CAL_CA_PD_SLOPE',
    ],
} # End of register: AUTO_CAL_CONFIG4_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG4_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG5_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG5_0'] = {
    'addr'            : 0x5b4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x880000,
    'array'           : False,
    'reset_mask'      : 0xff7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff7f7f,
    'write_mask'      : 0xff7f7f,
    'AUTO_CAL_CMD_PU_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CMD_PD_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CMD_PU_SLOPE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_CMD_PD_SLOPE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_CMD_PU_OFFSET',
        'AUTO_CAL_CMD_PD_OFFSET',
        'AUTO_CAL_CMD_PU_SLOPE',
        'AUTO_CAL_CMD_PD_SLOPE',
    ],
} # End of register: AUTO_CAL_CONFIG5_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG5_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG6_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG6_0'] = {
    'addr'            : 0x5cc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x880000,
    'array'           : False,
    'reset_mask'      : 0xff7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff7f7f,
    'write_mask'      : 0xff7f7f,
    'AUTO_CAL_DQ_PU_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQ_PD_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQ_PU_SLOPE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQ_PD_SLOPE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_DQ_PU_OFFSET',
        'AUTO_CAL_DQ_PD_OFFSET',
        'AUTO_CAL_DQ_PU_SLOPE',
        'AUTO_CAL_DQ_PD_SLOPE',
    ],
} # End of register: AUTO_CAL_CONFIG6_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG6_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG7_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG7_0'] = {
    'addr'            : 0x574,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x880000,
    'array'           : False,
    'reset_mask'      : 0xff7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff7f7f,
    'write_mask'      : 0xff7f7f,
    'AUTO_CAL_DQS_PU_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQS_PD_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQS_PU_SLOPE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQS_PD_SLOPE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_DQS_PU_OFFSET',
        'AUTO_CAL_DQS_PD_OFFSET',
        'AUTO_CAL_DQS_PU_SLOPE',
        'AUTO_CAL_DQS_PD_SLOPE',
    ],
} # End of register: AUTO_CAL_CONFIG7_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG7_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG8_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG8_0'] = {
    'addr'            : 0x2dc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x880000,
    'array'           : False,
    'reset_mask'      : 0xff7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff7f7f,
    'write_mask'      : 0xff7f7f,
    'AUTO_CAL_DQ_TERM_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQS_TERM_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQ_TERM_SLOPE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_DQS_TERM_SLOPE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_DQ_TERM_OFFSET',
        'AUTO_CAL_DQS_TERM_OFFSET',
        'AUTO_CAL_DQ_TERM_SLOPE',
        'AUTO_CAL_DQS_TERM_SLOPE',
    ],
} # End of register: AUTO_CAL_CONFIG8_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG8_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_CONFIG9_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG9_0'] = {
    'addr'            : 0x42c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x11,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1007f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1007f,
    'write_mask'      : 0x1007f,
    'AUTO_CAL_OVERRIDE_CA' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_OVERRIDE_CLK' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_OVERRIDE_CMD' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_OVERRIDE_DQ' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_OVERRIDE_DQ_TERM' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_OVERRIDE_DQS' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_OVERRIDE_DQS_TERM' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_DISABLE_MASTER' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "OFF",
        'enums' : {
            'OFF' : 0,
            'ON' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_OVERRIDE_CA',
        'AUTO_CAL_OVERRIDE_CLK',
        'AUTO_CAL_OVERRIDE_CMD',
        'AUTO_CAL_OVERRIDE_DQ',
        'AUTO_CAL_OVERRIDE_DQ_TERM',
        'AUTO_CAL_OVERRIDE_DQS',
        'AUTO_CAL_OVERRIDE_DQS_TERM',
        'AUTO_CAL_DISABLE_MASTER',
    ],
} # End of register: AUTO_CAL_CONFIG9_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG9_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# manually added by Gil Jung 
# Register EMC_AUTO_CAL_CONFIG10_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CONFIG10_0'] = {
    'addr'            : 0x574,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x880000,
    'array'           : False,
    'reset_mask'      : 0xff7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff7f7f,
    'write_mask'      : 0xff7f7f,
    'AUTO_CAL_WCK_PU_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_WCK_PD_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_WCK_PU_SLOPE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_WCK_PD_SLOPE' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_WCK_PU_OFFSET',
        'AUTO_CAL_WCK_PD_OFFSET',
        'AUTO_CAL_WCK_PU_SLOPE',
        'AUTO_CAL_WCK_PD_SLOPE',
    ],
} # End of register: AUTO_CAL_CONFIG10_0

registers['EMC']['register_list'].append('AUTO_CAL_CONFIG10_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.



# Register EMC_AUTO_CAL_VREF_SEL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_VREF_SEL_0_0'] = {
    'addr'            : 0x2f8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x3c3c3c3c,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'AUTO_CAL_PU_VREF0_SEL' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3c,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PU_VREF0_CAL_MODE' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PD_VREF0_SEL' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3c,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PD_VREF0_CAL_MODE' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PU_VREF1_SEL' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x3c,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PU_VREF1_CAL_MODE' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PD_VREF1_SEL' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x3c,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PD_VREF1_CAL_MODE' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_PU_VREF0_SEL',
        'AUTO_CAL_PU_VREF0_CAL_MODE',
        'AUTO_CAL_PD_VREF0_SEL',
        'AUTO_CAL_PD_VREF0_CAL_MODE',
        'AUTO_CAL_PU_VREF1_SEL',
        'AUTO_CAL_PU_VREF1_CAL_MODE',
        'AUTO_CAL_PD_VREF1_SEL',
        'AUTO_CAL_PD_VREF1_CAL_MODE',
    ],
} # End of register: AUTO_CAL_VREF_SEL_0_0

registers['EMC']['register_list'].append('AUTO_CAL_VREF_SEL_0_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_VREF_SEL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_VREF_SEL_1_0'] = {
    'addr'            : 0x300,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x3c3c,
    'array'           : False,
    'reset_mask'      : 0xfff0ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff0ffff,
    'write_mask'      : 0xfff0ffff,
    'AUTO_CAL_PU_VREF2_SEL' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3c,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PU_VREF2_CAL_MODE' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PD_VREF2_SEL' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3c,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PD_VREF2_CAL_MODE' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_PU_ZCTRL0' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PD_ZCTRL0' : {
        'lsb'               : 22,
        'msb'               : 23,
        'size'              : 2,
        'field'             : (0x3 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PU_ZCTRL1' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PD_ZCTRL1' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PU_ZCTRL2' : {
        'lsb'               : 28,
        'msb'               : 29,
        'size'              : 2,
        'field'             : (0x3 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_PD_ZCTRL2' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_PU_VREF2_SEL',
        'AUTO_CAL_PU_VREF2_CAL_MODE',
        'AUTO_CAL_PD_VREF2_SEL',
        'AUTO_CAL_PD_VREF2_CAL_MODE',
        'AUTO_CAL_PU_ZCTRL0',
        'AUTO_CAL_PD_ZCTRL0',
        'AUTO_CAL_PU_ZCTRL1',
        'AUTO_CAL_PD_ZCTRL1',
        'AUTO_CAL_PU_ZCTRL2',
        'AUTO_CAL_PD_ZCTRL2',
    ],
} # End of register: AUTO_CAL_VREF_SEL_1_0

registers['EMC']['register_list'].append('AUTO_CAL_VREF_SEL_1_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_INTERVAL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_INTERVAL_0'] = {
    'addr'            : 0x2a8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x15,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1fffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1fffff,
    'write_mask'      : 0x1fffff,
    'AUTO_CAL_INTERVAL' : {
        'lsb'               : 0,
        'msb'               : 20,
        'size'              : 21,
        'field'             : (0x1fffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_INTERVAL',
    ],
} # End of register: AUTO_CAL_INTERVAL_0

registers['EMC']['register_list'].append('AUTO_CAL_INTERVAL_0')
# *************************************
# Autocal master status registers
# *************************************
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_STATUS_0'] = {
    'addr'            : 0x2ac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3f131f,
    'write_mask'      : 0x0,
    'AUTO_CAL_MEASURE_ACTIVE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_COMPUTE_ACTIVE' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_TRANSFER_ACTIVE' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_UPDATE_ACTIVE' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_ACTIVE' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_PU_CAL_ZI' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_PD_CAL_ZI' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_MASTER_ENABLED' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_VREF0_DRVUP' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_VREF0_DRVDN' : {
        'lsb'               : 24,
        'msb'               : 29,
        'size'              : 6,
        'field'             : (0x3f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_MEASURE_ACTIVE',
        'AUTO_CAL_COMPUTE_ACTIVE',
        'AUTO_CAL_TRANSFER_ACTIVE',
        'AUTO_CAL_UPDATE_ACTIVE',
        'AUTO_CAL_ACTIVE',
        'AUTO_CAL_PU_CAL_ZI',
        'AUTO_CAL_PD_CAL_ZI',
        'AUTO_CAL_MASTER_ENABLED',
        'AUTO_CAL_VREF0_DRVUP',
        'AUTO_CAL_VREF0_DRVDN',
    ],
} # End of register: AUTO_CAL_STATUS_0

registers['EMC']['register_list'].append('AUTO_CAL_STATUS_0')
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_AUTO_CAL_STATUS2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_STATUS2_0'] = {
    'addr'            : 0x3d4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3f3f3f,
    'write_mask'      : 0x0,
    'AUTO_CAL_VREF1_DRVUP' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_VREF1_DRVDN' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_VREF2_DRVUP' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'AUTO_CAL_VREF2_DRVDN' : {
        'lsb'               : 24,
        'msb'               : 29,
        'size'              : 6,
        'field'             : (0x3f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_VREF1_DRVUP',
        'AUTO_CAL_VREF1_DRVDN',
        'AUTO_CAL_VREF2_DRVUP',
        'AUTO_CAL_VREF2_DRVDN',
    ],
} # End of register: AUTO_CAL_STATUS2_0

registers['EMC']['register_list'].append('AUTO_CAL_STATUS2_0')
# *************************************
# Autocal slave control registers
# *************************************
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_AUTO_CAL_CHANNEL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_CHANNEL_0'] = {
    'addr'            : 0x464,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xd280030a,
    'array'           : False,
    'reset_mask'      : 0xffff0f3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff0f3f,
    'write_mask'      : 0xffff0f3f,
    'AUTO_CAL_NUM_STALL_CYCLES' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0xa,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_WAIT_BEFORE_UPDATE' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_UPDATE_TIMEOUT' : {
        'lsb'               : 16,
        'msb'               : 20,
        'size'              : 5,
        'field'             : (0x1f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CAL_WAIT_AFTER_DVFS' : {
        'lsb'               : 21,
        'msb'               : 27,
        'size'              : 7,
        'field'             : (0x7f << 21),
        'woffset'           : 0x0,
        'default'           : 0x14,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_UPDATE_WAIT_MC_ACK' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'AUTO_CAL_COMPUTE_START_DVFS' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_STALL_ALL_TRAFFIC' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_UPDATE_IDLE' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_NUM_STALL_CYCLES',
        'AUTO_CAL_WAIT_BEFORE_UPDATE',
        'AUTO_CAL_UPDATE_TIMEOUT',
        'CAL_WAIT_AFTER_DVFS',
        'AUTO_CAL_UPDATE_WAIT_MC_ACK',
        'AUTO_CAL_COMPUTE_START_DVFS',
        'AUTO_CAL_STALL_ALL_TRAFFIC',
        'AUTO_CAL_UPDATE_IDLE',
    ],
} # End of register: AUTO_CAL_CHANNEL_0

registers['EMC']['register_list'].append('AUTO_CAL_CHANNEL_0')
# *************************************
# Autocal refresh event generation
# *************************************
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Autocal needs an all-bank refresh to occur periodically. If per-bank refresh is enabled, this register can be used to generate
# a periodic all-bank refresh with microsecond resolution.

# Register EMC_AUTO_CAL_REFRESH_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['AUTO_CAL_REFRESH_0'] = {
    'addr'            : 0x478,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffff,
    'write_mask'      : 0xffffff,
    'AUTO_CAL_REFRESH_CNT' : {
        'lsb'               : 0,
        'msb'               : 23,
        'size'              : 24,
        'field'             : (0xffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_REFRESH_CNT',
    ],
} # End of register: AUTO_CAL_REFRESH_0

registers['EMC']['register_list'].append('AUTO_CAL_REFRESH_0')
# *************************************
# Autocal padmacro control registers
# *************************************
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_RX_TERM_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_RX_TERM_0'] = {
    'addr'            : 0xc48,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x3f3f3f3f,
    'array'           : False,
    'reset_mask'      : 0x3f3f3f3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3f3f3f,
    'write_mask'      : 0x3f3f3f3f,
    'DQ_RX_DRVUP_TERM' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_RX_DRVDN_TERM' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQS_RX_DRVUP_TERM' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQS_RX_DRVDN_TERM' : {
        'lsb'               : 24,
        'msb'               : 29,
        'size'              : 6,
        'field'             : (0x3f << 24),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_RX_DRVUP_TERM',
        'DQ_RX_DRVDN_TERM',
        'DQS_RX_DRVUP_TERM',
        'DQS_RX_DRVDN_TERM',
    ],
} # End of register: PMACRO_RX_TERM_0

registers['EMC']['register_list'].append('PMACRO_RX_TERM_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DQ_TX_DRV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DQ_TX_DRV_0'] = {
    'addr'            : 0xc70,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x3f3f3f3f,
    'array'           : False,
    'reset_mask'      : 0x3f3f3f3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3f3f3f,
    'write_mask'      : 0x3f3f3f3f,
    'DATA_DQ_TX_DRVUP' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_DRVDN' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_DRVUP' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_DRVDN' : {
        'lsb'               : 24,
        'msb'               : 29,
        'size'              : 6,
        'field'             : (0x3f << 24),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA_DQ_TX_DRVUP',
        'DATA_DQ_TX_DRVDN',
        'DATA_DQS_TX_DRVUP',
        'DATA_DQS_TX_DRVDN',
    ],
} # End of register: PMACRO_DQ_TX_DRV_0

registers['EMC']['register_list'].append('PMACRO_DQ_TX_DRV_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CA_TX_DRV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CA_TX_DRV_0'] = {
    'addr'            : 0xc74,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x3f3f3f3f,
    'array'           : False,
    'reset_mask'      : 0x3f3f3f3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3f3f3f,
    'write_mask'      : 0x3f3f3f3f,
    'CMD_DQ_TX_DRVUP' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_DRVDN' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_DRVUP' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_DRVDN' : {
        'lsb'               : 24,
        'msb'               : 29,
        'size'              : 6,
        'field'             : (0x3f << 24),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DQ_TX_DRVUP',
        'CMD_DQ_TX_DRVDN',
        'CMD_DQS_TX_DRVUP',
        'CMD_DQS_TX_DRVDN',
    ],
} # End of register: PMACRO_CA_TX_DRV_0

registers['EMC']['register_list'].append('PMACRO_CA_TX_DRV_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CMD_TX_DRV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_TX_DRV_0'] = {
    'addr'            : 0xc4c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xe,
    'reset_val'       : 0x3f3f,
    'array'           : False,
    'reset_mask'      : 0x3f3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3f,
    'write_mask'      : 0x3f3f,
    'CMD_TX_DRVUP' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_DRVDN' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_TX_DRVUP',
        'CMD_TX_DRVDN',
    ],
} # End of register: PMACRO_CMD_TX_DRV_0

registers['EMC']['register_list'].append('PMACRO_CMD_TX_DRV_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_AUTOCAL_CFG_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_AUTOCAL_CFG_0_0'] = {
    'addr'            : 0x700,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x4040404,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'CMD_DRV_SEL_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CMD",
        'enums' : {
            'CMD' : 0,
            'CA' : 1,
        },
    },
    'DQS_DRV_SEL_BYTE0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DQS",
        'enums' : {
            'DQS' : 0,
            'CA' : 1,
        },
    },
    'DQS_E_CAL_BYPASS_BYTE0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'DQS_E_CAL_UPDATE_BYTE0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'CMD_DRV_SEL_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CMD",
        'enums' : {
            'CMD' : 0,
            'CA' : 1,
        },
    },
    'DQS_DRV_SEL_BYTE1' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DQS",
        'enums' : {
            'DQS' : 0,
            'CA' : 1,
        },
    },
    'DQS_E_CAL_BYPASS_BYTE1' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'DQS_E_CAL_UPDATE_BYTE1' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'CMD_DRV_SEL_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CMD",
        'enums' : {
            'CMD' : 0,
            'CA' : 1,
        },
    },
    'DQS_DRV_SEL_BYTE2' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DQS",
        'enums' : {
            'DQS' : 0,
            'CA' : 1,
        },
    },
    'DQS_E_CAL_BYPASS_BYTE2' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'DQS_E_CAL_UPDATE_BYTE2' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'CMD_DRV_SEL_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CMD",
        'enums' : {
            'CMD' : 0,
            'CA' : 1,
        },
    },
    'DQS_DRV_SEL_BYTE3' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DQS",
        'enums' : {
            'DQS' : 0,
            'CA' : 1,
        },
    },
    'DQS_E_CAL_BYPASS_BYTE3' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'DQS_E_CAL_UPDATE_BYTE3' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DRV_SEL_BYTE0',
        'DQS_DRV_SEL_BYTE0',
        'DQS_E_CAL_BYPASS_BYTE0',
        'DQS_E_CAL_UPDATE_BYTE0',
        'CMD_DRV_SEL_BYTE1',
        'DQS_DRV_SEL_BYTE1',
        'DQS_E_CAL_BYPASS_BYTE1',
        'DQS_E_CAL_UPDATE_BYTE1',
        'CMD_DRV_SEL_BYTE2',
        'DQS_DRV_SEL_BYTE2',
        'DQS_E_CAL_BYPASS_BYTE2',
        'DQS_E_CAL_UPDATE_BYTE2',
        'CMD_DRV_SEL_BYTE3',
        'DQS_DRV_SEL_BYTE3',
        'DQS_E_CAL_BYPASS_BYTE3',
        'DQS_E_CAL_UPDATE_BYTE3',
    ],
} # End of register: PMACRO_AUTOCAL_CFG_0_0

registers['EMC']['register_list'].append('PMACRO_AUTOCAL_CFG_0_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_AUTOCAL_CFG_1         EMC_WINCR // Autocal padmacro register for controls that are per-IOBRICK
#;
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_AUTOCAL_CFG_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_AUTOCAL_CFG_2_0'] = {
    'addr'            : 0x708,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x404,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'CMD_DRV_SEL_CMD0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CMD",
        'enums' : {
            'CMD' : 0,
            'CA' : 1,
        },
    },
    'DQS_DRV_SEL_CMD0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DQS",
        'enums' : {
            'DQS' : 0,
            'CA' : 1,
        },
    },
    'DQS_E_CAL_BYPASS_CMD0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'DQS_E_CAL_UPDATE_CMD0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'CMD_DRV_SEL_CMD1' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CMD",
        'enums' : {
            'CMD' : 0,
            'CA' : 1,
        },
    },
    'DQS_DRV_SEL_CMD1' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DQS",
        'enums' : {
            'DQS' : 0,
            'CA' : 1,
        },
    },
    'DQS_E_CAL_BYPASS_CMD1' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'DQS_E_CAL_UPDATE_CMD1' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DRV_SEL_CMD0',
        'DQS_DRV_SEL_CMD0',
        'DQS_E_CAL_BYPASS_CMD0',
        'DQS_E_CAL_UPDATE_CMD0',
        'CMD_DRV_SEL_CMD1',
        'DQS_DRV_SEL_CMD1',
        'DQS_E_CAL_BYPASS_CMD1',
        'DQS_E_CAL_UPDATE_CMD1',
    ],
} # End of register: PMACRO_AUTOCAL_CFG_2_0

registers['EMC']['register_list'].append('PMACRO_AUTOCAL_CFG_2_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_AUTOCAL_CFG_COMMON_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_AUTOCAL_CFG_COMMON_0'] = {
    'addr'            : 0xc78,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x11,
    'reset_val'       : 0x810,
    'array'           : False,
    'reset_mask'      : 0x13f3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x13f3f,
    'write_mask'      : 0x13f3f,
    'E_CAL_UPDATE_DELAY' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x10,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'E_CAL_UPDATE_HIGH' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'E_CAL_BYPASS_DVFS' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'E_CAL_UPDATE_DELAY',
        'E_CAL_UPDATE_HIGH',
        'E_CAL_BYPASS_DVFS',
    ],
} # End of register: PMACRO_AUTOCAL_CFG_COMMON_0

registers['EMC']['register_list'].append('PMACRO_AUTOCAL_CFG_COMMON_0')
# This register is shadowed: see usage note at top of spec file.
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_ZCTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_ZCTRL_0'] = {
    'addr'            : 0xc44,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffff0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffff0,
    'write_mask'      : 0xffffff0,
    'DQ_RX_DRVUP_TERM_ZCTRL' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQS_RX_DRVUP_TERM_ZCTRL' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_RX_DRVDN_TERM_ZCTRL' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQS_RX_DRVDN_TERM_ZCTRL' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_DRVUP_ZCTRL' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_DRVUP_ZCTRL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_DRVDN_ZCTRL' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_DRVDN_ZCTRL' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_DRVUP_ZCTRL' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_DRVUP_ZCTRL' : {
        'lsb'               : 22,
        'msb'               : 23,
        'size'              : 2,
        'field'             : (0x3 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_DRVDN_ZCTRL' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_DRVDN_ZCTRL' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_RX_DRVUP_TERM_ZCTRL',
        'DQS_RX_DRVUP_TERM_ZCTRL',
        'DQ_RX_DRVDN_TERM_ZCTRL',
        'DQS_RX_DRVDN_TERM_ZCTRL',
        'CMD_DQ_TX_DRVUP_ZCTRL',
        'CMD_DQS_TX_DRVUP_ZCTRL',
        'CMD_DQ_TX_DRVDN_ZCTRL',
        'CMD_DQS_TX_DRVDN_ZCTRL',
        'DATA_DQ_TX_DRVUP_ZCTRL',
        'DATA_DQS_TX_DRVUP_ZCTRL',
        'DATA_DQ_TX_DRVDN_ZCTRL',
        'DATA_DQS_TX_DRVDN_ZCTRL',
    ],
} # End of register: PMACRO_ZCTRL_0

registers['EMC']['register_list'].append('PMACRO_ZCTRL_0')
# *************************************
# Autocal comp pad control registers
# *************************************
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_XM2COMPPADCTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['XM2COMPPADCTRL_0'] = {
    'addr'            : 0x30c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x32,
    'array'           : False,
    'reset_mask'      : 0xff0ffa73,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff0ffa73,
    'write_mask'      : 0xff0ffa73,
    'EMC2TMC_CFG_XM2COMP_MEM_MODE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "LPDDR4",
        'enums' : {
            'LPDDR23' : 0,
            'SDDR3' : 1,
            'LPDDR4' : 2,
            'RFU' : 3,
        },
    },
    'EMC2TMC_CFG_XM2COMP_BG_SETUP' : {
        'lsb'               : 4,
        'msb'               : 6,
        'size'              : 3,
        'field'             : (0x7 << 4),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2TMC_CFG_XM2COMP_E_PWRD' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'EMC2TMC_CFG_XM2COMP_E_TESTOUT' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'EMC2TMC_CFG_XM2COMP_RFU' : {
        'lsb'               : 12,
        'msb'               : 19,
        'size'              : 8,
        'field'             : (0xff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM2COMP_VTTCDB_VDDA_LOAD' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC2TMC_CFG_XM2COMP_MEM_MODE',
        'EMC2TMC_CFG_XM2COMP_BG_SETUP',
        'EMC2TMC_CFG_XM2COMP_E_PWRD',
        'EMC2TMC_CFG_XM2COMP_E_TESTOUT',
        'EMC2TMC_CFG_XM2COMP_RFU',
        'XM2COMP_VTTCDB_VDDA_LOAD',
    ],
} # End of register: XM2COMPPADCTRL_0

registers['EMC']['register_list'].append('XM2COMPPADCTRL_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_XM2COMPPADCTRL2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['XM2COMPPADCTRL2_0'] = {
    'addr'            : 0x578,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x18000000,
    'array'           : False,
    'reset_mask'      : 0x3f33f03f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f33f03f,
    'write_mask'      : 0x3f33f03f,
    'EMC2TMC_CFG_XM2COMP_PU_RX_MODE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SCHMITT",
        'enums' : {
            'SCHMITT' : 0,
            'RFU0' : 1,
            'DIFFAMP' : 2,
            'RFU1' : 3,
        },
    },
    'EMC2TMC_CFG_XM2COMP_PU_TEST_MODE' : {
        'lsb'               : 2,
        'msb'               : 5,
        'size'              : 4,
        'field'             : (0xf << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2TMC_CFG_XM2COMP_PU_DRVUP_ZCTRL' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2TMC_CFG_XM2COMP_PU_DRVDN_ZCTRL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2TMC_CFG_XM2COMP_PU_E_WKPU' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'EMC2TMC_CFG_XM2COMP_PU_E_WKPD' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'XM2COMP_VTTCDB_VDDA_WB_CTRL' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM2COMP_VTTCDB_VDDA_CTRL' : {
        'lsb'               : 24,
        'msb'               : 29,
        'size'              : 6,
        'field'             : (0x3f << 24),
        'woffset'           : 0x0,
        'default'           : 0x18,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC2TMC_CFG_XM2COMP_PU_RX_MODE',
        'EMC2TMC_CFG_XM2COMP_PU_TEST_MODE',
        'EMC2TMC_CFG_XM2COMP_PU_DRVUP_ZCTRL',
        'EMC2TMC_CFG_XM2COMP_PU_DRVDN_ZCTRL',
        'EMC2TMC_CFG_XM2COMP_PU_E_WKPU',
        'EMC2TMC_CFG_XM2COMP_PU_E_WKPD',
        'XM2COMP_VTTCDB_VDDA_WB_CTRL',
        'XM2COMP_VTTCDB_VDDA_CTRL',
    ],
} # End of register: XM2COMPPADCTRL2_0

registers['EMC']['register_list'].append('XM2COMPPADCTRL2_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_XM2COMPPADCTRL3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['XM2COMPPADCTRL3_0'] = {
    'addr'            : 0x2f4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0xb00000,
    'array'           : False,
    'reset_mask'      : 0xf3f03f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf3f03f,
    'write_mask'      : 0xf3f03f,
    'EMC2TMC_CFG_XM2COMP_PD_RX_MODE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "SCHMITT",
        'enums' : {
            'SCHMITT' : 0,
            'RFU0' : 1,
            'DIFFAMP' : 2,
            'RFU1' : 3,
        },
    },
    'EMC2TMC_CFG_XM2COMP_PD_TEST_MODE' : {
        'lsb'               : 2,
        'msb'               : 5,
        'size'              : 4,
        'field'             : (0xf << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2TMC_CFG_XM2COMP_PD_DRVUP_ZCTRL' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2TMC_CFG_XM2COMP_PD_DRVDN_ZCTRL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2TMC_CFG_XM2COMP_PD_E_WKPU' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'EMC2TMC_CFG_XM2COMP_PD_E_WKPD' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'XM2COMP_VTTCDB_VDDA_LVL' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC2TMC_CFG_XM2COMP_PD_RX_MODE',
        'EMC2TMC_CFG_XM2COMP_PD_TEST_MODE',
        'EMC2TMC_CFG_XM2COMP_PD_DRVUP_ZCTRL',
        'EMC2TMC_CFG_XM2COMP_PD_DRVDN_ZCTRL',
        'EMC2TMC_CFG_XM2COMP_PD_E_WKPU',
        'EMC2TMC_CFG_XM2COMP_PD_E_WKPD',
        'XM2COMP_VTTCDB_VDDA_LVL',
    ],
} # End of register: XM2COMPPADCTRL3_0

registers['EMC']['register_list'].append('XM2COMPPADCTRL3_0')
# Only EMC CH0/CH2 versions of this register are used in the design.

# Register EMC_COMP_PAD_SW_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['COMP_PAD_SW_CTRL_0'] = {
    'addr'            : 0x57c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x738000f0,
    'array'           : False,
    'reset_mask'      : 0x7bfffdfd,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7bfffdfd,
    'write_mask'      : 0x7bfffdfd,
    'AUTO_CAL_SW_CTRL' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_IVREF_LVL' : {
        'lsb'               : 2,
        'msb'               : 8,
        'size'              : 7,
        'field'             : (0x7f << 2),
        'woffset'           : 0x0,
        'default'           : 0x3c,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_SW_CTRL_DRVUP' : {
        'lsb'               : 10,
        'msb'               : 15,
        'size'              : 6,
        'field'             : (0x3f << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_SW_CTRL_DRVDN' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'AUTO_CAL_SW_CTRL_PU_CAL_EN' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'ENABLE' : 0,
            'DISABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_PU_CAL_E_INPUT' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_PU_CAL_E_IVREF' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_PU_CAL_IVREF_CAL' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_PD_CAL_EN' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'ENABLE' : 0,
            'DISABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_PD_CAL_E_INPUT' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_PD_CAL_E_IVREF' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'AUTO_CAL_SW_CTRL_PD_CAL_IVREF_CAL' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'AUTO_CAL_SW_CTRL',
        'AUTO_CAL_SW_CTRL_IVREF_LVL',
        'AUTO_CAL_SW_CTRL_DRVUP',
        'AUTO_CAL_SW_CTRL_DRVDN',
        'AUTO_CAL_SW_CTRL_PU_CAL_EN',
        'AUTO_CAL_SW_CTRL_PU_CAL_E_INPUT',
        'AUTO_CAL_SW_CTRL_PU_CAL_E_IVREF',
        'AUTO_CAL_SW_CTRL_PU_CAL_IVREF_CAL',
        'AUTO_CAL_SW_CTRL_PD_CAL_EN',
        'AUTO_CAL_SW_CTRL_PD_CAL_E_INPUT',
        'AUTO_CAL_SW_CTRL_PD_CAL_E_IVREF',
        'AUTO_CAL_SW_CTRL_PD_CAL_IVREF_CAL',
    ],
} # End of register: COMP_PAD_SW_CTRL_0

registers['EMC']['register_list'].append('COMP_PAD_SW_CTRL_0')
# END Autocal registers
#  When either STALL_ALL_READS and/or STALL_ALL_WRITES is asserted, the stalling of read and/or write requests will not take effect
#  until the status bit from EMC_STATUS regster's NO_OUTSTANDING_TRANSACTIONS field is asserted.

# Register EMC_REQ_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['REQ_CTRL_0'] = {
    'addr'            : 0x2b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x107,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x107,
    'read_mask'       : 0x107,
    'write_mask'      : 0x107,
    'STALL_ALL_READS' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'STALL_ALL_WRITES' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'FORCE_REFAB' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'KILL_DECERR_READS' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'STALL_ALL_READS',
        'STALL_ALL_WRITES',
        'FORCE_REFAB',
        'KILL_DECERR_READS',
    ],
} # End of register: REQ_CTRL_0

registers['EMC']['register_list'].append('REQ_CTRL_0')
#   DRAM_IN_POWERDOWN, DRAM_IN_SELF_REFRESH, DRAM_IN_DPD: active high signal indicating current DRAM
#     status for each of these modes, w/ 1 status bit per device, bit[0] = dev0 status, bit[1] = dev1 status
#     Example: DRAM_IN_SELF_REFRESH = 0x3, both devices are in self-refresh, DRAM_IN_DPD= 0x2 would indicate only dev1 is in
#     deep-power-down mode.  NOTE: If EMC is reset or powered down, the actual DRAM state could be different than indicated by these
#     status bits.  These bits do not reflect manually entered/exited powerdown or self-refresh (via use of PIN_CKE).

# Register EMC_EMC_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['EMC_STATUS_0'] = {
    'addr'            : 0x2b4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff3f35,
    'write_mask'      : 0x0,
    'EMC_REQ_FIFO_EMPTY' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'NO_OUTSTANDING_TRANSACTIONS' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DRAM_IN_POWERDOWN' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DRAM_IN_SELF_REFRESH' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DRAM_IN_ACTIVE_SELF_REFRESH' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DRAM_IN_DPD' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'MRR_FIFO_SPACE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'MRR_DIVLD' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'CFG_ZQ_ACTIVE' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ZQ_FSM_IDLE' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'TIMING_UPDATE_STALLED' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DSR_FSM_IDLE' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ACPD_FSM_IDLE' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC_REQ_FIFO_EMPTY',
        'NO_OUTSTANDING_TRANSACTIONS',
        'DRAM_IN_POWERDOWN',
        'DRAM_IN_SELF_REFRESH',
        'DRAM_IN_ACTIVE_SELF_REFRESH',
        'DRAM_IN_DPD',
        'MRR_FIFO_SPACE',
        'MRR_DIVLD',
        'CFG_ZQ_ACTIVE',
        'ZQ_FSM_IDLE',
        'TIMING_UPDATE_STALLED',
        'DSR_FSM_IDLE',
        'ACPD_FSM_IDLE',
    ],
} # End of register: EMC_STATUS_0

registers['EMC']['register_list'].append('EMC_STATUS_0')
#  Clock change sequencing: Once the divider is reprogrammed, CAR signals to EMC that a clock change is pending.
#    If enabled, EMC stalls incoming requests, drains outstanding requests, and, if CLKCHANGE_(PD|SR)_ENABLE is enabled,
#    puts DRAM into powerdown (or self-refresh)  before signalling to CAR that it is idle and ready for the change to happen.
#    CAR will then change the divider/pll reprogramming.  Once complete, EMC updates its shadow registers (assuming they may have
#    been reprogrammed for new clock setting), unstalls requests, and resumes operation with new clock setttings.
#
# Some fields of this register is shadowed: see usage note at top of spec file.
# Boot requirements: This register (except for fields DRAMC_PRE_B4_ACT, MRR_BYTESEL_X16, MRR_BYTESEL) should be parameterized in the BCT and written by the BootROM during coldboot.

# Register EMC_CFG_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_2_0'] = {
    'addr'            : 0x2b8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x8017,
    'array'           : False,
    'reset_mask'      : 0xffd1cfff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffd1cfff,
    'write_mask'      : 0xffd1cfff,
    'CLKCHANGE_REQ_ENABLE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CLKCHANGE_PD_ENABLE' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'REF_AFTER_SREF' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ZQ_EXTRA_DELAY' : {
        'lsb'               : 3,
        'msb'               : 5,
        'size'              : 3,
        'field'             : (0x7 << 3),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DIS_STP_OB_CLK_DURING_NON_WR' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EARLY_TRFC_8_CLK' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PIN_CONFIG' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "LPDDR2",
        'enums' : {
            'LPDDR2' : 0,
            'LPDDR2_POP' : 1,
            'RESERVED' : 2,
        },
    },
    'DONT_GEN_EARLY_TRFC_DONE' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DIS_CNTR_WITH_CFG_TIMING_UPDATE' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DONT_GEN_EARLY_MRS_DONE' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'REF_B4_SREF' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CLKCHANGE_ACTIVE_SR' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'COMBINED_INTERRUPT_MODE' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ISSUE_PCHGALL_AFTER_REF' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CHK_PDEX2RD_TO_START_WR' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DSR_STUTTER_ENABLE' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ALLOW_REF_DURING_CC_PRE_EXE' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DRAMC_WD_CHK_POLICY' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DONT_CLR_TIMING_COUNTER_WHEN_CLKCHANGE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CLR_ACT_BANK_INUSE_WHEN_BANK_CLOSE' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'IGNORE_MC_A_BUS' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DRAMC_PRE_B4_ACT' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CLKCHANGE_REQ_ENABLE',
        'CLKCHANGE_PD_ENABLE',
        'REF_AFTER_SREF',
        'ZQ_EXTRA_DELAY',
        'DIS_STP_OB_CLK_DURING_NON_WR',
        'EARLY_TRFC_8_CLK',
        'PIN_CONFIG',
        'DONT_GEN_EARLY_TRFC_DONE',
        'DIS_CNTR_WITH_CFG_TIMING_UPDATE',
        'DONT_GEN_EARLY_MRS_DONE',
        'REF_B4_SREF',
        'CLKCHANGE_ACTIVE_SR',
        'COMBINED_INTERRUPT_MODE',
        'ISSUE_PCHGALL_AFTER_REF',
        'CHK_PDEX2RD_TO_START_WR',
        'DSR_STUTTER_ENABLE',
        'ALLOW_REF_DURING_CC_PRE_EXE',
        'DRAMC_WD_CHK_POLICY',
        'DONT_CLR_TIMING_COUNTER_WHEN_CLKCHANGE',
        'CLR_ACT_BANK_INUSE_WHEN_BANK_CLOSE',
        'IGNORE_MC_A_BUS',
        'DRAMC_PRE_B4_ACT',
    ],
} # End of register: CFG_2_0

registers['EMC']['register_list'].append('CFG_2_0')
# Controls for digital DLL's, which used to measure and maintain 1/4 cycle phase adjustment for RDQS strobes.
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register (except for field CFG_DLL_ALARM_DISABLE and DLL_RESET(trigger) and CFG_DLL_USE_OVERRIDE_UNTIL_LOCK(trigger)) should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register (except for field CFG_DLL_ALARM_DISABLE and DLL_RESET(trigger) and CFG_DLL_USE_OVERRIDE_UNTIL_LOCK(trigger)) should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CFG_DIG_DLL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_DIG_DLL_0'] = {
    'addr'            : 0x2bc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x6c,
    'array'           : False,
    'reset_mask'      : 0x4bffc7ed,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xcfffc7ff,
    'write_mask'      : 0xcfffc7ff,
    'CFG_DLL_EN' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CFG_DLL_STALL_ALL_UNTIL_LOCK' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    'CFG_DLL_OVERRIDE_EN' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CFG_DLL_STALL_ALL_TRAFFIC' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_DLL_STALL_RW_UNTIL_LOCK' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    'CFG_DLL_LOWSPEED' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_DLL_MODE' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "RUN_TIL_LOCK",
        'enums' : {
            'RUN_CONTINUOUS' : 0,
            'RUN_TIL_LOCK' : 1,
            'RUN_PERIODIC' : 2,
            'RUN_PRELOCK' : 3,
        },
    },
    'CFG_DLL_LOCK_LIMIT' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_DLL_QUSE_TESTOUT' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CFG_DLL_TESTEN' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CFG_DLL_OVERRIDE_VAL' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_DLL_UPDATE_AT_NXT_REFRESH' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    'CFG_DLL_ALARM_DISABLE' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DLL_RESET' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    'CFG_DLL_USE_OVERRIDE_UNTIL_LOCK' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CFG_DLL_EN',
        'CFG_DLL_STALL_ALL_UNTIL_LOCK',
        'CFG_DLL_OVERRIDE_EN',
        'CFG_DLL_STALL_ALL_TRAFFIC',
        'CFG_DLL_STALL_RW_UNTIL_LOCK',
        'CFG_DLL_LOWSPEED',
        'CFG_DLL_MODE',
        'CFG_DLL_LOCK_LIMIT',
        'CFG_DLL_QUSE_TESTOUT',
        'CFG_DLL_TESTEN',
        'CFG_DLL_OVERRIDE_VAL',
        'CFG_DLL_UPDATE_AT_NXT_REFRESH',
        'CFG_DLL_ALARM_DISABLE',
        'DLL_RESET',
        'CFG_DLL_USE_OVERRIDE_UNTIL_LOCK',
    ],
} # End of register: CFG_DIG_DLL_0

registers['EMC']['register_list'].append('CFG_DIG_DLL_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_CFG_DIG_DLL_PERIOD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_DIG_DLL_PERIOD_0'] = {
    'addr'            : 0x2c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x8000,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'CFG_DLL_RUN_PERIOD' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x8000,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CFG_DLL_RUN_PERIOD',
    ],
} # End of register: CFG_DIG_DLL_PERIOD_0

registers['EMC']['register_list'].append('CFG_DIG_DLL_PERIOD_0')
#   Digital DLL Status bits directly from DLL

# Register EMC_DIG_DLL_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DIG_DLL_STATUS_0'] = {
    'addr'            : 0x2c4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x3,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7,
    'write_mask'      : 0x0,
    'DLL_LOCK_TIMEOUT' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_LOCK' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DLL_LOCK_TIMEOUT',
        'DLL_ALARM',
        'DLL_LOCK',
    ],
} # End of register: DIG_DLL_STATUS_0

registers['EMC']['register_list'].append('DIG_DLL_STATUS_0')
# Additional DLL config bits used by DRAMc update logic

# Register EMC_CFG_DIG_DLL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_DIG_DLL_1_0'] = {
    'addr'            : 0x2c8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x19,
    'reset_val'       : 0x10f3801,
    'array'           : False,
    'reset_mask'      : 0x10fffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x10fffff,
    'write_mask'      : 0x10fffff,
    'CFG_DLL_UPDATE_IDLE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_DLL_UPDATE_TIMEOUT' : {
        'lsb'               : 1,
        'msb'               : 5,
        'size'              : 5,
        'field'             : (0x1f << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DLL_NUM_STALL_CYCLES' : {
        'lsb'               : 6,
        'msb'               : 11,
        'size'              : 6,
        'field'             : (0x3f << 6),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_DLL_WAIT_BEFORE_UPDATE' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_UPDATE_CNT_LIMIT' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CFG_DLL_UPDATE_WAIT_MC_ACK' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CFG_DLL_UPDATE_IDLE',
        'CFG_DLL_UPDATE_TIMEOUT',
        'DLL_NUM_STALL_CYCLES',
        'CFG_DLL_WAIT_BEFORE_UPDATE',
        'DDLLCAL_UPDATE_CNT_LIMIT',
        'CFG_DLL_UPDATE_WAIT_MC_ACK',
    ],
} # End of register: CFG_DIG_DLL_1_0

registers['EMC']['register_list'].append('CFG_DIG_DLL_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RDV_MASK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RDV_MASK_0'] = {
    'addr'            : 0x2cc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'RDV_MASK' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RDV_MASK',
    ],
} # End of register: RDV_MASK_0

registers['EMC']['register_list'].append('RDV_MASK_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WDV_MASK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WDV_MASK_0'] = {
    'addr'            : 0x2d0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0xf,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WDV_MASK' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WDV_MASK',
    ],
} # End of register: WDV_MASK_0

registers['EMC']['register_list'].append('WDV_MASK_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_RDV_EARLY_MASK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RDV_EARLY_MASK_0'] = {
    'addr'            : 0x2d4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x3f,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'RDV_EARLY_MASK' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RDV_EARLY_MASK',
    ],
} # End of register: RDV_EARLY_MASK_0

registers['EMC']['register_list'].append('RDV_EARLY_MASK_0')

# Register EMC_RDV_EARLY_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RDV_EARLY_0'] = {
    'addr'            : 0x2d8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x8,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'RDV_EARLY' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RDV_EARLY',
    ],
} # End of register: RDV_EARLY_0

registers['EMC']['register_list'].append('RDV_EARLY_0')
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_WDV_CHK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WDV_CHK_0'] = {
    'addr'            : 0x4e0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x6,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WDV_CHK_BASE' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WDV_CHK_BASE',
    ],
} # End of register: WDV_CHK_0

registers['EMC']['register_list'].append('WDV_CHK_0')
#
#
#
#///////////////////////////////////////////////////////////////////////////////////////////////////////////
#  ZQ Calibration Registers                                                                               //
#
#  1. Periodic mode:
#  Allows an ZQ calibration command to be sent periodically to dram.  After ZCAL_INTERVAL, ZCAL_MRW_CMD
#    will be sent to each dram, 1 at a time, followed by ZCAL_WAIT_CNT interval in which no other
#    commands will be allowed to be sent to either dram.  So if ZQ_MRW_DEV_SELECTN == 2'b00, it would send the MRW
#    cmd to dev0, wait ZCAL_WAIT_CNT, send cmd to dev1, wait ZCAL_WAIT_CNT, resume normal operation.  It will
#    then wait ZCAL_INTERVAL microseconds before repeating the procedure.  ZQ calibration command will not be sent
#    to devices that are 1)unpopulated 2)either in or about to enter either self-refresh or dpd.
#  To enable periodic ZQ calibration, program ZCAL_INTERVAL and ZCAL_WAIT_CNT to be non-zero, as well as ZCAL_MRW_CMD
#    to contain the command and device selection, followed by TIMING_CONTROL to latch those three registers.
#    Note that ZCAL_WAIT_CNT will be used instead of MRS_WAIT_CNT for delaying the subsequent dram commands after
#    the ZQ calibration commands, even if a ZQ calibration command is also a MRW comand.
#  Disable this feature by setting ZCAL_INTERVAL.ZCAL_REF_INTERVAL = 0, followed by TIMING_CONTROL to latch it.
#
#  2. Oneshot mode:
#  Allows ZQ calibration command to be sent to dram.
#  To send a one-shot command, keep ZCAL_INTERVAL and ZCAL_WAIT_CNT zero, program ZCAL_MRW_CMD with only
#    one device selected, then program TIMING_CONTROL to latch in those registers, and finally program
#    ZQ_CAL_CMD to 1 to trigger the one-shot command. If more than one devices need to be calibrated,
#    wait the ZQ calibration time and repeat the steps above with the other device selection bit enabled
#    in ZCAL_MRW_CMD.
#  Do not send oneshot ZQ calibration command when periodic mode is enabled.
#
#  ZQ Calibration Registers  -- LPDDR4                                                               //
#
#  1. Periodic mode:
#  Allows an ZQ calibration start command to be sent periodically to dram. LPDDR4 requires a separate MPC command
#  to latch the ZQ calibration results. So, the LPDDR4 sequence looks like this for each DRAM:
#    -after ZCAL_INTERVAL, an MPC ZQCal Start cmd will be sent
#    -after ZCAL_WAIT_CNT interval, an MPC ZQCal Latch cmd will be sent
#    -after ZCAL_LATCH_CNT interval, subsequent ZQ calibration of additional DRAM occurs or other commands can be issued
#  So if ZQ_MRW_DEV_SELECTN == 2'b00, it would send the Start cmd to dev0, wait ZCAL_WAIT_CNT, send Latch cmd to dev0,
#  wait ZCAL_LATCH_CNT, send Start cmd to dev1, wait ZCAL_WAIT_CNT, send Latch cmd to dev1, wait ZCAL_LATCH_CNT, resume
#  normal operation.  It will then wait ZCAL_INTERVAL microseconds before repeating the procedure. ZQ calibration
#  command will not be sent to devices that are 1)unpopulated 2)either in or about to enter either self-refresh or dpd.
#
#  To enable periodic ZQ calibration
#    - enable FBIO_CFG7.ZQCAL_MPC_ENABLE and FBIO_CFG7.ZQCAL_LATCH_ENABLE
#    - program ZCAL_INTERVAL, ZCAL_WAIT_CNT, and ZCAL_LATCH_CNT to be non-zero
#    - program ZCAL_MRW_CMD.ZQ_MRW_OP=ZQCal_Start and ZCAL_MRW_CMD.ZQ_MRW_MA=ZQCal_Latch
#    - program ZQ_MRW_DEV_SELECTN to contain the device selection
#    - write to TIMING_CONTROL to latch the three registers
#
#  To disble periodic ZQ calibration, program ZCAL_INTERVAL.ZCAL_REF_INTERVAL = 0, followed by TIMING_CONTROL to latch it.
#
#  2. Oneshot mode:
#  Allows ZQ calibration command to be sent to dram.
#  To send a one-shot command, keep ZCAL_INTERVAL and ZCAL_WAIT_CNT zero, program ZCAL_MRW_CMD with only
#    one device selected, then program TIMING_CONTROL to latch in those registers, and finally program
#    ZQ_CAL_CMD to 1 to trigger the one-shot command. Wait the ZQ calibration time and program ZQ_LATCH_CMD to 1.
#    If more than one devices need to be calibrated, wait the ZQ latch time and repeat the steps above with the
#    other device selection bit enabled in ZCAL_MRW_CMD. Only one of ZQ_CAL_CMD and ZQ_LATCH_CMD should be 1 for
#    any ZQ_CAL write.
#  Do not send oneshot ZQ calibration command when periodic mode is enabled.
#
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_ZCAL_INTERVAL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ZCAL_INTERVAL_0'] = {
    'addr'            : 0x2e0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffff,
    'write_mask'      : 0xffffff,
    'ZCAL_INTERVAL_HI' : {
        'lsb'               : 10,
        'msb'               : 23,
        'size'              : 14,
        'field'             : (0x3fff << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ZCAL_INTERVAL_LO' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ZCAL_INTERVAL_HI',
        'ZCAL_INTERVAL_LO',
    ],
} # End of register: ZCAL_INTERVAL_0

registers['EMC']['register_list'].append('ZCAL_INTERVAL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_ZCAL_WAIT_CNT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ZCAL_WAIT_CNT_0'] = {
    'addr'            : 0x2e4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x807f0fff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x807f0fff,
    'write_mask'      : 0x807f0fff,
    'ZCAL_WAIT_CNT' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ZCAL_LATCH_CNT' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ZCAL_RESISTOR_SHARED' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ZCAL_WAIT_CNT',
        'ZCAL_LATCH_CNT',
        'ZCAL_RESISTOR_SHARED',
    ],
} # End of register: ZCAL_WAIT_CNT_0

registers['EMC']['register_list'].append('ZCAL_WAIT_CNT_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_ZCAL_MRW_CMD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ZCAL_MRW_CMD_0'] = {
    'addr'            : 0x2e8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xc0000000,
    'array'           : False,
    'reset_mask'      : 0xc8ff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xc8ff00ff,
    'write_mask'      : 0xc8ff00ff,
    'ZQ_MRW_OP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ZQ_MRW_MA' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ZQ_MRW_SUBP_STAGGER_MODE' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ZQ_MRW_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ZQ_MRW_OP',
        'ZQ_MRW_MA',
        'ZQ_MRW_SUBP_STAGGER_MODE',
        'ZQ_MRW_DEV_SELECTN',
    ],
} # End of register: ZCAL_MRW_CMD_0

registers['EMC']['register_list'].append('ZCAL_MRW_CMD_0')
# This register issues a ZQ calibration MRS command

# Register EMC_ZQ_CAL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ZQ_CAL_0'] = {
    'addr'            : 0x2ec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x10,
    'array'           : False,
    'reset_mask'      : 0xcc000013,
    'sw_default_val'  : 0x10,
    'sw_default_mask' : 0xcc000013,
    'read_mask'       : 0xcc000013,
    'write_mask'      : 0xcc000013,
    'ZQ_CAL_CMD' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ZQ_LATCH_CMD' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ZQ_CAL_LENGTH' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "LONG",
        'enums' : {
            'SHORT' : 0,
            'LONG' : 1,
        },
    },
    'ZQ_CAL_SUBP_SELECTN' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ZQ_CAL_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ZQ_CAL_CMD',
        'ZQ_LATCH_CMD',
        'ZQ_CAL_LENGTH',
        'ZQ_CAL_SUBP_SELECTN',
        'ZQ_CAL_DEV_SELECTN',
    ],
} # End of register: ZQ_CAL_0

registers['EMC']['register_list'].append('ZQ_CAL_0')
# This is a scratch register for general use.

# Register EMC_SCRATCH0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SCRATCH0_0'] = {
    'addr'            : 0x324,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xffffffff,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'SCRATCH' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SCRATCH',
    ],
} # End of register: SCRATCH0_0

registers['EMC']['register_list'].append('SCRATCH0_0')
#///////////////////////////////////////////////////////////////////////////////////////////////////////////
#  Scheme to change controller timing parameters + SDRAM mode timing atomically.
#       (A)     Program the EMC controller timing registers (shadowed).
#       (B)     Pre-program SDRAM mode registers.
#               (a)     write 1 to STALL_THEN_EXE_BEFORE_CLKCHANGE field which will prevent further cfg execution
#                      until clock change request has been detected.
#          Note: after this step, no register read should happen on EMC before the clock change (C)
#                happens, otherwise system will hang. Disable EMC interrupt before this step if the
#                interrupt handler reads EMC registers.
#               (b)     write to whatever EMC registers you want to be execute after clock change request has been
#                       detected but before the actual clock change happens.  For example, if you want to disable
#                       DLL in DDR3 mode, you can,
#                               (1)  Issue a write to SDRAM's MR1 register via EMC MRS register to disable DLL.
#                               (2)  Issue a Self-refresh entry via EMC SELF_REF register.
#                       Note:  If there's no need to execute any register access before clock change, simply skip
#                              step (b); step (a) is still require.
#               (c)     write 1 to STALL_THEN_EXE_AFTER_CLKCHANGE field which will prevent further cfg execution
#                       until after the actual clock change has happened.
#               (d)     write to whatever EMC registers you want to be execute after clock change happened.  Using
#                       the same example as (b), you will,
#                               (1)  Issue a Self-refresh exit via EMC SELF_REF register.
#                               (2)  Issue writes to SDRAM's MRx register(s) to change read/write latencies and/or enable DLL
#                               (3)  Issue burst refreshs via EMC REF register.
#                       Note:  If there's no need to execute any register access after clock change, simply skip
#                              step (d); step (c) is still require.
#               (e)     write 1 to UNSTALL_RW_AFTER_CLKCHANGE field which will restore normal memory read/write
#                       accesses.
#       (C)     Program CAR to change either clock source and/or clock divider.
#
#///////////////////////////////////////////////////////////////////////////////////////////////////////////
#  Note: In both sequences above, DYN_SELF_REF must be disabled off before the first step,
#        then can be restored after the last step.
#  Note: The interval between two clock change sequences are recommended to be at least 20us apart
#///////////////////////////////////////////////////////////////////////////////////////////////////////////
# Write to this register will stall the register read/write path until a clock change request is detected.  Once detected, whatever register
# acceess follows this register write will be executed until a STALL_THEN_EXE_AFTER_CKLCHANGE is encountered.  At that point, EMC timing
# registers will be updated and clock change request will be acknowledge.

# Register EMC_STALL_THEN_EXE_BEFORE_CLKCHANGE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STALL_THEN_EXE_BEFORE_CLKCHANGE_0'] = {
    'addr'            : 0x3c8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x1,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'STALL_THEN_EXE_BEFORE_CLKCHANGE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'STALL_THEN_EXE_BEFORE_CLKCHANGE',
    ],
} # End of register: STALL_THEN_EXE_BEFORE_CLKCHANGE_0

registers['EMC']['register_list'].append('STALL_THEN_EXE_BEFORE_CLKCHANGE_0')
# Write to this register will stall the register read/write path until after EMC timing registers are updated and that clock change has
# been completed.  Once that happen, whatever register acceess follows this register write will be executed until UNSTALL_RW_AFTER_CLKCHANGE
# is encountered.  At that point, normal memory read/write will be allow to resume.

# Register EMC_STALL_THEN_EXE_AFTER_CLKCHANGE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['STALL_THEN_EXE_AFTER_CLKCHANGE_0'] = {
    'addr'            : 0x3cc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x1,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'STALL_THEN_EXE_AFTER_CLKCHANGE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'STALL_THEN_EXE_AFTER_CLKCHANGE',
    ],
} # End of register: STALL_THEN_EXE_AFTER_CLKCHANGE_0

registers['EMC']['register_list'].append('STALL_THEN_EXE_AFTER_CLKCHANGE_0')
# Writing to this register will un-stall memory read/write after clock change, use in conjunction with STALL_THEN_EXE_AFTER_CLKCHANGE.

# Register EMC_UNSTALL_RW_AFTER_CLKCHANGE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['UNSTALL_RW_AFTER_CLKCHANGE_0'] = {
    'addr'            : 0x3d0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x1,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'UNSTALL_RW_AFTER_CLKCHANGE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'UNSTALL_RW_AFTER_CLKCHANGE',
    ],
} # End of register: UNSTALL_RW_AFTER_CLKCHANGE_0

registers['EMC']['register_list'].append('UNSTALL_RW_AFTER_CLKCHANGE_0')
#///////////////////////////////////

# Register EMC_FDPD_CTRL_CMD_NO_RAMP_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FDPD_CTRL_CMD_NO_RAMP_0'] = {
    'addr'            : 0x4d8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x1,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'CMD_DPD_NO_RAMP_ENABLE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DPD_NO_RAMP_ENABLE',
    ],
} # End of register: FDPD_CTRL_CMD_NO_RAMP_0

registers['EMC']['register_list'].append('FDPD_CTRL_CMD_NO_RAMP_0')
# See bug 1341809 when taking idle power measurement with FDPD feature.

# Register EMC_SEL_DPD_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SEL_DPD_CTRL_0'] = {
    'addr'            : 0x3d8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x11,
    'reset_val'       : 0x40000,
    'array'           : False,
    'reset_mask'      : 0x7013c,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7013c,
    'write_mask'      : 0x7013c,
    'CLK_SEL_DPD_EN' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CA_SEL_DPD_EN' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RESET_SEL_DPD_EN' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ODT_SEL_DPD_EN' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'DATA_SEL_DPD_EN' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'SEL_DPD_DLY' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CLK_SEL_DPD_EN',
        'CA_SEL_DPD_EN',
        'RESET_SEL_DPD_EN',
        'ODT_SEL_DPD_EN',
        'DATA_SEL_DPD_EN',
        'SEL_DPD_DLY',
    ],
} # End of register: SEL_DPD_CTRL_0

registers['EMC']['register_list'].append('SEL_DPD_CTRL_0')

# Register EMC_FDPD_CTRL_DQ_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FDPD_CTRL_DQ_0'] = {
    'addr'            : 0x310,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x8020221f,
    'array'           : False,
    'reset_mask'      : 0xdff1ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xdff1ffff,
    'write_mask'      : 0xdff1ffff,
    'DQ_DPD_ENTRY_DELAY' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_PHASE_HOLD_MIN' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_PHASE_RAMP_OUT_TIME' : {
        'lsb'               : 12,
        'msb'               : 16,
        'size'              : 5,
        'field'             : (0x1f << 12),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_PHASE_RAMP_IN_TIME' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_DPD_EXIT_DELAY' : {
        'lsb'               : 24,
        'msb'               : 28,
        'size'              : 5,
        'field'             : (0x1f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_PHASE_MIN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_DPD_ENTRY_DELAY',
        'DQ_PHASE_HOLD_MIN',
        'DQ_PHASE_RAMP_OUT_TIME',
        'DQ_PHASE_RAMP_IN_TIME',
        'DQ_DPD_EXIT_DELAY',
        'DQ_PHASE_MIN',
    ],
} # End of register: FDPD_CTRL_DQ_0

registers['EMC']['register_list'].append('FDPD_CTRL_DQ_0')

# Register EMC_FDPD_CTRL_CMD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FDPD_CTRL_CMD_0'] = {
    'addr'            : 0x314,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x220f40f,
    'array'           : False,
    'reset_mask'      : 0xfff1ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff1ffff,
    'write_mask'      : 0xfff1ffff,
    'CMD_DPD_ENTRY_DELAY' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_PHASE_HOLD_MIN' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_PHASE_RAMP_OUT_TIME' : {
        'lsb'               : 12,
        'msb'               : 16,
        'size'              : 5,
        'field'             : (0x1f << 12),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_PHASE_RAMP_IN_TIME' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DPD_EXIT_DELAY' : {
        'lsb'               : 24,
        'msb'               : 28,
        'size'              : 5,
        'field'             : (0x1f << 24),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DPD_RAMP_ENABLE' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_PHASE_MIN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DPD_ENTRY_DELAY',
        'CMD_PHASE_HOLD_MIN',
        'CMD_PHASE_RAMP_OUT_TIME',
        'CMD_PHASE_RAMP_IN_TIME',
        'CMD_DPD_EXIT_DELAY',
        'CMD_DPD_RAMP_ENABLE',
        'CMD_PHASE_MIN',
    ],
} # End of register: FDPD_CTRL_CMD_0

registers['EMC']['register_list'].append('FDPD_CTRL_CMD_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PRE_REFRESH_REQ_CNT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PRE_REFRESH_REQ_CNT_0'] = {
    'addr'            : 0x3dc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'PRE_REF_REQ_CNT' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PRE_REF_REQ_CNT',
    ],
} # End of register: PRE_REFRESH_REQ_CNT_0

registers['EMC']['register_list'].append('PRE_REFRESH_REQ_CNT_0')
# This register is shadowed: see usage note at top of spec file - EXCEPT for REFPB_HALT

# Register EMC_REFCTRL2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['REFCTRL2_0'] = {
    'addr'            : 0x580,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x8777f001,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x8777f001,
    'write_mask'      : 0x8777f001,
    'REFRESH_PER_DEVICE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'REFAB_OVF_THRESHOLD' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'REFPB_PANIC_LWM' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'REFPB_PANIC_HWM' : {
        'lsb'               : 20,
        'msb'               : 22,
        'size'              : 3,
        'field'             : (0x7 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'REFPB_PD_THRESHOLD' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'REFPB_VALID' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'REFRESH_PER_DEVICE',
        'REFAB_OVF_THRESHOLD',
        'REFPB_PANIC_LWM',
        'REFPB_PANIC_HWM',
        'REFPB_PD_THRESHOLD',
        'REFPB_VALID',
    ],
} # End of register: REFCTRL2_0

registers['EMC']['register_list'].append('REFCTRL2_0')

# Register EMC_FBIO_CFG7_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FBIO_CFG7_0'] = {
    'addr'            : 0x584,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x8002a,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DRAM_EMCCLK_2TO1' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONEX",
        'enums' : {
            'ONEX' : 0,
            'TWOX' : 1,
        },
    },
    'CH0_ENABLE' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'CH1_ENABLE' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'QUSE_CCDP1_EXTEND' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'LPDDR4_CMD_MAP' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'MASKED_WR' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'WR_DBI' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RD_DBI' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'MRR_DBI' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CS_POLARITY' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ACTIVE_LOW",
        'enums' : {
            'ACTIVE_LOW' : 0,
            'ACTIVE_HIGH' : 1,
        },
    },
    'QPOP_RD_PREAMBLE_TOGGLE' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ZQCAL_MPC_ENABLE' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ZQCAL_LATCH_ENABLE' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'SUBP_ADDR_MODE' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "X32",
        'enums' : {
            'X32' : 0,
            'X16' : 1,
        },
    },
    'DISABLE_CCDP1_RD_SPACING' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DISABLE_CCDP1_WR_SPACING' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'FORCE_CMD_PHASE_EQ0' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'SEND_RD1_TO_BOTH_RANKS' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'SEND_WR1_TO_BOTH_RANKS' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'FORCED_REFRESH_REQ_STALL' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'TEMP_REG' : {
        'lsb'               : 20,
        'msb'               : 31,
        'size'              : 12,
        'field'             : (0xfff << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DRAM_EMCCLK_2TO1',
        'CH0_ENABLE',
        'CH1_ENABLE',
        'QUSE_CCDP1_EXTEND',
        'LPDDR4_CMD_MAP',
        'MASKED_WR',
        'WR_DBI',
        'RD_DBI',
        'MRR_DBI',
        'CS_POLARITY',
        'QPOP_RD_PREAMBLE_TOGGLE',
        'ZQCAL_MPC_ENABLE',
        'ZQCAL_LATCH_ENABLE',
        'SUBP_ADDR_MODE',
        'DISABLE_CCDP1_RD_SPACING',
        'DISABLE_CCDP1_WR_SPACING',
        'FORCE_CMD_PHASE_EQ0',
        'SEND_RD1_TO_BOTH_RANKS',
        'SEND_WR1_TO_BOTH_RANKS',
        'FORCED_REFRESH_REQ_STALL',
        'TEMP_REG',
    ],
} # End of register: FBIO_CFG7_0

registers['EMC']['register_list'].append('FBIO_CFG7_0')

# Register EMC_FBIO_CFG9_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FBIO_CFG9_0'] = {
    'addr'            : 0x710,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x11f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x100,
    'read_mask'       : 0x117,
    'write_mask'      : 0x11f,
    'ECC_CHECK_DISABLE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "OFF",
        'enums' : {
            'OFF' : 0,
            'ON' : 1,
        },
    },
    'ECC_ENCR_DISABLE' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "OFF",
        'enums' : {
            'OFF' : 0,
            'ON' : 1,
        },
    },
    'ECC_DYNAMIC_BYPASS_DISABLE' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "OFF",
        'enums' : {
            'OFF' : 0,
            'ON' : 1,
        },
    },
    'ECC_ENCR_CFG_LOCK' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
            'init_enum'  : "OFF",
        'enums' : {
            'OFF' : 0,
            'ON' : 1,
        },
    },
    'ENCR_TWEAK_CHECK_ENABLE' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "OFF",
        'enums' : {
            'OFF' : 0,
            'ON' : 1,
        },
    },
    'USE_SELF_REF_STATE' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ECC_CHECK_DISABLE',
        'ECC_ENCR_DISABLE',
        'ECC_DYNAMIC_BYPASS_DISABLE',
        'ECC_ENCR_CFG_LOCK',
        'ENCR_TWEAK_CHECK_ENABLE',
        'USE_SELF_REF_STATE',
    ],
} # End of register: FBIO_CFG9_0

registers['EMC']['register_list'].append('FBIO_CFG9_0')
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# EMC implements a circular buffer for storing ECC errors. This ECC error buffer has two operating modes, RING and
# WRITESTOP. In RING mode, up to the last N errors are stored where N = min(ERR_BUFFER_DEPTH, ERR_BUFFER_LIMIT).
# If more than N errors occur before s/w reads buffer, only the last N errors are saved. In WRITESTOP mode, errors
# are recorded until the buffer fills. Any subsequent errors are lost. So, the first N errors are retained.
#
# The error buffer is wider than 32 bits and has multiple entries. Writing a one to ERR_BUFFER_LOAD reads an entry
# from error buffer, populates the ECC_ERROR_* registers, and increments ERR_BUFFER_RD_PTR.
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# Register EMC_ECC_CONTROL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ECC_CONTROL_0'] = {
    'addr'            : 0xac0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0xff00,
    'array'           : False,
    'reset_mask'      : 0xff07,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff07,
    'write_mask'      : 0xff07,
    'ERR_BUFFER_MODE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "RING",
        'enums' : {
            'RING' : 0,
            'WRITESTOP' : 1,
        },
    },
    'ERR_BUFFER_RESET' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR_BUFFER_LOAD' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwt',
        'enums' : {
        },
    },
    'ERR_BUFFER_LIMIT' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0xff,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR_BUFFER_MODE',
        'ERR_BUFFER_RESET',
        'ERR_BUFFER_LOAD',
        'ERR_BUFFER_LIMIT',
    ],
} # End of register: ECC_CONTROL_0

registers['EMC']['register_list'].append('ECC_CONTROL_0')

# Register EMC_ECC_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ECC_STATUS_0'] = {
    'addr'            : 0xac4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'ERR_BUFFER_RD_PTR' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ERR_BUFFER_WR_PTR' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ERR_BUFFER_CNT' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ERR_BUFFER_DEPTH' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR_BUFFER_RD_PTR',
        'ERR_BUFFER_WR_PTR',
        'ERR_BUFFER_CNT',
        'ERR_BUFFER_DEPTH',
    ],
} # End of register: ECC_STATUS_0

registers['EMC']['register_list'].append('ECC_STATUS_0')

# Register EMC_ECC_ERR_SP0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ECC_ERR_SP0_0'] = {
    'addr'            : 0xac8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffc3ffcb,
    'write_mask'      : 0x0,
    'ECC_DERR_PAR_SP0' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
            'NONE' : 0,
            'CORRECTABLE' : 1,
            'UNCORRECTABLE' : 2,
        },
    },
    'ECC_ERR_POISON_SP0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_DERR_SYNDROME_SP0' : {
        'lsb'               : 6,
        'msb'               : 15,
        'size'              : 10,
        'field'             : (0x3ff << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_EERR_PAR_SP0' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
            'NONE' : 0,
            'CORRECTABLE' : 1,
            'UNCORRECTABLE' : 2,
        },
    },
    'ECC_EERR_SYNDROME_SP0' : {
        'lsb'               : 22,
        'msb'               : 31,
        'size'              : 10,
        'field'             : (0x3ff << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ECC_DERR_PAR_SP0',
        'ECC_ERR_POISON_SP0',
        'ECC_DERR_SYNDROME_SP0',
        'ECC_EERR_PAR_SP0',
        'ECC_EERR_SYNDROME_SP0',
    ],
} # End of register: ECC_ERR_SP0_0

registers['EMC']['register_list'].append('ECC_ERR_SP0_0')

# Register EMC_ECC_ERR_SP1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ECC_ERR_SP1_0'] = {
    'addr'            : 0xacc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffc3ffcb,
    'write_mask'      : 0x0,
    'ECC_DERR_PAR_SP1' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
            'NONE' : 0,
            'CORRECTABLE' : 1,
            'UNCORRECTABLE' : 2,
        },
    },
    'ECC_ERR_POISON_SP1' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_DERR_SYNDROME_SP1' : {
        'lsb'               : 6,
        'msb'               : 15,
        'size'              : 10,
        'field'             : (0x3ff << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_EERR_PAR_SP1' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
            'NONE' : 0,
            'CORRECTABLE' : 1,
            'UNCORRECTABLE' : 2,
        },
    },
    'ECC_EERR_SYNDROME_SP1' : {
        'lsb'               : 22,
        'msb'               : 31,
        'size'              : 10,
        'field'             : (0x3ff << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ECC_DERR_PAR_SP1',
        'ECC_ERR_POISON_SP1',
        'ECC_DERR_SYNDROME_SP1',
        'ECC_EERR_PAR_SP1',
        'ECC_EERR_SYNDROME_SP1',
    ],
} # End of register: ECC_ERR_SP1_0

registers['EMC']['register_list'].append('ECC_ERR_SP1_0')

# Register EMC_ECC_ERR_ADDR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ECC_ERR_ADDR_0'] = {
    'addr'            : 0xad0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x71ffff3f,
    'write_mask'      : 0x0,
    'ECC_ERR_GOB' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_ROW' : {
        'lsb'               : 8,
        'msb'               : 24,
        'size'              : 17,
        'field'             : (0x1ffff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_BANK' : {
        'lsb'               : 28,
        'msb'               : 30,
        'size'              : 3,
        'field'             : (0x7 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ECC_ERR_GOB',
        'ECC_ERR_ROW',
        'ECC_ERR_BANK',
    ],
} # End of register: ECC_ERR_ADDR_0

registers['EMC']['register_list'].append('ECC_ERR_ADDR_0')

# Register EMC_ECC_ERR_REQ_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ECC_ERR_REQ_0'] = {
    'addr'            : 0xad4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff3f77f0,
    'write_mask'      : 0x0,
    'ECC_ERR_EMC_ID' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_COL_SP0' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_COL_SP1' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_DEVICE' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_SIZE' : {
        'lsb'               : 17,
        'msb'               : 18,
        'size'              : 2,
        'field'             : (0x3 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
            'R64B' : 0,
            'R32B' : 1,
            'R16B' : 2,
        },
    },
    'ECC_ERR_SWAP' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_SEQ' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'ECC_ERR_CGID' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ECC_ERR_EMC_ID',
        'ECC_ERR_COL_SP0',
        'ECC_ERR_COL_SP1',
        'ECC_ERR_DEVICE',
        'ECC_ERR_SIZE',
        'ECC_ERR_SWAP',
        'ECC_ERR_SEQ',
        'ECC_ERR_CGID',
    ],
} # End of register: ECC_ERR_REQ_0

registers['EMC']['register_list'].append('ECC_ERR_REQ_0')
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#

# Register EMC_EMC_ENCR_KEY_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['EMC_ENCR_KEY_STATUS_0'] = {
    'addr'            : 0xadc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff000f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xff000f0f,
    'read_mask'       : 0xff000f0f,
    'write_mask'      : 0xf000000,
    'KEY_ACTIVE' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'KEY_DISTRIB_ERR' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'KEY_STATE_CLEAR' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    'KEY_INIT_DONE' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'KEY_ACTIVE',
        'KEY_DISTRIB_ERR',
        'KEY_STATE_CLEAR',
        'KEY_INIT_DONE',
    ],
} # End of register: EMC_ENCR_KEY_STATUS_0

registers['EMC']['register_list'].append('EMC_ENCR_KEY_STATUS_0')
#
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
# DQ/DQS BRLSHFTS
# Rank 0 Per byte OB barrleshift setting . This is to be used mutually exclusive  with per bit EMC_DQ_BRLSHFT* (one of them should be 0)

# Register EMC_DATA_BRLSHFT_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DATA_BRLSHFT_0_0'] = {
    'addr'            : 0x588,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'RANK0_BYTE0_DATA_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE1_DATA_BRLSHFT' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE2_DATA_BRLSHFT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE3_DATA_BRLSHFT' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK0_BYTE0_DATA_BRLSHFT',
        'RANK0_BYTE1_DATA_BRLSHFT',
        'RANK0_BYTE2_DATA_BRLSHFT',
        'RANK0_BYTE3_DATA_BRLSHFT',
    ],
} # End of register: DATA_BRLSHFT_0_0

registers['EMC']['register_list'].append('DATA_BRLSHFT_0_0')
# Rank1 Per byte OB barrleshift setting . This is to be used mutually exclusive  with per bit EMC_DQ_BRLSHFT* (one of them should be 0)

# Register EMC_DATA_BRLSHFT_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DATA_BRLSHFT_1_0'] = {
    'addr'            : 0x58c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'RANK1_BYTE0_DATA_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE1_DATA_BRLSHFT' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE2_DATA_BRLSHFT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE3_DATA_BRLSHFT' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK1_BYTE0_DATA_BRLSHFT',
        'RANK1_BYTE1_DATA_BRLSHFT',
        'RANK1_BYTE2_DATA_BRLSHFT',
        'RANK1_BYTE3_DATA_BRLSHFT',
    ],
} # End of register: DATA_BRLSHFT_1_0

registers['EMC']['register_list'].append('DATA_BRLSHFT_1_0')
# Rank 0 Per byte OB barrleshift setting

# Register EMC_DQS_BRLSHFT_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQS_BRLSHFT_0_0'] = {
    'addr'            : 0x594,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'RANK0_BYTE0_DQS_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE1_DQS_BRLSHFT' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE2_DQS_BRLSHFT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE3_DQS_BRLSHFT' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK0_BYTE0_DQS_BRLSHFT',
        'RANK0_BYTE1_DQS_BRLSHFT',
        'RANK0_BYTE2_DQS_BRLSHFT',
        'RANK0_BYTE3_DQS_BRLSHFT',
    ],
} # End of register: DQS_BRLSHFT_0_0

registers['EMC']['register_list'].append('DQS_BRLSHFT_0_0')
# Rank1 Per byte OB barrleshift setting

# Register EMC_DQS_BRLSHFT_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQS_BRLSHFT_1_0'] = {
    'addr'            : 0x598,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'RANK1_BYTE0_DQS_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE1_DQS_BRLSHFT' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE2_DQS_BRLSHFT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE3_DQS_BRLSHFT' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK1_BYTE0_DQS_BRLSHFT',
        'RANK1_BYTE1_DQS_BRLSHFT',
        'RANK1_BYTE2_DQS_BRLSHFT',
        'RANK1_BYTE3_DQS_BRLSHFT',
    ],
} # End of register: DQS_BRLSHFT_1_0

registers['EMC']['register_list'].append('DQS_BRLSHFT_1_0')
# CMD/ADR BRLSHFTS
# Notes: Barrelshift to CMD/ADR mapping
# is specified in emc_cmd_mapping.vh
# In LP4 mode SUBP0 address bits will be
# on one brick and SUBP1 address on another
# So different 1T settings will be needed
# for different long trimmers
# In legacy (LP3) modes, same 1T setting
# will need to be programmed for SUBP0 and
# SUBP1 because addresses belonging to
# the same subpartition can end up on different
# bricks with different long trimmer settings
# So to sum up, in LP4 - Training will set SUBP0 1T
# and SUBP1 1T, only SW will set 2T for CKE/RST
# In Legacy modes- SW can only set both SUBP0 1T and
# SUBP1 1T to the same value. Also,
# SW can set SUBP0 2T and SUBP1 2T to
# the same value.
# 1T LP4 ADR barrleshift setting on Ch0
# These will be set be training engine
# in LP4 mode. In Legacy modes these
# will be set by SW (if needed) . This is to be used mutually exclusive  with per bit EMC_DQ_BRLSHFT*CMD (one of them should be 0)

# Register EMC_CMD_BRLSHFT_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_BRLSHFT_0_0'] = {
    'addr'            : 0x59c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'CH0_SUBP0_1T_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CH0_SUBP1_1T_BRLSHFT' : {
        'lsb'               : 3,
        'msb'               : 5,
        'size'              : 3,
        'field'             : (0x7 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH0_SUBP0_1T_BRLSHFT',
        'CH0_SUBP1_1T_BRLSHFT',
    ],
} # End of register: CMD_BRLSHFT_0_0

registers['EMC']['register_list'].append('CMD_BRLSHFT_0_0')
# 1T LP4 ADR barrleshift setting on Ch1
# These will be set be training engine
# in LP4 mode. In Legacy modes these
# will be set by SW (if needed) . This is to be used mutually exclusive  with per bit EMC_DQ_BRLSHFT*CMD (one of them should be 0)

# Register EMC_CMD_BRLSHFT_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_BRLSHFT_1_0'] = {
    'addr'            : 0x5a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'CH1_SUBP0_1T_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CH1_SUBP1_1T_BRLSHFT' : {
        'lsb'               : 3,
        'msb'               : 5,
        'size'              : 3,
        'field'             : (0x7 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH1_SUBP0_1T_BRLSHFT',
        'CH1_SUBP1_1T_BRLSHFT',
    ],
} # End of register: CMD_BRLSHFT_1_0

registers['EMC']['register_list'].append('CMD_BRLSHFT_1_0')
# 2T signal barrleshift setting on Ch1
# These will be not be training engine
# in LP4 mode and will be applied only
# to CKE and RST. In legacy modes these
# will be applied to non-ADR signals like
# RAS,CAS,WE

# Register EMC_CMD_BRLSHFT_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_BRLSHFT_2_0'] = {
    'addr'            : 0x5a4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'CH0_SUBP0_2T_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CH0_SUBP1_2T_BRLSHFT' : {
        'lsb'               : 3,
        'msb'               : 5,
        'size'              : 3,
        'field'             : (0x7 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH0_SUBP0_2T_BRLSHFT',
        'CH0_SUBP1_2T_BRLSHFT',
    ],
} # End of register: CMD_BRLSHFT_2_0

registers['EMC']['register_list'].append('CMD_BRLSHFT_2_0')
# 2T signal barrleshift setting on Ch1
# These will be not be training engine
# in LP4 mode and will be applied only
# to CKE and RST. In legacy modes these
# will be applied to non-ADR signals like
# RAS,CAS,WE

# Register EMC_CMD_BRLSHFT_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_BRLSHFT_3_0'] = {
    'addr'            : 0x5a8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'CH1_SUBP0_2T_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CH1_SUBP1_2T_BRLSHFT' : {
        'lsb'               : 3,
        'msb'               : 5,
        'size'              : 3,
        'field'             : (0x7 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH1_SUBP0_2T_BRLSHFT',
        'CH1_SUBP1_2T_BRLSHFT',
    ],
} # End of register: CMD_BRLSHFT_3_0

registers['EMC']['register_list'].append('CMD_BRLSHFT_3_0')
#  QUSE BRLSHFTS
# Per byte OB barrleshift setting

# Register EMC_QUSE_BRLSHFT_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['QUSE_BRLSHFT_0_0'] = {
    'addr'            : 0x5ac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfffff,
    'write_mask'      : 0xfffff,
    'RANK0_BYTE0_QUSE_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE1_QUSE_BRLSHFT' : {
        'lsb'               : 5,
        'msb'               : 9,
        'size'              : 5,
        'field'             : (0x1f << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE2_QUSE_BRLSHFT' : {
        'lsb'               : 10,
        'msb'               : 14,
        'size'              : 5,
        'field'             : (0x1f << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK0_BYTE3_QUSE_BRLSHFT' : {
        'lsb'               : 15,
        'msb'               : 19,
        'size'              : 5,
        'field'             : (0x1f << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK0_BYTE0_QUSE_BRLSHFT',
        'RANK0_BYTE1_QUSE_BRLSHFT',
        'RANK0_BYTE2_QUSE_BRLSHFT',
        'RANK0_BYTE3_QUSE_BRLSHFT',
    ],
} # End of register: QUSE_BRLSHFT_0_0

registers['EMC']['register_list'].append('QUSE_BRLSHFT_0_0')
# Per byte OB barrleshift setting
#reg   QUSE_BRLSHFT_1                     EMC_WINCR
#;
# Per byte OB barrleshift setting

# Register EMC_QUSE_BRLSHFT_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['QUSE_BRLSHFT_2_0'] = {
    'addr'            : 0x5bc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfffff,
    'write_mask'      : 0xfffff,
    'RANK1_BYTE0_QUSE_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE1_QUSE_BRLSHFT' : {
        'lsb'               : 5,
        'msb'               : 9,
        'size'              : 5,
        'field'             : (0x1f << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE2_QUSE_BRLSHFT' : {
        'lsb'               : 10,
        'msb'               : 14,
        'size'              : 5,
        'field'             : (0x1f << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RANK1_BYTE3_QUSE_BRLSHFT' : {
        'lsb'               : 15,
        'msb'               : 19,
        'size'              : 5,
        'field'             : (0x1f << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK1_BYTE0_QUSE_BRLSHFT',
        'RANK1_BYTE1_QUSE_BRLSHFT',
        'RANK1_BYTE2_QUSE_BRLSHFT',
        'RANK1_BYTE3_QUSE_BRLSHFT',
    ],
} # End of register: QUSE_BRLSHFT_2_0

registers['EMC']['register_list'].append('QUSE_BRLSHFT_2_0')
# Per byte OB barrleshift setting
#reg   QUSE_BRLSHFT_3                     EMC_WINCR
#;
# The QRST,QUSE,RDV fields specify the delays from read to internal
# timing signals. These fields should be set as follows:
# The QRST,QUSE,RDV fields specify the delays from read to internal
# timing signals. These fields should be set as follows:
#    QUSE   = CAS_LATENCY - 1 non-mobile SDRAM

# Register EMC_FBIO_CFG8_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['FBIO_CFG8_0'] = {
    'addr'            : 0x5c8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x3f0000,
    'array'           : False,
    'reset_mask'      : 0x3f8000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f8000,
    'write_mask'      : 0x3f8000,
    'RANK_SWIZZLE' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK0' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK2' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK4' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK5' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK_SWIZZLE',
        'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK0',
        'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK1',
        'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK2',
        'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK3',
        'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK4',
        'EMC2PMACRO_CFG_PIPE_DATA_MODE_BRICK5',
    ],
} # End of register: FBIO_CFG8_0

registers['EMC']['register_list'].append('FBIO_CFG8_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CMD_MAPPING_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_MAPPING_CMD0_0_0'] = {
    'addr'            : 0x380,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x1010101,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'CMD0_DQ0_MAP' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD0_DQ1_MAP' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD0_DQ2_MAP' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD0_DQ3_MAP' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD0_DQ0_MAP',
        'CMD0_DQ1_MAP',
        'CMD0_DQ2_MAP',
        'CMD0_DQ3_MAP',
    ],
} # End of register: CMD_MAPPING_CMD0_0_0

registers['EMC']['register_list'].append('CMD_MAPPING_CMD0_0_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CMD_MAPPING_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_MAPPING_CMD0_1_0'] = {
    'addr'            : 0x384,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x1010101,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'CMD0_DQ4_MAP' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD0_DQ5_MAP' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD0_DQ6_MAP' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD0_DQ7_MAP' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD0_DQ4_MAP',
        'CMD0_DQ5_MAP',
        'CMD0_DQ6_MAP',
        'CMD0_DQ7_MAP',
    ],
} # End of register: CMD_MAPPING_CMD0_1_0

registers['EMC']['register_list'].append('CMD_MAPPING_CMD0_1_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CMD_MAPPING_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_MAPPING_CMD0_2_0'] = {
    'addr'            : 0x388,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x1010101,
    'array'           : False,
    'reset_mask'      : 0xf7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf7f7f7f,
    'write_mask'      : 0xf7f7f7f,
    'CMD0_DQ8_MAP' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD0_DQSP_MAP' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
            'MAP_CLK' : 37,
            'MAP_CLKB' : 38,
        },
    },
    'CMD0_DQSN_MAP' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
            'MAP_CLK' : 37,
            'MAP_CLKB' : 38,
        },
    },
    'CMD0_DQ_CMD_MAP' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_RESET' : 2,
            'MAP_CH0_CKE0' : 3,
            'MAP_CH0_CKE1' : 4,
            'MAP_CH0_CKE_B0' : 5,
            'MAP_CH0_CKE_B1' : 6,
            'MAP_CH1_CKE0' : 7,
            'MAP_CH1_CKE1' : 8,
            'MAP_CH1_CKE_B0' : 9,
            'MAP_CH1_CKE_B1' : 10,
            'MAP_ODT0' : 11,
            'MAP_ODT1' : 12,
            'MAP_ODT_B0' : 13,
            'MAP_ODT_B1' : 14,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD0_DQ8_MAP',
        'CMD0_DQSP_MAP',
        'CMD0_DQSN_MAP',
        'CMD0_DQ_CMD_MAP',
    ],
} # End of register: CMD_MAPPING_CMD0_2_0

registers['EMC']['register_list'].append('CMD_MAPPING_CMD0_2_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CMD_MAPPING_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_MAPPING_CMD1_0_0'] = {
    'addr'            : 0x38c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x1010101,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'CMD1_DQ0_MAP' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD1_DQ1_MAP' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD1_DQ2_MAP' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD1_DQ3_MAP' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD1_DQ0_MAP',
        'CMD1_DQ1_MAP',
        'CMD1_DQ2_MAP',
        'CMD1_DQ3_MAP',
    ],
} # End of register: CMD_MAPPING_CMD1_0_0

registers['EMC']['register_list'].append('CMD_MAPPING_CMD1_0_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CMD_MAPPING_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_MAPPING_CMD1_1_0'] = {
    'addr'            : 0x390,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x1010101,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'CMD1_DQ4_MAP' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD1_DQ5_MAP' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD1_DQ6_MAP' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD1_DQ7_MAP' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD1_DQ4_MAP',
        'CMD1_DQ5_MAP',
        'CMD1_DQ6_MAP',
        'CMD1_DQ7_MAP',
    ],
} # End of register: CMD_MAPPING_CMD1_1_0

registers['EMC']['register_list'].append('CMD_MAPPING_CMD1_1_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CMD_MAPPING_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_MAPPING_CMD1_2_0'] = {
    'addr'            : 0x394,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x1010101,
    'array'           : False,
    'reset_mask'      : 0xf7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf7f7f7f,
    'write_mask'      : 0xf7f7f7f,
    'CMD1_DQ8_MAP' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
        },
    },
    'CMD1_DQSP_MAP' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
            'MAP_CLK' : 37,
            'MAP_CLKB' : 38,
        },
    },
    'CMD1_DQSN_MAP' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_ADR0' : 2,
            'MAP_ADR1' : 3,
            'MAP_ADR2' : 4,
            'MAP_ADR3' : 5,
            'MAP_ADR4' : 6,
            'MAP_ADR5' : 7,
            'MAP_ADR6' : 8,
            'MAP_ADR7' : 9,
            'MAP_ADR8' : 10,
            'MAP_ADR9' : 11,
            'MAP_ADR10' : 12,
            'MAP_ADR11' : 13,
            'MAP_ADR12' : 14,
            'MAP_ADR13' : 15,
            'MAP_ADR14' : 16,
            'MAP_ADR15' : 17,
            'MAP_SUB0' : 18,
            'MAP_SUB1' : 19,
            'MAP_SUB2' : 20,
            'MAP_BA0' : 21,
            'MAP_BA1' : 22,
            'MAP_BA2' : 23,
            'MAP_CAS' : 24,
            'MAP_RAS' : 25,
            'MAP_WE' : 26,
            'MAP_CS0' : 27,
            'MAP_CS1' : 28,
            'MAP_CS_B0' : 29,
            'MAP_CS_B1' : 30,
            'MAP_ODT0' : 31,
            'MAP_ODT1' : 32,
            'MAP_ODT_B0' : 33,
            'MAP_ODT_B1' : 34,
            'MAP_GPIO0' : 35,
            'MAP_GPIO1' : 36,
            'MAP_CLK' : 37,
            'MAP_CLKB' : 38,
        },
    },
    'CMD1_DQ_CMD_MAP' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_RESET' : 2,
            'MAP_CH0_CKE0' : 3,
            'MAP_CH0_CKE1' : 4,
            'MAP_CH0_CKE_B0' : 5,
            'MAP_CH0_CKE_B1' : 6,
            'MAP_CH1_CKE0' : 7,
            'MAP_CH1_CKE1' : 8,
            'MAP_CH1_CKE_B0' : 9,
            'MAP_CH1_CKE_B1' : 10,
            'MAP_ODT0' : 11,
            'MAP_ODT1' : 12,
            'MAP_ODT_B0' : 13,
            'MAP_ODT_B1' : 14,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD1_DQ8_MAP',
        'CMD1_DQSP_MAP',
        'CMD1_DQSN_MAP',
        'CMD1_DQ_CMD_MAP',
    ],
} # End of register: CMD_MAPPING_CMD1_2_0

registers['EMC']['register_list'].append('CMD_MAPPING_CMD1_2_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   CMD_MAPPING_CMD2_0                EMC_WINCR  // Configures the command mapping
#;
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   CMD_MAPPING_CMD2_1                 EMC_WINCR  // Configures the command mapping
#;
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   CMD_MAPPING_CMD2_2                 EMC_WINCR  // Configures the command mapping
#;
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   CMD_MAPPING_CMD3_0                EMC_WINCR  // Configures the command mapping
#;
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   CMD_MAPPING_CMD3_1                 EMC_WINCR  // Configures the command mapping
#;
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   CMD_MAPPING_CMD3_2                 EMC_WINCR  // Configures the command mapping
#;
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_CMD_MAPPING_BYTE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CMD_MAPPING_BYTE_0'] = {
    'addr'            : 0x3b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x1111,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'BYTE0_DQ_CMD_MAP' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_RESET' : 2,
            'MAP_CH0_CKE0' : 3,
            'MAP_CH0_CKE1' : 4,
            'MAP_CH0_CKE_B0' : 5,
            'MAP_CH0_CKE_B1' : 6,
            'MAP_CH1_CKE0' : 7,
            'MAP_CH1_CKE1' : 8,
            'MAP_CH1_CKE_B0' : 9,
            'MAP_CH1_CKE_B1' : 10,
            'MAP_ODT0' : 11,
            'MAP_ODT1' : 12,
            'MAP_ODT_B0' : 13,
            'MAP_ODT_B1' : 14,
        },
    },
    'BYTE1_DQ_CMD_MAP' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_RESET' : 2,
            'MAP_CH0_CKE0' : 3,
            'MAP_CH0_CKE1' : 4,
            'MAP_CH0_CKE_B0' : 5,
            'MAP_CH0_CKE_B1' : 6,
            'MAP_CH1_CKE0' : 7,
            'MAP_CH1_CKE1' : 8,
            'MAP_CH1_CKE_B0' : 9,
            'MAP_CH1_CKE_B1' : 10,
            'MAP_ODT0' : 11,
            'MAP_ODT1' : 12,
            'MAP_ODT_B0' : 13,
            'MAP_ODT_B1' : 14,
        },
    },
    'BYTE2_DQ_CMD_MAP' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_RESET' : 2,
            'MAP_CH0_CKE0' : 3,
            'MAP_CH0_CKE1' : 4,
            'MAP_CH0_CKE_B0' : 5,
            'MAP_CH0_CKE_B1' : 6,
            'MAP_CH1_CKE0' : 7,
            'MAP_CH1_CKE1' : 8,
            'MAP_CH1_CKE_B0' : 9,
            'MAP_CH1_CKE_B1' : 10,
            'MAP_ODT0' : 11,
            'MAP_ODT1' : 12,
            'MAP_ODT_B0' : 13,
            'MAP_ODT_B1' : 14,
        },
    },
    'BYTE3_DQ_CMD_MAP' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MAP_BOOT",
        'enums' : {
            'MAP_NONE' : 0,
            'MAP_BOOT' : 1,
            'MAP_RESET' : 2,
            'MAP_CH0_CKE0' : 3,
            'MAP_CH0_CKE1' : 4,
            'MAP_CH0_CKE_B0' : 5,
            'MAP_CH0_CKE_B1' : 6,
            'MAP_CH1_CKE0' : 7,
            'MAP_CH1_CKE1' : 8,
            'MAP_CH1_CKE_B0' : 9,
            'MAP_CH1_CKE_B1' : 10,
            'MAP_ODT0' : 11,
            'MAP_ODT1' : 12,
            'MAP_ODT_B0' : 13,
            'MAP_ODT_B1' : 14,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BYTE0_DQ_CMD_MAP',
        'BYTE1_DQ_CMD_MAP',
        'BYTE2_DQ_CMD_MAP',
        'BYTE3_DQ_CMD_MAP',
    ],
} # End of register: CMD_MAPPING_BYTE_0

registers['EMC']['register_list'].append('CMD_MAPPING_BYTE_0')
# This register controls how dynamic self-refresh entry/exit is handled.
# ***** PLEASE NOTE *****
#   If ODT is enabled, the DSR_PER_DEVICE field must be set to DISABLED.
#   It is recommended to change the values of ODT_WRITE and DSR_PER_DEVICE with a clock change
#     To do it outside of a clock change sequence, one has to be aware that DSR enable/disable
#     takes time to take effect. This is the sequence for disabling DSR_PER_DEVICE and enabling
#     ODT outside of clock change:
#     1. DYN_SELF_REF <= DISABLED (DSR exit)
#     2. TIMING_UPDATE <= 1 (latch in the shadow value)
#     3. read back and discard any EMC register such as INTSTATUS (ensure 1 and 2 have gone through)
#     4. wait 2 us for the last possible self-refresh entry
#     5. Poll for SDRAM_IN_SELF_REFRESH == 0 (ensure that self-refresh exits)
#     6. ODT_WRITE <= new value to turn on ODT
#        DSR_PER_DEVICE <= DISABLED (turn off per-device DSR)
#        DYN_SELF_REF <= EABLED (re-enable DSR)
#     7. TIMING_UPDATE <= 1 (latch in the shadow values)
# ***** END OF NOTE *****
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DYN_SELF_REF_CONTROL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DYN_SELF_REF_CONTROL_0'] = {
    'addr'            : 0x3e0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x8000ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x8000ffff,
    'write_mask'      : 0x8000ffff,
    'DSR_THRESHOLD' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DSR_PER_DEVICE' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DSR_THRESHOLD',
        'DSR_PER_DEVICE',
    ],
} # End of register: DYN_SELF_REF_CONTROL_0

registers['EMC']['register_list'].append('DYN_SELF_REF_CONTROL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#
# Note: If operating in non-DLL mode, this register needs to be updated w/ the non-DLL timing requirement.

# Register EMC_TXSRDLL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TXSRDLL_0'] = {
    'addr'            : 0x3e4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x7ff,
    'array'           : False,
    'reset_mask'      : 0xfff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff,
    'write_mask'      : 0xfff,
    'TXSRDLL' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x7ff,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TXSRDLL',
    ],
} # End of register: TXSRDLL_0

registers['EMC']['register_list'].append('TXSRDLL_0')
#////////////////////////////////////////////////////////////////////////////////
# CCFIFO_ADDR:  This register contains the address offset of the EMC register  //
#               that's intended to be executed during clock change sequence.    //
# CCFIFO_DATA:  This register contains the 32-bit data of the EMC register     //
#               that's intended to be written pointed to by CCFIFO_ADDR.       //
#                                                                              //
# **Note:  Before triggering a clock change sequence from CAR, one must        //
#          configure the pre-/post- clkchange sequence by writing, multiple    //
#          times, to the CCFIFO_DATA/CCFIFO_ADDR register pair.  Once the      //
#          CCFIFO_ADDR register is written, Hardware will write the register   //
#          offset and corresponding data into the 32-deep clock change FIFO    //
#          (CCFIFO).                                                            //
#////////////////////////////////////////////////////////////////////////////////

# Register EMC_CCFIFO_ADDR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CCFIFO_ADDR_0'] = {
    'addr'            : 0x3e8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x7fffffff,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'CCFIFO_ADDR' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CCFIFO_STALL_CNT' : {
        'lsb'               : 16,
        'msb'               : 30,
        'size'              : 15,
        'field'             : (0x7fff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CCFIFO_STALL_CNT_BY_1' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CCFIFO_ADDR',
        'CCFIFO_STALL_CNT',
        'CCFIFO_STALL_CNT_BY_1',
    ],
} # End of register: CCFIFO_ADDR_0

registers['EMC']['register_list'].append('CCFIFO_ADDR_0')

# Register EMC_CCFIFO_DATA_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CCFIFO_DATA_0'] = {
    'addr'            : 0x3ec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xffffffff,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'CCFIFO_DATA' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CCFIFO_DATA',
    ],
} # End of register: CCFIFO_DATA_0

registers['EMC']['register_list'].append('CCFIFO_DATA_0')

# Register EMC_CCFIFO_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CCFIFO_STATUS_0'] = {
    'addr'            : 0x3f0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x0,
    'CCFIFO_COUNT' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CCFIFO_COUNT',
    ],
} # End of register: CCFIFO_STATUS_0

registers['EMC']['register_list'].append('CCFIFO_STATUS_0')
#
#  SWZ_RANK*_BYTE*_BIT*_SEL fields indicates which SDRAM data bit (0-7) within each byte is mapped/connected to the corresponding bit of the chip.
#
#  T124 has 8 bytes per partition w/o a per rank differenciation for swizzling. The RANK1 register set is controlling swizzling for the upper 4 byte of data.

# Register EMC_SWIZZLE_RANK0_BYTE0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SWIZZLE_RANK0_BYTE0_0'] = {
    'addr'            : 0x404,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x76543210,
    'array'           : False,
    'reset_mask'      : 0x77777777,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x77777777,
    'write_mask'      : 0x77777777,
    'SWZ_RANK0_BYTE0_BIT0_SEL' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE0_BIT1_SEL' : {
        'lsb'               : 4,
        'msb'               : 6,
        'size'              : 3,
        'field'             : (0x7 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE0_BIT2_SEL' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE0_BIT3_SEL' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE0_BIT4_SEL' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE0_BIT5_SEL' : {
        'lsb'               : 20,
        'msb'               : 22,
        'size'              : 3,
        'field'             : (0x7 << 20),
        'woffset'           : 0x0,
        'default'           : 0x5,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE0_BIT6_SEL' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE0_BIT7_SEL' : {
        'lsb'               : 28,
        'msb'               : 30,
        'size'              : 3,
        'field'             : (0x7 << 28),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SWZ_RANK0_BYTE0_BIT0_SEL',
        'SWZ_RANK0_BYTE0_BIT1_SEL',
        'SWZ_RANK0_BYTE0_BIT2_SEL',
        'SWZ_RANK0_BYTE0_BIT3_SEL',
        'SWZ_RANK0_BYTE0_BIT4_SEL',
        'SWZ_RANK0_BYTE0_BIT5_SEL',
        'SWZ_RANK0_BYTE0_BIT6_SEL',
        'SWZ_RANK0_BYTE0_BIT7_SEL',
    ],
} # End of register: SWIZZLE_RANK0_BYTE0_0

registers['EMC']['register_list'].append('SWIZZLE_RANK0_BYTE0_0')

# Register EMC_SWIZZLE_RANK0_BYTE1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SWIZZLE_RANK0_BYTE1_0'] = {
    'addr'            : 0x408,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x76543210,
    'array'           : False,
    'reset_mask'      : 0x77777777,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x77777777,
    'write_mask'      : 0x77777777,
    'SWZ_RANK0_BYTE1_BIT0_SEL' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE1_BIT1_SEL' : {
        'lsb'               : 4,
        'msb'               : 6,
        'size'              : 3,
        'field'             : (0x7 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE1_BIT2_SEL' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE1_BIT3_SEL' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE1_BIT4_SEL' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE1_BIT5_SEL' : {
        'lsb'               : 20,
        'msb'               : 22,
        'size'              : 3,
        'field'             : (0x7 << 20),
        'woffset'           : 0x0,
        'default'           : 0x5,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE1_BIT6_SEL' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE1_BIT7_SEL' : {
        'lsb'               : 28,
        'msb'               : 30,
        'size'              : 3,
        'field'             : (0x7 << 28),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SWZ_RANK0_BYTE1_BIT0_SEL',
        'SWZ_RANK0_BYTE1_BIT1_SEL',
        'SWZ_RANK0_BYTE1_BIT2_SEL',
        'SWZ_RANK0_BYTE1_BIT3_SEL',
        'SWZ_RANK0_BYTE1_BIT4_SEL',
        'SWZ_RANK0_BYTE1_BIT5_SEL',
        'SWZ_RANK0_BYTE1_BIT6_SEL',
        'SWZ_RANK0_BYTE1_BIT7_SEL',
    ],
} # End of register: SWIZZLE_RANK0_BYTE1_0

registers['EMC']['register_list'].append('SWIZZLE_RANK0_BYTE1_0')

# Register EMC_SWIZZLE_RANK0_BYTE2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SWIZZLE_RANK0_BYTE2_0'] = {
    'addr'            : 0x40c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x76543210,
    'array'           : False,
    'reset_mask'      : 0x77777777,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x77777777,
    'write_mask'      : 0x77777777,
    'SWZ_RANK0_BYTE2_BIT0_SEL' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE2_BIT1_SEL' : {
        'lsb'               : 4,
        'msb'               : 6,
        'size'              : 3,
        'field'             : (0x7 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE2_BIT2_SEL' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE2_BIT3_SEL' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE2_BIT4_SEL' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE2_BIT5_SEL' : {
        'lsb'               : 20,
        'msb'               : 22,
        'size'              : 3,
        'field'             : (0x7 << 20),
        'woffset'           : 0x0,
        'default'           : 0x5,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE2_BIT6_SEL' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE2_BIT7_SEL' : {
        'lsb'               : 28,
        'msb'               : 30,
        'size'              : 3,
        'field'             : (0x7 << 28),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SWZ_RANK0_BYTE2_BIT0_SEL',
        'SWZ_RANK0_BYTE2_BIT1_SEL',
        'SWZ_RANK0_BYTE2_BIT2_SEL',
        'SWZ_RANK0_BYTE2_BIT3_SEL',
        'SWZ_RANK0_BYTE2_BIT4_SEL',
        'SWZ_RANK0_BYTE2_BIT5_SEL',
        'SWZ_RANK0_BYTE2_BIT6_SEL',
        'SWZ_RANK0_BYTE2_BIT7_SEL',
    ],
} # End of register: SWIZZLE_RANK0_BYTE2_0

registers['EMC']['register_list'].append('SWIZZLE_RANK0_BYTE2_0')

# Register EMC_SWIZZLE_RANK0_BYTE3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SWIZZLE_RANK0_BYTE3_0'] = {
    'addr'            : 0x410,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x76543210,
    'array'           : False,
    'reset_mask'      : 0x77777777,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x77777777,
    'write_mask'      : 0x77777777,
    'SWZ_RANK0_BYTE3_BIT0_SEL' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE3_BIT1_SEL' : {
        'lsb'               : 4,
        'msb'               : 6,
        'size'              : 3,
        'field'             : (0x7 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE3_BIT2_SEL' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE3_BIT3_SEL' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE3_BIT4_SEL' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE3_BIT5_SEL' : {
        'lsb'               : 20,
        'msb'               : 22,
        'size'              : 3,
        'field'             : (0x7 << 20),
        'woffset'           : 0x0,
        'default'           : 0x5,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE3_BIT6_SEL' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SWZ_RANK0_BYTE3_BIT7_SEL' : {
        'lsb'               : 28,
        'msb'               : 30,
        'size'              : 3,
        'field'             : (0x7 << 28),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SWZ_RANK0_BYTE3_BIT0_SEL',
        'SWZ_RANK0_BYTE3_BIT1_SEL',
        'SWZ_RANK0_BYTE3_BIT2_SEL',
        'SWZ_RANK0_BYTE3_BIT3_SEL',
        'SWZ_RANK0_BYTE3_BIT4_SEL',
        'SWZ_RANK0_BYTE3_BIT5_SEL',
        'SWZ_RANK0_BYTE3_BIT6_SEL',
        'SWZ_RANK0_BYTE3_BIT7_SEL',
    ],
} # End of register: SWIZZLE_RANK0_BYTE3_0

registers['EMC']['register_list'].append('SWIZZLE_RANK0_BYTE3_0')
#///
#/// Training Support Registers in EMC ////

# Register EMC_TR_TIMING_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_TIMING_0_0'] = {
    'addr'            : 0x3b4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x11861b8,
    'array'           : False,
    'reset_mask'      : 0xffbcf3ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffbcf3ff,
    'write_mask'      : 0xffbcf3ff,
    'T_VREF_LONG' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x1b8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'T_DSTRAIN' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'T_DHTRAIN' : {
        'lsb'               : 18,
        'msb'               : 21,
        'size'              : 4,
        'field'             : (0xf << 18),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'T_CATR_RD2VREF' : {
        'lsb'               : 23,
        'msb'               : 31,
        'size'              : 9,
        'field'             : (0x1ff << 23),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'T_VREF_LONG',
        'T_DSTRAIN',
        'T_DHTRAIN',
        'T_CATR_RD2VREF',
    ],
} # End of register: TR_TIMING_0_0

registers['EMC']['register_list'].append('TR_TIMING_0_0')

# Register EMC_TR_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_CTRL_0_0'] = {
    'addr'            : 0x3b8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x4000020,
    'array'           : False,
    'reset_mask'      : 0x73f11ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x73f11ff,
    'write_mask'      : 0x73f11ff,
    'CAVREF_TX_BYTE_MASK' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CAVREF_DQS_DURATION' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CATR_ENABLE' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CATR_MODE2_ENABLE' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CATR_DQS_PULSE_WD' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CAVREF_DRIVE_DQS' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ENABLE_CA_VREF_UPPER' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ENABLE_CA_VREF_LOWER' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CAVREF_TX_BYTE_MASK',
        'CAVREF_DQS_DURATION',
        'CATR_ENABLE',
        'CATR_MODE2_ENABLE',
        'CATR_DQS_PULSE_WD',
        'CAVREF_DRIVE_DQS',
        'ENABLE_CA_VREF_UPPER',
        'ENABLE_CA_VREF_LOWER',
    ],
} # End of register: TR_CTRL_0_0

registers['EMC']['register_list'].append('TR_CTRL_0_0')

# Register EMC_TR_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_CTRL_1_0'] = {
    'addr'            : 0x3bc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f,
    'write_mask'      : 0x1f,
    'ENABLE_TR_RDV' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ENABLE_TR_QPOP' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ENABLE_TR_RDV_MASK' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ENABLE_TR_QSAFE' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'ENABLE_TR_QRST' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ENABLE_TR_RDV',
        'ENABLE_TR_QPOP',
        'ENABLE_TR_RDV_MASK',
        'ENABLE_TR_QSAFE',
        'ENABLE_TR_QRST',
    ],
} # End of register: TR_CTRL_1_0

registers['EMC']['register_list'].append('TR_CTRL_1_0')

# Register EMC_TR_DVFS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_DVFS_0'] = {
    'addr'            : 0x460,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'TRAINING_DVFS' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TRAINING_DVFS',
    ],
} # End of register: TR_DVFS_0

registers['EMC']['register_list'].append('TR_DVFS_0')

# Register EMC_SWITCH_BACK_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['SWITCH_BACK_CTRL_0'] = {
    'addr'            : 0x3c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x2,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3,
    'write_mask'      : 0x3,
    'CLK_SWITCH_BACK' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwt',
        'enums' : {
        },
    },
    'CLK_SKIP_SWITCH_BACK' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwt',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CLK_SWITCH_BACK',
        'CLK_SKIP_SWITCH_BACK',
    ],
} # End of register: SWITCH_BACK_CTRL_0

registers['EMC']['register_list'].append('SWITCH_BACK_CTRL_0')

# Register EMC_TR_RDV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_RDV_0'] = {
    'addr'            : 0x3c4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0xf,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'TR_RDV' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR_RDV',
    ],
} # End of register: TR_RDV_0

registers['EMC']['register_list'].append('TR_RDV_0')

# Register EMC_TR_QPOP_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_QPOP_0'] = {
    'addr'            : 0x3f4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x6,
    'array'           : False,
    'reset_mask'      : 0xff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff00ff,
    'write_mask'      : 0xff00ff,
    'TR_QPOP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    'TR_QPOP_PREAMBLE' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR_QPOP',
        'TR_QPOP_PREAMBLE',
    ],
} # End of register: TR_QPOP_0

registers['EMC']['register_list'].append('TR_QPOP_0')

# Register EMC_TR_RDV_MASK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_RDV_MASK_0'] = {
    'addr'            : 0x3f8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x6,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'TR_RDV_MASK' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR_RDV_MASK',
    ],
} # End of register: TR_RDV_MASK_0

registers['EMC']['register_list'].append('TR_RDV_MASK_0')

# Register EMC_TR_QSAFE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_QSAFE_0'] = {
    'addr'            : 0x3fc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x6,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'TR_QSAFE' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR_QSAFE',
    ],
} # End of register: TR_QSAFE_0

registers['EMC']['register_list'].append('TR_QSAFE_0')

# Register EMC_TR_QRST_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_QRST_0'] = {
    'addr'            : 0x400,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x15,
    'reset_val'       : 0x6,
    'array'           : False,
    'reset_mask'      : 0x1f00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f00ff,
    'write_mask'      : 0x1f00ff,
    'TR_QRST' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    'TR_QRST_DURATION' : {
        'lsb'               : 16,
        'msb'               : 20,
        'size'              : 5,
        'field'             : (0x1f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR_QRST',
        'TR_QRST_DURATION',
    ],
} # End of register: TR_QRST_0

registers['EMC']['register_list'].append('TR_QRST_0')

# Register EMC_MPC_R2W_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MPC_R2W_0'] = {
    'addr'            : 0x414,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0xff,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'RTRRD' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0xff,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RTRRD',
    ],
} # End of register: MPC_R2W_0

registers['EMC']['register_list'].append('MPC_R2W_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_IBDLY_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['IBDLY_0'] = {
    'addr'            : 0x468,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x1,
    'array'           : False,
    'reset_mask'      : 0x300000ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x300000ff,
    'write_mask'      : 0x300000ff,
    'IBDLY' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IBDLY_MODE' : {
        'lsb'               : 28,
        'msb'               : 29,
        'size'              : 2,
        'field'             : (0x3 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DISABLED' : 0,
            'AFTER_CMD' : 1,
            'RESERVED' : 2,
            'B4_CMD' : 3,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IBDLY',
        'IBDLY_MODE',
    ],
} # End of register: IBDLY_0

registers['EMC']['register_list'].append('IBDLY_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_OBDLY_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['OBDLY_0'] = {
    'addr'            : 0x46c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x3,
    'array'           : False,
    'reset_mask'      : 0x3000003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3000003f,
    'write_mask'      : 0x3000003f,
    'OBDLY' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OBDLY_MODE' : {
        'lsb'               : 28,
        'msb'               : 29,
        'size'              : 2,
        'field'             : (0x3 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DISABLED' : 0,
            'AFTER_CMD' : 1,
            'RESERVED' : 2,
            'B4_CMD' : 3,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OBDLY',
        'OBDLY_MODE',
    ],
} # End of register: OBDLY_0

registers['EMC']['register_list'].append('OBDLY_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_TXDSRVTTGEN_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TXDSRVTTGEN_0'] = {
    'addr'            : 0x480,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff,
    'write_mask'      : 0xfff,
    'TXDSRVTTGEN' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TXDSRVTTGEN',
    ],
} # End of register: TXDSRVTTGEN_0

registers['EMC']['register_list'].append('TXDSRVTTGEN_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WE_DURATION_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WE_DURATION_0'] = {
    'addr'            : 0x48c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WE_DURATION' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WE_DURATION',
    ],
} # End of register: WE_DURATION_0

registers['EMC']['register_list'].append('WE_DURATION_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WS_DURATION_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WS_DURATION_0'] = {
    'addr'            : 0x490,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WS_DURATION' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WS_DURATION',
    ],
} # End of register: WS_DURATION_0

registers['EMC']['register_list'].append('WS_DURATION_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WEV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WEV_0'] = {
    'addr'            : 0x494,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WEV' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX' : 40,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WEV',
    ],
} # End of register: WEV_0

registers['EMC']['register_list'].append('WEV_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_WSV_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['WSV_0'] = {
    'addr'            : 0x498,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x3f,
    'WSV' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX' : 40,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WSV',
    ],
} # End of register: WSV_0

registers['EMC']['register_list'].append('WSV_0')
# Boot requirements: This register (except for fields DRAMC_PRE_B4_ACT, MRR_BYTESEL_X16, MRR_BYTESEL) should be saved in the scratch registers and restored by the BootROM during warmboot.
# Boot requirements: If the OS needs the MRR_BYTESEL* fields set to non-default values to perform a mode-register read, it needs to correctly program these values before performing the MRR.

# Register EMC_CFG_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_3_0'] = {
    'addr'            : 0x49c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x13,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x50077,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x50077,
    'write_mask'      : 0x50077,
    'MRR_BYTESEL' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'MRR_BYTESEL_X16' : {
        'lsb'               : 4,
        'msb'               : 6,
        'size'              : 3,
        'field'             : (0x7 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'R0_GEOMETRY' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "LP4_1x16",
        'enums' : {
            'LP4_1x16' : 0,
            'LP4_2x8' : 1,
        },
    },
    'R1_GEOMETRY' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "LP4_1x16",
        'enums' : {
            'LP4_1x16' : 0,
            'LP4_2x8' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MRR_BYTESEL',
        'MRR_BYTESEL_X16',
        'R0_GEOMETRY',
        'R1_GEOMETRY',
    ],
} # End of register: CFG_3_0

registers['EMC']['register_list'].append('CFG_3_0')
# This pipe stage is present inside the pad macro not at the top level
# This register is shadowed: see usage note at top of spec file.

# Register EMC_CFG_PIPE_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_PIPE_2_0'] = {
    'addr'            : 0x554,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x16,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f003f,
    'write_mask'      : 0x3f003f,
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK0' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK2' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK4' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK5' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK0',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK1',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK2',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK3',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK4',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE3_BRICK5',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK0',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK1',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK2',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK3',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK4',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE3_BRICK5',
    ],
} # End of register: CFG_PIPE_2_0

registers['EMC']['register_list'].append('CFG_PIPE_2_0')

# Register EMC_CFG_PIPE_CLK_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_PIPE_CLK_0'] = {
    'addr'            : 0x558,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x1,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x1,
    'sw_default_mask' : 0x1,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'PIPE_CLK_ENABLE_OVERRIDE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x1,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "CLK_ALWAYS_ON",
        'enums' : {
            'CLK_GATED' : 0,
            'CLK_ALWAYS_ON' : 1,
            'DISABLE' : 0,
            'ENABLE' : 1,
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PIPE_CLK_ENABLE_OVERRIDE',
    ],
} # End of register: CFG_PIPE_CLK_0

registers['EMC']['register_list'].append('CFG_PIPE_CLK_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_CFG_PIPE_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_PIPE_1_0'] = {
    'addr'            : 0x55c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x16,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f003f,
    'write_mask'      : 0x3f003f,
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK0' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK2' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK4' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK5' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK0',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK1',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK2',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK3',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK4',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE1_BRICK5',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK0',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK1',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK2',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK3',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK4',
        'EMC2PMACRO_CFG_BYPASS_CMD_OB_PIPE2_BRICK5',
    ],
} # End of register: CFG_PIPE_1_0

registers['EMC']['register_list'].append('CFG_PIPE_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_CFG_PIPE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['CFG_PIPE_0'] = {
    'addr'            : 0x560,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x16,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f003f,
    'write_mask'      : 0x3f003f,
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK0' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK2' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK4' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK5' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK0',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK1',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK2',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK3',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK4',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE1_BRICK5',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK0',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK1',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK2',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK3',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK4',
        'EMC2PMACRO_CFG_BYPASS_OB_PIPE2_BRICK5',
    ],
} # End of register: CFG_PIPE_0

registers['EMC']['register_list'].append('CFG_PIPE_0')
# This register is shadowed
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_QPOP_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['QPOP_0'] = {
    'addr'            : 0x564,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x6,
    'array'           : False,
    'reset_mask'      : 0xff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff00ff,
    'write_mask'      : 0xff00ff,
    'QPOP' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x6,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    'QPOP_PREAMBLE' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'MAX_1TO1' : 75,
            'MAX_2TO1' : 150,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QPOP',
        'QPOP_PREAMBLE',
    ],
} # End of register: QPOP_0

registers['EMC']['register_list'].append('QPOP_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_QUSE_WIDTH_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['QUSE_WIDTH_0'] = {
    'addr'            : 0x568,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x3,
    'array'           : False,
    'reset_mask'      : 0x3000001f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3000001f,
    'write_mask'      : 0x3000001f,
    'QUSE_DURATION' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_EXTEND_UI' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_SHORTEN_2UI' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE_DURATION',
        'QUSE_EXTEND_UI',
        'QUSE_SHORTEN_2UI',
    ],
} # End of register: QUSE_WIDTH_0

registers['EMC']['register_list'].append('QUSE_WIDTH_0')
# This register is shadowed: see usage note at top of spec file.
# Set both RXTERM_DURATION and CFG_STATIC_TERM to disable terminations.
# RXTERM defines start of term window
# RX_TERM_MODE controls termination type

# Register EMC_PUTERM_WIDTH_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PUTERM_WIDTH_0'] = {
    'addr'            : 0x56c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x5,
    'array'           : False,
    'reset_mask'      : 0x8000001f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x8000001f,
    'write_mask'      : 0x8000001f,
    'CFG_STATIC_TERM' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'RXTERM_DURATION' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x5,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CFG_STATIC_TERM',
        'RXTERM_DURATION',
    ],
} # End of register: PUTERM_WIDTH_0

registers['EMC']['register_list'].append('PUTERM_WIDTH_0')
# This register is shadowed: see usage note at top of spec file.
#offset 0x574;
#reg   PUTERM_ADJ  EMC_WINCR  //PUTERM controls
#     1:0      rwsp CFG_PUTERM_LATE       init=0x1 sw_default=0x1        //   Half-cycle increments
#     7        rwsp CFG_PUTERM_EXTEND_HALF_CLK       init=ENABLED sw_default=ENABLED //  extend the PUTERM window by half clk
#                   enum (DISABLED, ENABLED)
#;

# Register EMC_PROTOBIST_CONFIG_ADR_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PROTOBIST_CONFIG_ADR_1_0'] = {
    'addr'            : 0x5d0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x30000000,
    'array'           : False,
    'reset_mask'      : 0x7ffffff8,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x0,
    'write_mask'      : 0x7ffffff8,
    'PROTOBIST_A_BANK' : {
        'lsb'               : 3,
        'msb'               : 5,
        'size'              : 3,
        'field'             : (0x7 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_BANK' : {
        'lsb'               : 6,
        'msb'               : 8,
        'size'              : 3,
        'field'             : (0x7 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_A_DEV' : {
        'lsb'               : 9,
        'msb'               : 10,
        'size'              : 2,
        'field'             : (0x3 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_A_REF' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_A_ROW' : {
        'lsb'               : 12,
        'msb'               : 27,
        'size'              : 16,
        'field'             : (0xffff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_A_RDY' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_APC' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_A_ROW_MSB' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PROTOBIST_A_BANK',
        'PROTOBIST_BANK',
        'PROTOBIST_A_DEV',
        'PROTOBIST_A_REF',
        'PROTOBIST_A_ROW',
        'PROTOBIST_A_RDY',
        'PROTOBIST_APC',
        'PROTOBIST_A_ROW_MSB',
    ],
} # End of register: PROTOBIST_CONFIG_ADR_1_0

registers['EMC']['register_list'].append('PROTOBIST_CONFIG_ADR_1_0')

# Register EMC_PROTOBIST_CONFIG_ADR_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PROTOBIST_CONFIG_ADR_2_0'] = {
    'addr'            : 0x5d4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x8000101,
    'array'           : False,
    'reset_mask'      : 0x1fffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x0,
    'write_mask'      : 0x1fffffff,
    'PROTOBIST_CGID' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_T_RDY' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_T_COL' : {
        'lsb'               : 9,
        'msb'               : 20,
        'size'              : 12,
        'field'             : (0xfff << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_T_COL1' : {
        'lsb'               : 21,
        'msb'               : 23,
        'size'              : 3,
        'field'             : (0x7 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_T_DEV' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_MASKED_WRITE' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_SIZE' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x2,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_SWAP' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PROTOBIST_CGID',
        'PROTOBIST_T_RDY',
        'PROTOBIST_T_COL',
        'PROTOBIST_T_COL1',
        'PROTOBIST_T_DEV',
        'PROTOBIST_MASKED_WRITE',
        'PROTOBIST_SIZE',
        'PROTOBIST_SWAP',
    ],
} # End of register: PROTOBIST_CONFIG_ADR_2_0

registers['EMC']['register_list'].append('PROTOBIST_CONFIG_ADR_2_0')

# Register EMC_PROTOBIST_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PROTOBIST_MISC_0'] = {
    'addr'            : 0x5d8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf7fff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xc000,
    'write_mask'      : 0xf7fff,
    'PROTOBIST_TAG' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_RDI_SEL' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_MODE' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_W_BE' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_START' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
        'enums' : {
        },
    },
    'PROTOBIST_READ_ACK' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'PROTOBIST_REQ' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    'PROTOBIST_RESET' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PROTOBIST_TAG',
        'PROTOBIST_RDI_SEL',
        'PROTOBIST_MODE',
        'PROTOBIST_W_BE',
        'PROTOBIST_START',
        'PROTOBIST_READ_ACK',
        'PROTOBIST_REQ',
        'PROTOBIST_RESET',
    ],
} # End of register: PROTOBIST_MISC_0

registers['EMC']['register_list'].append('PROTOBIST_MISC_0')

# Register EMC_PROTOBIST_WDATA_LOWER_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PROTOBIST_WDATA_LOWER_0'] = {
    'addr'            : 0x5dc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'PROTOBIST_DATA_LOWER' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PROTOBIST_DATA_LOWER',
    ],
} # End of register: PROTOBIST_WDATA_LOWER_0

registers['EMC']['register_list'].append('PROTOBIST_WDATA_LOWER_0')

# Register EMC_PROTOBIST_WDATA_UPPER_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PROTOBIST_WDATA_UPPER_0'] = {
    'addr'            : 0x5e0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'PROTOBIST_DATA_UPPER' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PROTOBIST_DATA_UPPER',
    ],
} # End of register: PROTOBIST_WDATA_UPPER_0

registers['EMC']['register_list'].append('PROTOBIST_WDATA_UPPER_0')

# Register EMC_PROTOBIST_RDATA_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PROTOBIST_RDATA_0'] = {
    'addr'            : 0x5ec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'PROTOBIST_RDATA' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PROTOBIST_RDATA',
    ],
} # End of register: PROTOBIST_RDATA_0

registers['EMC']['register_list'].append('PROTOBIST_RDATA_0')
# DLL cal config register 0

# Register EMC_PMACRO_DLL_CFG_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DLL_CFG_0_0'] = {
    'addr'            : 0x5e4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x1a340f0,
    'array'           : False,
    'reset_mask'      : 0x3ffffff0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ffffff0,
    'write_mask'      : 0x3ffffff0,
    'DDLLCAL_CTRL_SAMPLE_DELAY' : {
        'lsb'               : 4,
        'msb'               : 11,
        'size'              : 8,
        'field'             : (0xff << 4),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CTRL_SAMPLE_COUNT' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CTRL_FILTER_BITS' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CTRL_END_COUNT' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0xa,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CTRL_STEP_SIZE' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CTRL_DUAL_PASS_LOCK' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CTRL_IGNORE_START' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLLCAL_CTRL_SAMPLE_DELAY',
        'DDLLCAL_CTRL_SAMPLE_COUNT',
        'DDLLCAL_CTRL_FILTER_BITS',
        'DDLLCAL_CTRL_END_COUNT',
        'DDLLCAL_CTRL_STEP_SIZE',
        'DDLLCAL_CTRL_DUAL_PASS_LOCK',
        'DDLLCAL_CTRL_IGNORE_START',
    ],
} # End of register: PMACRO_DLL_CFG_0_0

registers['EMC']['register_list'].append('PMACRO_DLL_CFG_0_0')
# DLL cal config register 1

# Register EMC_PMACRO_DLL_CFG_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DLL_CFG_1_0'] = {
    'addr'            : 0x5e8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x19,
    'reset_val'       : 0x20,
    'array'           : False,
    'reset_mask'      : 0x13337ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x13337ff,
    'write_mask'      : 0x13337ff,
    'DDLLCAL_CTRL_START_TRIM' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'E_DDLL_PWRD' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MDDLL_SEL_CLK_SRC' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DDLLCLK' : 0,
            'M2CLK0' : 1,
        },
    },
    'MDDLL_PHASE_SELECT' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MDDLL_E_TCLK' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MDDLL_SEL_CLK_TESTSRC' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'MDDLLCAL_CLK_ALWAYS_ON' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLLCAL_CTRL_START_TRIM',
        'E_DDLL_PWRD',
        'MDDLL_SEL_CLK_SRC',
        'MDDLL_PHASE_SELECT',
        'MDDLL_E_TCLK',
        'MDDLL_SEL_CLK_TESTSRC',
        'MDDLLCAL_CLK_ALWAYS_ON',
    ],
} # End of register: PMACRO_DLL_CFG_1_0

registers['EMC']['register_list'].append('PMACRO_DLL_CFG_1_0')
# DLL cal config register 2

# Register EMC_PMACRO_DLL_CFG_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DLL_CFG_2_0'] = {
    'addr'            : 0x5f8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x640,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'DDLLCAL_CK_SETTLE_TIME' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x640,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLLCAL_CK_SETTLE_TIME',
    ],
} # End of register: PMACRO_DLL_CFG_2_0

registers['EMC']['register_list'].append('PMACRO_DLL_CFG_2_0')

# Register EMC_TRAINING_CMD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CMD_0'] = {
    'addr'            : 0xe00,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xc00003ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xc00003ff,
    'write_mask'      : 0xc00003ff,
    'PRIME' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CA' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RD' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'WR' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'QUSE' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'CA_VREF' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'WR_VREF' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RD_VREF' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'QUSE_VREF' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'WR_LEVEL' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'PERIODIC' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'GO' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwo',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PRIME',
        'CA',
        'RD',
        'WR',
        'QUSE',
        'CA_VREF',
        'WR_VREF',
        'RD_VREF',
        'QUSE_VREF',
        'WR_LEVEL',
        'PERIODIC',
        'GO',
    ],
} # End of register: TRAINING_CMD_0

registers['EMC']['register_list'].append('TRAINING_CMD_0')

# Register EMC_TRAINING_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CTRL_0'] = {
    'addr'            : 0xe04,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x15,
    'reset_val'       : 0x9080,
    'array'           : False,
    'reset_mask'      : 0x1fffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1fffff,
    'write_mask'      : 0x1fffff,
    'ASYNC_UPDATES' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'REFRESH' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'REFRESH_CA' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RPT_MODE' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'IFIFO_WRPTR' : {
        'lsb'               : 4,
        'msb'               : 11,
        'size'              : 8,
        'field'             : (0xff << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'QUSE_MODE' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "IFIFO_WRPTR",
        'enums' : {
            'READ_DATA' : 0,
            'IFIFO_WRPTR' : 1,
        },
    },
    'UPDATE_QUSE_RD_TR' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'SWAP_RANK' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "RANK0",
        'enums' : {
            'RANK0' : 0,
            'RANK1' : 1,
        },
    },
    'TR_IN_SELF_REFRESH' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ENABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'FORCE_DR_TO_SR' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ABSOLUTE_REG_DURING_PERIODIC' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'LOWER_X8_CA_TRAINING' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'RD_DBI' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'USE_X8_CA_VREF' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ASYNC_UPDATES',
        'REFRESH',
        'REFRESH_CA',
        'RPT_MODE',
        'IFIFO_WRPTR',
        'QUSE_MODE',
        'UPDATE_QUSE_RD_TR',
        'SWAP_RANK',
        'TR_IN_SELF_REFRESH',
        'FORCE_DR_TO_SR',
        'ABSOLUTE_REG_DURING_PERIODIC',
        'LOWER_X8_CA_TRAINING',
        'RD_DBI',
        'USE_X8_CA_VREF',
    ],
} # End of register: TRAINING_CTRL_0

registers['EMC']['register_list'].append('TRAINING_CTRL_0')

# Register EMC_TRAINING_STATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_STATUS_0'] = {
    'addr'            : 0xe08,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0x0,
    'STATUS' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
            'init_enum'  : "DONE",
        'enums' : {
            'DONE' : 0,
            'RUNNING' : 1,
            'ERROR' : 2,
        },
    },
    'STATUS_PER' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
            'init_enum'  : "DONE",
        'enums' : {
            'DONE' : 0,
            'RUNNING' : 1,
            'ERROR' : 2,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'STATUS',
        'STATUS_PER',
    ],
} # End of register: TRAINING_STATUS_0

registers['EMC']['register_list'].append('TRAINING_STATUS_0')

# Register EMC_TRAINING_QUSE_CORS_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_QUSE_CORS_CTRL_0'] = {
    'addr'            : 0xe0c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x111e000,
    'array'           : False,
    'reset_mask'      : 0x1ff7fdff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ff7fdff,
    'write_mask'      : 0x1ff7fdff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 8,
        'size'              : 9,
        'field'             : (0x1ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 10,
        'msb'               : 18,
        'size'              : 9,
        'field'             : (0x1ff << 10),
        'woffset'           : 0x0,
        'default'           : 0x78,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 120,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN_SIZE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
        'STEP_LN',
        'STEP_LN_SIZE',
    ],
} # End of register: TRAINING_QUSE_CORS_CTRL_0

registers['EMC']['register_list'].append('TRAINING_QUSE_CORS_CTRL_0')

# Register EMC_TRAINING_QUSE_FINE_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_QUSE_FINE_CTRL_0'] = {
    'addr'            : 0xe10,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x1110ffc1,
    'array'           : False,
    'reset_mask'      : 0x1fffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1fffffff,
    'write_mask'      : 0x1fffffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3c1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MINUS_63",
        'enums' : {
            'MINUS_63' : 961,
        },
    },
    'MAX' : {
        'lsb'               : 10,
        'msb'               : 19,
        'size'              : 10,
        'field'             : (0x3ff << 10),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PLUS_63",
        'enums' : {
            'PLUS_63' : 63,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN_SIZE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
        'STEP_LN',
        'STEP_LN_SIZE',
    ],
} # End of register: TRAINING_QUSE_FINE_CTRL_0

registers['EMC']['register_list'].append('TRAINING_QUSE_FINE_CTRL_0')

# Register EMC_TRAINING_QUSE_CTRL_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_QUSE_CTRL_MISC_0'] = {
    'addr'            : 0xe14,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x15081000,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'ERR_LIMIT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'BURST_COUNT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ONE' : 0,
            'TWO' : 1,
            'THREE' : 2,
            'FOUR' : 3,
        },
    },
    'PATTERN' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MPC",
        'enums' : {
            'FIFO' : 0,
            'MPC' : 1,
        },
    },
    'LEVEL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "BYTE",
        'enums' : {
            'BYTE' : 0,
            'BIT' : 1,
        },
    },
    'PATRAM_MIN' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PATRAM_MAX' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x15,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR_LIMIT',
        'BURST_COUNT',
        'PATTERN',
        'LEVEL',
        'PATRAM_MIN',
        'PATRAM_MAX',
    ],
} # End of register: TRAINING_QUSE_CTRL_MISC_0

registers['EMC']['register_list'].append('TRAINING_QUSE_CTRL_MISC_0')

# Register EMC_TRAINING_WRITE_FINE_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WRITE_FINE_CTRL_0'] = {
    'addr'            : 0xe18,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x11150000,
    'array'           : False,
    'reset_mask'      : 0x1fffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1fffffff,
    'write_mask'      : 0x1fffffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 10,
        'msb'               : 19,
        'size'              : 10,
        'field'             : (0x3ff << 10),
        'woffset'           : 0x0,
        'default'           : 0x140,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 320,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN_SIZE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
        'STEP_LN',
        'STEP_LN_SIZE',
    ],
} # End of register: TRAINING_WRITE_FINE_CTRL_0

registers['EMC']['register_list'].append('TRAINING_WRITE_FINE_CTRL_0')

# Register EMC_TRAINING_WRITE_CTRL_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WRITE_CTRL_MISC_0'] = {
    'addr'            : 0xe1c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x7000300,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'ERR_LIMIT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'BURST_COUNT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "FOUR",
        'enums' : {
            'ONE' : 0,
            'TWO' : 1,
            'THREE' : 2,
            'FOUR' : 3,
        },
    },
    'PATTERN' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "FIFO",
        'enums' : {
            'FIFO' : 0,
            'MPC' : 1,
        },
    },
    'LEVEL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "BYTE",
        'enums' : {
            'BYTE' : 0,
            'BIT' : 1,
        },
    },
    'PATRAM_MIN' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PATRAM_MAX' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR_LIMIT',
        'BURST_COUNT',
        'PATTERN',
        'LEVEL',
        'PATRAM_MIN',
        'PATRAM_MAX',
    ],
} # End of register: TRAINING_WRITE_CTRL_MISC_0

registers['EMC']['register_list'].append('TRAINING_WRITE_CTRL_MISC_0')

# Register EMC_TRAINING_WRITE_VREF_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WRITE_VREF_CTRL_0'] = {
    'addr'            : 0xe20,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x103200,
    'array'           : False,
    'reset_mask'      : 0xf0ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffff,
    'write_mask'      : 0xf0ffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x32,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 50,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
    ],
} # End of register: TRAINING_WRITE_VREF_CTRL_0

registers['EMC']['register_list'].append('TRAINING_WRITE_VREF_CTRL_0')

# Register EMC_TRAINING_READ_FINE_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_READ_FINE_CTRL_0'] = {
    'addr'            : 0xe24,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x1110fc00,
    'array'           : False,
    'reset_mask'      : 0x1fffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1fffffff,
    'write_mask'      : 0x1fffffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 10,
        'msb'               : 19,
        'size'              : 10,
        'field'             : (0x3ff << 10),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 63,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN_SIZE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
        'STEP_LN',
        'STEP_LN_SIZE',
    ],
} # End of register: TRAINING_READ_FINE_CTRL_0

registers['EMC']['register_list'].append('TRAINING_READ_FINE_CTRL_0')

# Register EMC_TRAINING_READ_CTRL_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_READ_CTRL_MISC_0'] = {
    'addr'            : 0xe28,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x15081300,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'ERR_LIMIT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'BURST_COUNT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "FOUR",
        'enums' : {
            'FOUR' : 3,
        },
    },
    'PATTERN' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MPC",
        'enums' : {
            'FIFO' : 0,
            'MPC' : 1,
        },
    },
    'LEVEL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "BYTE",
        'enums' : {
            'BYTE' : 0,
            'BIT' : 1,
        },
    },
    'PATRAM_MIN' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PATRAM_MAX' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x15,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR_LIMIT',
        'BURST_COUNT',
        'PATTERN',
        'LEVEL',
        'PATRAM_MIN',
        'PATRAM_MAX',
    ],
} # End of register: TRAINING_READ_CTRL_MISC_0

registers['EMC']['register_list'].append('TRAINING_READ_CTRL_MISC_0')

# Register EMC_TRAINING_READ_VREF_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_READ_VREF_CTRL_0'] = {
    'addr'            : 0xe2c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x103f00,
    'array'           : False,
    'reset_mask'      : 0xf0ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffff,
    'write_mask'      : 0xf0ffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 63,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
    ],
} # End of register: TRAINING_READ_VREF_CTRL_0

registers['EMC']['register_list'].append('TRAINING_READ_VREF_CTRL_0')

# Register EMC_TRAINING_CA_FINE_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CA_FINE_CTRL_0'] = {
    'addr'            : 0xe30,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x11130030,
    'array'           : False,
    'reset_mask'      : 0x1fffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1fffffff,
    'write_mask'      : 0x1fffffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x30,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 48,
        },
    },
    'MAX' : {
        'lsb'               : 10,
        'msb'               : 19,
        'size'              : 10,
        'field'             : (0x3ff << 10),
        'woffset'           : 0x0,
        'default'           : 0xc0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 192,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN_SIZE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
        'STEP_LN',
        'STEP_LN_SIZE',
    ],
} # End of register: TRAINING_CA_FINE_CTRL_0

registers['EMC']['register_list'].append('TRAINING_CA_FINE_CTRL_0')

# Register EMC_TRAINING_CA_CTRL_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CA_CTRL_MISC_0'] = {
    'addr'            : 0xe34,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x1f101300,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'ERR_LIMIT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'BURST_COUNT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x3,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "FOUR",
        'enums' : {
            'FOUR' : 3,
        },
    },
    'PATTERN' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MPC",
        'enums' : {
            'FIFO' : 0,
            'MPC' : 1,
        },
    },
    'LEVEL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "BYTE",
        'enums' : {
            'BYTE' : 0,
            'BIT' : 1,
        },
    },
    'PATRAM_MIN' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x10,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PATRAM_MAX' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR_LIMIT',
        'BURST_COUNT',
        'PATTERN',
        'LEVEL',
        'PATRAM_MIN',
        'PATRAM_MAX',
    ],
} # End of register: TRAINING_CA_CTRL_MISC_0

registers['EMC']['register_list'].append('TRAINING_CA_CTRL_MISC_0')

# Register EMC_TRAINING_CA_CTRL_MISC1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CA_CTRL_MISC1_0'] = {
    'addr'            : 0xe38,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x18,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'SKIP_CNT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x18,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 24,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SKIP_CNT',
    ],
} # End of register: TRAINING_CA_CTRL_MISC1_0

registers['EMC']['register_list'].append('TRAINING_CA_CTRL_MISC1_0')

# Register EMC_TRAINING_CA_VREF_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CA_VREF_CTRL_0'] = {
    'addr'            : 0xe3c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x103200,
    'array'           : False,
    'reset_mask'      : 0xf0ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffff,
    'write_mask'      : 0xf0ffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x32,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 50,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
    ],
} # End of register: TRAINING_CA_VREF_CTRL_0

registers['EMC']['register_list'].append('TRAINING_CA_VREF_CTRL_0')

# Register EMC_TRAINING_CA_TADR_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CA_TADR_CTRL_0'] = {
    'addr'            : 0xe40,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x28000,
    'array'           : False,
    'reset_mask'      : 0x800fffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x800fffff,
    'write_mask'      : 0x800fffff,
    'TADR_SETTING' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'TADR_MAX' : {
        'lsb'               : 12,
        'msb'               : 19,
        'size'              : 8,
        'field'             : (0xff << 12),
        'woffset'           : 0x0,
        'default'           : 0x28,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 40,
        },
    },
    'TADR_ENABLE' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TADR_SETTING',
        'TADR_MAX',
        'TADR_ENABLE',
    ],
} # End of register: TRAINING_CA_TADR_CTRL_0

registers['EMC']['register_list'].append('TRAINING_CA_TADR_CTRL_0')

# Register EMC_TRAINING_SETTLE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_SETTLE_0'] = {
    'addr'            : 0xe44,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x7070404,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'LONG_TRIMMER' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SHORT_TRIMMER' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x4,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PRIV_DELAY' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'APPLY_DELAY' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'LONG_TRIMMER',
        'SHORT_TRIMMER',
        'PRIV_DELAY',
        'APPLY_DELAY',
    ],
} # End of register: TRAINING_SETTLE_0

registers['EMC']['register_list'].append('TRAINING_SETTLE_0')
# TRAINING_DEBUG_CTRL usage:
# Setting *_PASSING0 will output debug info for bit 0 to 3 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING1 will output debug info for bit 4 to 7 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING2 will output debug info for bit 8 to 11 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING3 will output debug info for bit 12 to 15 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING4 will output debug info for bit 16 to 19 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING5 will output debug info for bit 20 to 23 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING6 will output debug info for bit 24 to 27 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING7 will output debug info for bit 28 to 31 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING_DBI will output debug info for DBI of byte0 to DBI of byte3 on the DEBUG_DQ0 to DEBUG_DQ3 respectively
# Setting *_PASSING_BYTE will output debug info for byte0 to byte3 on the DEBUG_DQ0 to DEBUG_DQ3 respectively

# Register EMC_TRAINING_DEBUG_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_DEBUG_CTRL_0'] = {
    'addr'            : 0xe48,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0000ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0000ff,
    'write_mask'      : 0xf0000ff,
    'SELECT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'RANK0_CA_PASSING0' : 80,
            'RANK0_CA_PASSING1' : 81,
            'RANK0_CA_PASSING2' : 82,
            'RANK0_CA_PASSING3' : 83,
            'RANK0_CA_PASSING_BYTE' : 84,
            'RANK1_CA_PASSING0' : 85,
            'RANK1_CA_PASSING1' : 86,
            'RANK1_CA_PASSING2' : 87,
            'RANK1_CA_PASSING3' : 88,
            'RANK1_CA_PASSING_BYTE' : 89,
            'RANK0_DQ_OB_PASSING0' : 11,
            'RANK0_DQ_OB_PASSING1' : 12,
            'RANK0_DQ_OB_PASSING2' : 13,
            'RANK0_DQ_OB_PASSING3' : 14,
            'RANK0_DQ_OB_PASSING4' : 15,
            'RANK0_DQ_OB_PASSING5' : 16,
            'RANK0_DQ_OB_PASSING6' : 17,
            'RANK0_DQ_OB_PASSING7' : 18,
            'RANK0_DQ_OB_PASSING_DBI' : 19,
            'RANK0_DQ_OB_PASSING_BYTE' : 21,
            'RANK0_DQ_IB_PASSING0' : 0,
            'RANK0_DQ_IB_PASSING1' : 1,
            'RANK0_DQ_IB_PASSING2' : 2,
            'RANK0_DQ_IB_PASSING3' : 3,
            'RANK0_DQ_IB_PASSING4' : 4,
            'RANK0_DQ_IB_PASSING5' : 5,
            'RANK0_DQ_IB_PASSING6' : 6,
            'RANK0_DQ_IB_PASSING7' : 7,
            'RANK0_DQ_IB_PASSING_DBI' : 8,
            'RANK0_DQ_IB_PASSING_BYTE' : 10,
            'RANK1_DQ_OB_PASSING0' : 155,
            'RANK1_DQ_OB_PASSING1' : 156,
            'RANK1_DQ_OB_PASSING2' : 157,
            'RANK1_DQ_OB_PASSING3' : 158,
            'RANK1_DQ_OB_PASSING4' : 159,
            'RANK1_DQ_OB_PASSING5' : 160,
            'RANK1_DQ_OB_PASSING6' : 161,
            'RANK1_DQ_OB_PASSING7' : 162,
            'RANK1_DQ_OB_PASSING_DBI' : 163,
            'RANK1_DQ_OB_PASSING_BYTE' : 165,
            'RANK1_DQ_IB_PASSING0' : 144,
            'RANK1_DQ_IB_PASSING1' : 145,
            'RANK1_DQ_IB_PASSING2' : 146,
            'RANK1_DQ_IB_PASSING3' : 147,
            'RANK1_DQ_IB_PASSING4' : 148,
            'RANK1_DQ_IB_PASSING5' : 149,
            'RANK1_DQ_IB_PASSING6' : 150,
            'RANK1_DQ_IB_PASSING7' : 151,
            'RANK1_DQ_IB_PASSING_DBI' : 152,
            'RANK1_DQ_IB_PASSING_BYTE' : 154,
            'RANK0_DQ_QUSE_PASSING0' : 203,
            'RANK0_DQ_QUSE_PASSING1' : 204,
            'RANK0_DQ_QUSE_PASSING2' : 205,
            'RANK0_DQ_QUSE_PASSING3' : 206,
            'RANK0_DQ_QUSE_PASSING4' : 207,
            'RANK0_DQ_QUSE_PASSING5' : 208,
            'RANK0_DQ_QUSE_PASSING6' : 209,
            'RANK0_DQ_QUSE_PASSING7' : 210,
            'RANK0_DQ_QUSE_PASSING_DBI' : 211,
            'RANK0_DQ_QUSE_PASSING_BYTE' : 213,
            'RANK1_DQ_QUSE_PASSING0' : 176,
            'RANK1_DQ_QUSE_PASSING1' : 177,
            'RANK1_DQ_QUSE_PASSING2' : 178,
            'RANK1_DQ_QUSE_PASSING3' : 179,
            'RANK1_DQ_QUSE_PASSING4' : 180,
            'RANK1_DQ_QUSE_PASSING5' : 181,
            'RANK1_DQ_QUSE_PASSING6' : 182,
            'RANK1_DQ_QUSE_PASSING7' : 183,
            'RANK1_DQ_QUSE_PASSING_DBI' : 184,
            'RANK1_DQ_QUSE_PASSING_BYTE' : 186,
            'DQ_ERRCNT' : 96,
            'SEQUENCER' : 128,
            'INTERFACE' : 129,
            'RANK0_WR_LEVELING_PASSING0' : 224,
            'RANK0_WR_LEVELING_PASSING1' : 225,
            'RANK0_WR_LEVELING_PASSING2' : 226,
            'RANK0_WR_LEVELING_PASSING3' : 227,
            'RANK0_WR_LEVELING_PASSING4' : 228,
            'RANK1_WR_LEVELING_PASSING0' : 229,
            'RANK1_WR_LEVELING_PASSING1' : 230,
            'RANK1_WR_LEVELING_PASSING2' : 231,
            'RANK1_WR_LEVELING_PASSING3' : 232,
            'RANK1_WR_LEVELING_PASSING4' : 233,
        },
    },
    'WINDOW_LIMIT' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SELECT',
        'WINDOW_LIMIT',
    ],
} # End of register: TRAINING_DEBUG_CTRL_0

registers['EMC']['register_list'].append('TRAINING_DEBUG_CTRL_0')

# Register EMC_TRAINING_DEBUG_DQ0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_DEBUG_DQ0_0'] = {
    'addr'            : 0xe4c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0ffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffffff,
    'write_mask'      : 0x0,
    'MIN_PASSING' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'MAX_PASSING' : {
        'lsb'               : 12,
        'msb'               : 23,
        'size'              : 12,
        'field'             : (0xfff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'WINDOW_COUNT' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN_PASSING',
        'MAX_PASSING',
        'WINDOW_COUNT',
    ],
} # End of register: TRAINING_DEBUG_DQ0_0

registers['EMC']['register_list'].append('TRAINING_DEBUG_DQ0_0')

# Register EMC_TRAINING_DEBUG_DQ1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_DEBUG_DQ1_0'] = {
    'addr'            : 0xe50,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0ffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffffff,
    'write_mask'      : 0x0,
    'MIN_PASSING' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'MAX_PASSING' : {
        'lsb'               : 12,
        'msb'               : 23,
        'size'              : 12,
        'field'             : (0xfff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'WINDOW_COUNT' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN_PASSING',
        'MAX_PASSING',
        'WINDOW_COUNT',
    ],
} # End of register: TRAINING_DEBUG_DQ1_0

registers['EMC']['register_list'].append('TRAINING_DEBUG_DQ1_0')

# Register EMC_TRAINING_DEBUG_DQ2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_DEBUG_DQ2_0'] = {
    'addr'            : 0xe54,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0ffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffffff,
    'write_mask'      : 0x0,
    'MIN_PASSING' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'MAX_PASSING' : {
        'lsb'               : 12,
        'msb'               : 23,
        'size'              : 12,
        'field'             : (0xfff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'WINDOW_COUNT' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN_PASSING',
        'MAX_PASSING',
        'WINDOW_COUNT',
    ],
} # End of register: TRAINING_DEBUG_DQ2_0

registers['EMC']['register_list'].append('TRAINING_DEBUG_DQ2_0')

# Register EMC_TRAINING_DEBUG_DQ3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_DEBUG_DQ3_0'] = {
    'addr'            : 0xe58,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0ffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffffff,
    'write_mask'      : 0x0,
    'MIN_PASSING' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'MAX_PASSING' : {
        'lsb'               : 12,
        'msb'               : 23,
        'size'              : 12,
        'field'             : (0xfff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'WINDOW_COUNT' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN_PASSING',
        'MAX_PASSING',
        'WINDOW_COUNT',
    ],
} # End of register: TRAINING_DEBUG_DQ3_0

registers['EMC']['register_list'].append('TRAINING_DEBUG_DQ3_0')

# Register EMC_TRAINING_MPC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_MPC_0'] = {
    'addr'            : 0xe5c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x5053c5a,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DATA' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x3c5a,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'INVERT_PATTERN' : {
        'lsb'               : 16,
        'msb'               : 31,
        'size'              : 16,
        'field'             : (0xffff << 16),
        'woffset'           : 0x0,
        'default'           : 0x505,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA',
        'INVERT_PATTERN',
    ],
} # End of register: TRAINING_MPC_0

registers['EMC']['register_list'].append('TRAINING_MPC_0')

# Register EMC_TRAINING_PATRAM_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_PATRAM_CTRL_0'] = {
    'addr'            : 0xe60,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x800f00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x800f00ff,
    'write_mask'      : 0x800f00ff,
    'SELECT_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'FORMAT' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'WRITE' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SELECT_OFFSET',
        'FORMAT',
        'WRITE',
    ],
} # End of register: TRAINING_PATRAM_CTRL_0

registers['EMC']['register_list'].append('TRAINING_PATRAM_CTRL_0')

# Register EMC_TRAINING_PATRAM_DQ_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_PATRAM_DQ_0'] = {
    'addr'            : 0xe64,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DATA' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA',
    ],
} # End of register: TRAINING_PATRAM_DQ_0

registers['EMC']['register_list'].append('TRAINING_PATRAM_DQ_0')

# Register EMC_TRAINING_PATRAM_DMI_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_PATRAM_DMI_0'] = {
    'addr'            : 0xe68,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DATA' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA',
    ],
} # End of register: TRAINING_PATRAM_DMI_0

registers['EMC']['register_list'].append('TRAINING_PATRAM_DMI_0')

# Register EMC_TRAINING_VREF_SETTLE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_VREF_SETTLE_0'] = {
    'addr'            : 0xe6c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x7d0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x7d0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'OB' : {
        'lsb'               : 16,
        'msb'               : 31,
        'size'              : 16,
        'field'             : (0xffff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB',
        'OB',
    ],
} # End of register: TRAINING_VREF_SETTLE_0

registers['EMC']['register_list'].append('TRAINING_VREF_SETTLE_0')

# Register EMC_TRAINING_RW_EYE_CENTER_IB_BYTE0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_IB_BYTE0_0'] = {
    'addr'            : 0xe70,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_IB_BYTE0_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_IB_BYTE0_0')

# Register EMC_TRAINING_RW_EYE_CENTER_IB_BYTE1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_IB_BYTE1_0'] = {
    'addr'            : 0xe74,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_IB_BYTE1_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_IB_BYTE1_0')

# Register EMC_TRAINING_RW_EYE_CENTER_IB_BYTE2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_IB_BYTE2_0'] = {
    'addr'            : 0xe78,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_IB_BYTE2_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_IB_BYTE2_0')

# Register EMC_TRAINING_RW_EYE_CENTER_IB_BYTE3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_IB_BYTE3_0'] = {
    'addr'            : 0xe7c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_IB_BYTE3_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_IB_BYTE3_0')

# Register EMC_TRAINING_RW_EYE_CENTER_IB_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_IB_MISC_0'] = {
    'addr'            : 0xe80,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x8888,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'DBI0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DBI0',
        'DBI1',
        'DBI2',
        'DBI3',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_IB_MISC_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_IB_MISC_0')

# Register EMC_TRAINING_RW_EYE_CENTER_OB_BYTE0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_OB_BYTE0_0'] = {
    'addr'            : 0xe84,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_OB_BYTE0_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_OB_BYTE0_0')

# Register EMC_TRAINING_RW_EYE_CENTER_OB_BYTE1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_OB_BYTE1_0'] = {
    'addr'            : 0xe88,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_OB_BYTE1_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_OB_BYTE1_0')

# Register EMC_TRAINING_RW_EYE_CENTER_OB_BYTE2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_OB_BYTE2_0'] = {
    'addr'            : 0xe8c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_OB_BYTE2_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_OB_BYTE2_0')

# Register EMC_TRAINING_RW_EYE_CENTER_OB_BYTE3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_OB_BYTE3_0'] = {
    'addr'            : 0xe90,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x88888888,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_OB_BYTE3_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_OB_BYTE3_0')

# Register EMC_TRAINING_RW_EYE_CENTER_OB_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_EYE_CENTER_OB_MISC_0'] = {
    'addr'            : 0xe94,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x8888,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'DBI0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DBI0',
        'DBI1',
        'DBI2',
        'DBI3',
    ],
} # End of register: TRAINING_RW_EYE_CENTER_OB_MISC_0

registers['EMC']['register_list'].append('TRAINING_RW_EYE_CENTER_OB_MISC_0')

# Register EMC_TRAINING_RW_OFFSET_IB_BYTE0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_IB_BYTE0_0'] = {
    'addr'            : 0xe98,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_IB_BYTE0_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_IB_BYTE0_0')

# Register EMC_TRAINING_RW_OFFSET_IB_BYTE1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_IB_BYTE1_0'] = {
    'addr'            : 0xe9c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_IB_BYTE1_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_IB_BYTE1_0')

# Register EMC_TRAINING_RW_OFFSET_IB_BYTE2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_IB_BYTE2_0'] = {
    'addr'            : 0xea0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_IB_BYTE2_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_IB_BYTE2_0')

# Register EMC_TRAINING_RW_OFFSET_IB_BYTE3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_IB_BYTE3_0'] = {
    'addr'            : 0xea4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_IB_BYTE3_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_IB_BYTE3_0')

# Register EMC_TRAINING_RW_OFFSET_IB_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_IB_MISC_0'] = {
    'addr'            : 0xea8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'DBI0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DBI0',
        'DBI1',
        'DBI2',
        'DBI3',
    ],
} # End of register: TRAINING_RW_OFFSET_IB_MISC_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_IB_MISC_0')

# Register EMC_TRAINING_RW_OFFSET_OB_BYTE0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_OB_BYTE0_0'] = {
    'addr'            : 0xeac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_OB_BYTE0_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_OB_BYTE0_0')

# Register EMC_TRAINING_RW_OFFSET_OB_BYTE1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_OB_BYTE1_0'] = {
    'addr'            : 0xeb0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_OB_BYTE1_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_OB_BYTE1_0')

# Register EMC_TRAINING_RW_OFFSET_OB_BYTE2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_OB_BYTE2_0'] = {
    'addr'            : 0xeb4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_OB_BYTE2_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_OB_BYTE2_0')

# Register EMC_TRAINING_RW_OFFSET_OB_BYTE3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_OB_BYTE3_0'] = {
    'addr'            : 0xeb8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ4' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ5' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ6' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0',
        'DQ1',
        'DQ2',
        'DQ3',
        'DQ4',
        'DQ5',
        'DQ6',
        'DQ7',
    ],
} # End of register: TRAINING_RW_OFFSET_OB_BYTE3_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_OB_BYTE3_0')

# Register EMC_TRAINING_RW_OFFSET_OB_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_OFFSET_OB_MISC_0'] = {
    'addr'            : 0xebc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'DBI0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DBI3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DBI0',
        'DBI1',
        'DBI2',
        'DBI3',
    ],
} # End of register: TRAINING_RW_OFFSET_OB_MISC_0

registers['EMC']['register_list'].append('TRAINING_RW_OFFSET_OB_MISC_0')

# Register EMC_TRAINING_OPT_CA_VREF_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_CA_VREF_0'] = {
    'addr'            : 0xec0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'RANK0_SUB_PARTITION0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK0_SUB_PARTITION1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_SUB_PARTITION0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_SUB_PARTITION1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK0_SUB_PARTITION0',
        'RANK0_SUB_PARTITION1',
        'RANK1_SUB_PARTITION0',
        'RANK1_SUB_PARTITION1',
    ],
} # End of register: TRAINING_OPT_CA_VREF_0

registers['EMC']['register_list'].append('TRAINING_OPT_CA_VREF_0')

# Register EMC_TRAINING_OPT_DQ_OB_VREF_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_DQ_OB_VREF_0'] = {
    'addr'            : 0xec4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'RANK0_SUB_PARTITION0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK0_SUB_PARTITION1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_SUB_PARTITION0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_SUB_PARTITION1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK0_SUB_PARTITION0',
        'RANK0_SUB_PARTITION1',
        'RANK1_SUB_PARTITION0',
        'RANK1_SUB_PARTITION1',
    ],
} # End of register: TRAINING_OPT_DQ_OB_VREF_0

registers['EMC']['register_list'].append('TRAINING_OPT_DQ_OB_VREF_0')

# Register EMC_TRAINING_OPT_DQ_IB_VREF_RANK0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_DQ_IB_VREF_RANK0_0'] = {
    'addr'            : 0xec8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BYTE0',
        'BYTE1',
        'BYTE2',
        'BYTE3',
    ],
} # End of register: TRAINING_OPT_DQ_IB_VREF_RANK0_0

registers['EMC']['register_list'].append('TRAINING_OPT_DQ_IB_VREF_RANK0_0')

# Register EMC_TRAINING_OPT_DQ_IB_VREF_RANK1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_DQ_IB_VREF_RANK1_0'] = {
    'addr'            : 0xecc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BYTE0',
        'BYTE1',
        'BYTE2',
        'BYTE3',
    ],
} # End of register: TRAINING_OPT_DQ_IB_VREF_RANK1_0

registers['EMC']['register_list'].append('TRAINING_OPT_DQ_IB_VREF_RANK1_0')

# Register EMC_TRAINING_QUSE_VREF_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_QUSE_VREF_CTRL_0'] = {
    'addr'            : 0xed0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x103f00,
    'array'           : False,
    'reset_mask'      : 0xf0ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0ffff,
    'write_mask'      : 0xf0ffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 63,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
    ],
} # End of register: TRAINING_QUSE_VREF_CTRL_0

registers['EMC']['register_list'].append('TRAINING_QUSE_VREF_CTRL_0')

# Register EMC_TRAINING_OPT_DQS_IB_VREF_RANK0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_DQS_IB_VREF_RANK0_0'] = {
    'addr'            : 0xed4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BYTE0',
        'BYTE1',
        'BYTE2',
        'BYTE3',
    ],
} # End of register: TRAINING_OPT_DQS_IB_VREF_RANK0_0

registers['EMC']['register_list'].append('TRAINING_OPT_DQS_IB_VREF_RANK0_0')

# Register EMC_TRAINING_OPT_DQS_IB_VREF_RANK1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_DQS_IB_VREF_RANK1_0'] = {
    'addr'            : 0xed8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BYTE0',
        'BYTE1',
        'BYTE2',
        'BYTE3',
    ],
} # End of register: TRAINING_OPT_DQS_IB_VREF_RANK1_0

registers['EMC']['register_list'].append('TRAINING_OPT_DQS_IB_VREF_RANK1_0')

# Register EMC_TRAINING_DRAMC_TIMING_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_DRAMC_TIMING_0'] = {
    'addr'            : 0xedc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x19,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1ffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ffffff,
    'write_mask'      : 0x1ffffff,
    'TR_DEFAULT' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'TR_CUSTOM' : {
        'lsb'               : 10,
        'msb'               : 19,
        'size'              : 10,
        'field'             : (0x3ff << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'TR_CMD' : {
        'lsb'               : 20,
        'msb'               : 24,
        'size'              : 5,
        'field'             : (0x1f << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR_DEFAULT',
        'TR_CUSTOM',
        'TR_CMD',
    ],
} # End of register: TRAINING_DRAMC_TIMING_0

registers['EMC']['register_list'].append('TRAINING_DRAMC_TIMING_0')

# Register EMC_TRAINING_WR_LEVEL_FINE_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_LEVEL_FINE_CTRL_0'] = {
    'addr'            : 0xee0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1d,
    'reset_val'       : 0x1111fc00,
    'array'           : False,
    'reset_mask'      : 0x1fffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1fffffff,
    'write_mask'      : 0x1fffffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 10,
        'msb'               : 19,
        'size'              : 10,
        'field'             : (0x3ff << 10),
        'woffset'           : 0x0,
        'default'           : 0x7f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 127,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN_SIZE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
        'STEP_LN',
        'STEP_LN_SIZE',
    ],
} # End of register: TRAINING_WR_LEVEL_FINE_CTRL_0

registers['EMC']['register_list'].append('TRAINING_WR_LEVEL_FINE_CTRL_0')

# Register EMC_TRAINING_WR_LEVEL_CTRL_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_LEVEL_CTRL_MISC_0'] = {
    'addr'            : 0xee4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x1f101000,
    'array'           : False,
    'reset_mask'      : 0xffffff00,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffff00,
    'write_mask'      : 0xffffff00,
    'BURST_COUNT' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ONE' : 0,
            'TWO' : 1,
            'THREE' : 2,
            'FOUR' : 3,
        },
    },
    'PATTERN' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "MPC",
        'enums' : {
            'FIFO' : 0,
            'MPC' : 1,
        },
    },
    'LEVEL' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "BYTE",
        'enums' : {
            'BYTE' : 0,
            'BIT' : 1,
        },
    },
    'PATRAM_MIN' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x10,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PATRAM_MAX' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x1f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BURST_COUNT',
        'PATTERN',
        'LEVEL',
        'PATRAM_MIN',
        'PATRAM_MAX',
    ],
} # End of register: TRAINING_WR_LEVEL_CTRL_MISC_0

registers['EMC']['register_list'].append('TRAINING_WR_LEVEL_CTRL_MISC_0')

# Register EMC_TRAINING_WR_LEVEL_EYE_CENTER_OB_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_LEVEL_EYE_CENTER_OB_MISC_0'] = {
    'addr'            : 0xee8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x8888,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'DQS0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQS1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQS2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQS3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x8,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQS0',
        'DQS1',
        'DQS2',
        'DQS3',
    ],
} # End of register: TRAINING_WR_LEVEL_EYE_CENTER_OB_MISC_0

registers['EMC']['register_list'].append('TRAINING_WR_LEVEL_EYE_CENTER_OB_MISC_0')

# Register EMC_TRAINING_WR_LEVEL_OFFSET_OB_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_LEVEL_OFFSET_OB_MISC_0'] = {
    'addr'            : 0xeec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'DQS0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQS1' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQS2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQS3' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQS0',
        'DQS1',
        'DQS2',
        'DQS3',
    ],
} # End of register: TRAINING_WR_LEVEL_OFFSET_OB_MISC_0

registers['EMC']['register_list'].append('TRAINING_WR_LEVEL_OFFSET_OB_MISC_0')

# Register EMC_TRAINING_CONST_MR_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CONST_MR_0'] = {
    'addr'            : 0xef0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'MR_DATA0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MR_DATA0',
    ],
} # End of register: TRAINING_CONST_MR_0

registers['EMC']['register_list'].append('TRAINING_CONST_MR_0')

# Register EMC_TRAINING_WR_LEVEL_CTRL_MISC1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_LEVEL_CTRL_MISC1_0'] = {
    'addr'            : 0xef4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'EARLY_MIN' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'EARLY_MAX' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'LATE_MIN' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'LATE_MAX' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'EARLY_MIN',
        'EARLY_MAX',
        'LATE_MIN',
        'LATE_MAX',
    ],
} # End of register: TRAINING_WR_LEVEL_CTRL_MISC1_0

registers['EMC']['register_list'].append('TRAINING_WR_LEVEL_CTRL_MISC1_0')

# Register EMC_TRAINING_RW_PERIODIC_DDLL_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_PERIODIC_DDLL_CTRL_0'] = {
    'addr'            : 0xef8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x1010c000,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'MIN' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    'MAX' : {
        'lsb'               : 10,
        'msb'               : 19,
        'size'              : 10,
        'field'             : (0x3ff << 10),
        'woffset'           : 0x0,
        'default'           : 0x30,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 48,
        },
    },
    'STEP' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'STEP_LN' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    'CMD_CNT' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ONE",
        'enums' : {
            'ZERO' : 0,
            'ONE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MIN',
        'MAX',
        'STEP',
        'STEP_LN',
        'CMD_CNT',
    ],
} # End of register: TRAINING_RW_PERIODIC_DDLL_CTRL_0

registers['EMC']['register_list'].append('TRAINING_RW_PERIODIC_DDLL_CTRL_0')

# Register EMC_TRAINING_RW_PERIODIC_DDLL_MISC_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RW_PERIODIC_DDLL_MISC_0'] = {
    'addr'            : 0xefc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'ERR_LIMIT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "ZERO",
        'enums' : {
            'ZERO' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR_LIMIT',
    ],
} # End of register: TRAINING_RW_PERIODIC_DDLL_MISC_0

registers['EMC']['register_list'].append('TRAINING_RW_PERIODIC_DDLL_MISC_0')

# Register EMC_TRAINING_WR_LEVEL_SWEEP_FINE_CTRL0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_LEVEL_SWEEP_FINE_CTRL0_0'] = {
    'addr'            : 0xf10,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'R0_BYTE0_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'R0_BYTE1_SWEEP_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'R0_BYTE2_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'R0_BYTE3_SWEEP_OFFSET' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'R0_BYTE0_SWEEP_OFFSET',
        'R0_BYTE1_SWEEP_OFFSET',
        'R0_BYTE2_SWEEP_OFFSET',
        'R0_BYTE3_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_WR_LEVEL_SWEEP_FINE_CTRL0_0

registers['EMC']['register_list'].append('TRAINING_WR_LEVEL_SWEEP_FINE_CTRL0_0')

# Register EMC_TRAINING_WR_LEVEL_SWEEP_FINE_CTRL1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_LEVEL_SWEEP_FINE_CTRL1_0'] = {
    'addr'            : 0xf14,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'R1_BYTE0_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'R1_BYTE1_SWEEP_OFFSET' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'R1_BYTE2_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'R1_BYTE3_SWEEP_OFFSET' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'R1_BYTE0_SWEEP_OFFSET',
        'R1_BYTE1_SWEEP_OFFSET',
        'R1_BYTE2_SWEEP_OFFSET',
        'R1_BYTE3_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_WR_LEVEL_SWEEP_FINE_CTRL1_0

registers['EMC']['register_list'].append('TRAINING_WR_LEVEL_SWEEP_FINE_CTRL1_0')

# Register EMC_TRAINING_WRITE_VREF_CTRL1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WRITE_VREF_CTRL1_0'] = {
    'addr'            : 0xf20,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x2,
    'reset_val'       : 0x3,
    'array'           : False,
    'reset_mask'      : 0x3,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3,
    'write_mask'      : 0x3,
    'R0_MODE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PER_DOUBLE_BYTE",
        'enums' : {
            'PER_BYTE' : 0,
            'PER_DOUBLE_BYTE' : 1,
        },
    },
    'R1_MODE' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PER_DOUBLE_BYTE",
        'enums' : {
            'PER_BYTE' : 0,
            'PER_DOUBLE_BYTE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'R0_MODE',
        'R1_MODE',
    ],
} # End of register: TRAINING_WRITE_VREF_CTRL1_0

registers['EMC']['register_list'].append('TRAINING_WRITE_VREF_CTRL1_0')

# Register EMC_TRAINING_CA_VREF_CTRL1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_CA_VREF_CTRL1_0'] = {
    'addr'            : 0xf24,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x1,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'MODE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PER_DOUBLE_BYTE",
        'enums' : {
            'PER_BYTE' : 0,
            'PER_DOUBLE_BYTE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MODE',
    ],
} # End of register: TRAINING_CA_VREF_CTRL1_0

registers['EMC']['register_list'].append('TRAINING_CA_VREF_CTRL1_0')

# Register EMC_TRAINING_OPT_CA_VREF1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_CA_VREF1_0'] = {
    'addr'            : 0xf30,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'RANK0_SUB_PARTITION0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK0_SUB_PARTITION1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_SUB_PARTITION0_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_SUB_PARTITION1_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK0_SUB_PARTITION0_BYTE1',
        'RANK0_SUB_PARTITION1_BYTE1',
        'RANK1_SUB_PARTITION0_BYTE1',
        'RANK1_SUB_PARTITION1_BYTE1',
    ],
} # End of register: TRAINING_OPT_CA_VREF1_0

registers['EMC']['register_list'].append('TRAINING_OPT_CA_VREF1_0')

# Register EMC_TRAINING_OPT_DQ_OB_VREF1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_OPT_DQ_OB_VREF1_0'] = {
    'addr'            : 0xf34,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'RANK0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK0_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'RANK1_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RANK0_BYTE0',
        'RANK0_BYTE1',
        'RANK1_BYTE0',
        'RANK1_BYTE1',
    ],
} # End of register: TRAINING_OPT_DQ_OB_VREF1_0

registers['EMC']['register_list'].append('TRAINING_OPT_DQ_OB_VREF1_0')

# Register EMC_TRAINING_LIMIT_MOD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_LIMIT_MOD_0'] = {
    'addr'            : 0xf3c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xd,
    'reset_val'       : 0x1010,
    'array'           : False,
    'reset_mask'      : 0x103f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x103f,
    'write_mask'      : 0x103f,
    'PBDQS_ADD' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x10,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'TR_IB_BYTE_USE_MAX_PBDQS' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PBDQS_ADD',
        'TR_IB_BYTE_USE_MAX_PBDQS',
    ],
} # End of register: TRAINING_LIMIT_MOD_0

registers['EMC']['register_list'].append('TRAINING_LIMIT_MOD_0')

# Register EMC_TRAINING_WR_SWEEP_FINE_CTRL0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_SWEEP_FINE_CTRL0_0'] = {
    'addr'            : 0xf40,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'WR_R0_BYTE0_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'WR_R0_BYTE1_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WR_R0_BYTE0_SWEEP_OFFSET',
        'WR_R0_BYTE1_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_WR_SWEEP_FINE_CTRL0_0

registers['EMC']['register_list'].append('TRAINING_WR_SWEEP_FINE_CTRL0_0')

# Register EMC_TRAINING_WR_SWEEP_FINE_CTRL1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_SWEEP_FINE_CTRL1_0'] = {
    'addr'            : 0xf44,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'WR_R0_BYTE2_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'WR_R0_BYTE3_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WR_R0_BYTE2_SWEEP_OFFSET',
        'WR_R0_BYTE3_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_WR_SWEEP_FINE_CTRL1_0

registers['EMC']['register_list'].append('TRAINING_WR_SWEEP_FINE_CTRL1_0')

# Register EMC_TRAINING_WR_SWEEP_FINE_CTRL2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_SWEEP_FINE_CTRL2_0'] = {
    'addr'            : 0xf48,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'WR_R1_BYTE0_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'WR_R1_BYTE1_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WR_R1_BYTE0_SWEEP_OFFSET',
        'WR_R1_BYTE1_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_WR_SWEEP_FINE_CTRL2_0

registers['EMC']['register_list'].append('TRAINING_WR_SWEEP_FINE_CTRL2_0')

# Register EMC_TRAINING_WR_SWEEP_FINE_CTRL3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_WR_SWEEP_FINE_CTRL3_0'] = {
    'addr'            : 0xf4c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'WR_R1_BYTE2_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'WR_R1_BYTE3_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'WR_R1_BYTE2_SWEEP_OFFSET',
        'WR_R1_BYTE3_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_WR_SWEEP_FINE_CTRL3_0

registers['EMC']['register_list'].append('TRAINING_WR_SWEEP_FINE_CTRL3_0')

# Register EMC_TRAINING_RD_SWEEP_FINE_CTRL0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RD_SWEEP_FINE_CTRL0_0'] = {
    'addr'            : 0xf50,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'RD_R0_BYTE0_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'RD_R0_BYTE1_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RD_R0_BYTE0_SWEEP_OFFSET',
        'RD_R0_BYTE1_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_RD_SWEEP_FINE_CTRL0_0

registers['EMC']['register_list'].append('TRAINING_RD_SWEEP_FINE_CTRL0_0')

# Register EMC_TRAINING_RD_SWEEP_FINE_CTRL1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RD_SWEEP_FINE_CTRL1_0'] = {
    'addr'            : 0xf54,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'RD_R0_BYTE2_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'RD_R0_BYTE3_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RD_R0_BYTE2_SWEEP_OFFSET',
        'RD_R0_BYTE3_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_RD_SWEEP_FINE_CTRL1_0

registers['EMC']['register_list'].append('TRAINING_RD_SWEEP_FINE_CTRL1_0')

# Register EMC_TRAINING_RD_SWEEP_FINE_CTRL2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RD_SWEEP_FINE_CTRL2_0'] = {
    'addr'            : 0xf58,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'RD_R1_BYTE0_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'RD_R1_BYTE1_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RD_R1_BYTE0_SWEEP_OFFSET',
        'RD_R1_BYTE1_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_RD_SWEEP_FINE_CTRL2_0

registers['EMC']['register_list'].append('TRAINING_RD_SWEEP_FINE_CTRL2_0')

# Register EMC_TRAINING_RD_SWEEP_FINE_CTRL3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TRAINING_RD_SWEEP_FINE_CTRL3_0'] = {
    'addr'            : 0xf5c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ff03ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x3ff03ff,
    'RD_R1_BYTE2_SWEEP_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    'RD_R1_BYTE3_SWEEP_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "PROD",
        'enums' : {
            'PROD' : 0,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RD_R1_BYTE2_SWEEP_OFFSET',
        'RD_R1_BYTE3_SWEEP_OFFSET',
    ],
} # End of register: TRAINING_RD_SWEEP_FINE_CTRL3_0

registers['EMC']['register_list'].append('TRAINING_RD_SWEEP_FINE_CTRL3_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_QUSE_DDLL_RANK0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_QUSE_DDLL_RANK0_0_0'] = {
    'addr'            : 0x600,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'QUSE_DDLL_RANK0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_DDLL_RANK0_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE_DDLL_RANK0_BYTE0',
        'QUSE_DDLL_RANK0_BYTE1',
    ],
} # End of register: PMACRO_QUSE_DDLL_RANK0_0_0

registers['EMC']['register_list'].append('PMACRO_QUSE_DDLL_RANK0_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_QUSE_DDLL_RANK0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_QUSE_DDLL_RANK0_1_0'] = {
    'addr'            : 0x604,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'QUSE_DDLL_RANK0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_DDLL_RANK0_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE_DDLL_RANK0_BYTE2',
        'QUSE_DDLL_RANK0_BYTE3',
    ],
} # End of register: PMACRO_QUSE_DDLL_RANK0_1_0

registers['EMC']['register_list'].append('PMACRO_QUSE_DDLL_RANK0_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_QUSE_DDLL_RANK0_2           EMC_WINCR // Rank0 QUSE DDLL  value for Byte4 and Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_QUSE_DDLL_RANK0_3           EMC_WINCR // Rank0 QUSE DDLL  value for Byte6 and Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_QUSE_DDLL_RANK0_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_QUSE_DDLL_RANK0_4_0'] = {
    'addr'            : 0x610,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'QUSE_DDLL_RANK0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_DDLL_RANK0_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE_DDLL_RANK0_CMD0',
        'QUSE_DDLL_RANK0_CMD1',
    ],
} # End of register: PMACRO_QUSE_DDLL_RANK0_4_0

registers['EMC']['register_list'].append('PMACRO_QUSE_DDLL_RANK0_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_QUSE_DDLL_RANK0_5           EMC_WINCR // Rank0 CMD DDLL  value for cmd2 and cmd3
#;
#///////
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_QUSE_DDLL_RANK1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_QUSE_DDLL_RANK1_0_0'] = {
    'addr'            : 0x620,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'QUSE_DDLL_RANK1_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_DDLL_RANK1_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE_DDLL_RANK1_BYTE0',
        'QUSE_DDLL_RANK1_BYTE1',
    ],
} # End of register: PMACRO_QUSE_DDLL_RANK1_0_0

registers['EMC']['register_list'].append('PMACRO_QUSE_DDLL_RANK1_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_QUSE_DDLL_RANK1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_QUSE_DDLL_RANK1_1_0'] = {
    'addr'            : 0x624,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'QUSE_DDLL_RANK1_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_DDLL_RANK1_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE_DDLL_RANK1_BYTE2',
        'QUSE_DDLL_RANK1_BYTE3',
    ],
} # End of register: PMACRO_QUSE_DDLL_RANK1_1_0

registers['EMC']['register_list'].append('PMACRO_QUSE_DDLL_RANK1_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_QUSE_DDLL_RANK1_2           EMC_WINCR // Rank1 QUSE DDLL  value for Byte4 and Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_QUSE_DDLL_RANK1_3           EMC_WINCR // Rank1 QUSE DDLL  value for Byte6 and Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_QUSE_DDLL_RANK1_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_QUSE_DDLL_RANK1_4_0'] = {
    'addr'            : 0x630,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'QUSE_DDLL_RANK1_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'QUSE_DDLL_RANK1_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'QUSE_DDLL_RANK1_CMD0',
        'QUSE_DDLL_RANK1_CMD1',
    ],
} # End of register: PMACRO_QUSE_DDLL_RANK1_4_0

registers['EMC']['register_list'].append('PMACRO_QUSE_DDLL_RANK1_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_QUSE_DDLL_RANK1_5           EMC_WINCR // Rank1 CMD DDLL  value for cmd2 and cmd3
#;
#//////////
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK0_0_0'] = {
    'addr'            : 0x640,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQ_RANK0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQ_RANK0_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK0_BYTE0',
        'OB_DDLL_LONG_DQ_RANK0_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK0_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK0_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK0_1_0'] = {
    'addr'            : 0x644,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQ_RANK0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQ_RANK0_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK0_BYTE2',
        'OB_DDLL_LONG_DQ_RANK0_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK0_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK0_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQ_RANK0_2           EMC_WINCR // Rank0 OB  Long DQ DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQ_RANK0_3           EMC_WINCR // Rank0 OB  Long DQ DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK0_4_0'] = {
    'addr'            : 0x650,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff,
    'write_mask'      : 0x7ff,
    'OB_DDLL_LONG_DQ_RANK0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK0_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK0_4_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK0_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK0_5_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK0_5_0'] = {
    'addr'            : 0x654,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff,
    'write_mask'      : 0x7ff,
    'OB_DDLL_LONG_DQ_RANK0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK0_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK0_5_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK0_5_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK1_0_0'] = {
    'addr'            : 0x660,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQ_RANK1_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQ_RANK1_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK1_BYTE0',
        'OB_DDLL_LONG_DQ_RANK1_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK1_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK1_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK1_1_0'] = {
    'addr'            : 0x664,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQ_RANK1_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQ_RANK1_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK1_BYTE2',
        'OB_DDLL_LONG_DQ_RANK1_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK1_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK1_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQ_RANK1_2           EMC_WINCR // Rank1 OB  Long DQ DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQ_RANK1_3           EMC_WINCR // Rank1 OB  Long DQ DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK1_4_0'] = {
    'addr'            : 0x670,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff,
    'write_mask'      : 0x7ff,
    'OB_DDLL_LONG_DQ_RANK1_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK1_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK1_4_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK1_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQ_RANK1_5_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQ_RANK1_5_0'] = {
    'addr'            : 0x674,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff,
    'write_mask'      : 0x7ff,
    'OB_DDLL_LONG_DQ_RANK1_CMD1' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQ_RANK1_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQ_RANK1_5_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQ_RANK1_5_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQS_RANK0_0_0'] = {
    'addr'            : 0x680,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQS_RANK0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQS_RANK0_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQS_RANK0_BYTE0',
        'OB_DDLL_LONG_DQS_RANK0_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQS_RANK0_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQS_RANK0_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQS_RANK0_1_0'] = {
    'addr'            : 0x684,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQS_RANK0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQS_RANK0_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQS_RANK0_BYTE2',
        'OB_DDLL_LONG_DQS_RANK0_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQS_RANK0_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQS_RANK0_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQS_RANK0_2           EMC_WINCR // Rank0 OB  Long DQS DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQS_RANK0_3           EMC_WINCR // Rank0 OB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQS_RANK0_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQS_RANK0_4_0'] = {
    'addr'            : 0x690,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQS_RANK0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQS_RANK0_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQS_RANK0_CMD0',
        'OB_DDLL_LONG_DQS_RANK0_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQS_RANK0_4_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQS_RANK0_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQS_RANK0_5           EMC_WINCR // Rank0 OB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQS_RANK1_0_0'] = {
    'addr'            : 0x6a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQS_RANK1_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQS_RANK1_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQS_RANK1_BYTE0',
        'OB_DDLL_LONG_DQS_RANK1_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQS_RANK1_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQS_RANK1_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQS_RANK1_1_0'] = {
    'addr'            : 0x6a4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQS_RANK1_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQS_RANK1_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQS_RANK1_BYTE2',
        'OB_DDLL_LONG_DQS_RANK1_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQS_RANK1_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQS_RANK1_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQS_RANK1_2           EMC_WINCR // Rank1 OB  Long DQS DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_DQS_RANK1_3           EMC_WINCR // Rank1 OB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_DQS_RANK1_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_DQS_RANK1_4_0'] = {
    'addr'            : 0x6b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_DQS_RANK1_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_DQS_RANK1_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_DQS_RANK1_CMD0',
        'OB_DDLL_LONG_DQS_RANK1_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_DQS_RANK1_4_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_DQS_RANK1_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#offset 0x6B4;
#reg   PMACRO_OB_DDLL_LONG_DQS_RANK1_5           EMC_WINCR // Rank1 OB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.


####  Gil Jung for WCK

# Register EMC_PMACRO_OB_DDLL_LONG_WCK_RANK0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_WCK_RANK0_0_0'] = {
    'addr'            : 0x680,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_WCK_RANK0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_WCK_RANK0_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_WCK_RANK0_BYTE0',
        'OB_DDLL_LONG_WCK_RANK0_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_WCK_RANK0_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_WCK_RANK0_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_WCK_RANK0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_WCK_RANK0_1_0'] = {
    'addr'            : 0x684,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_WCK_RANK0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_WCK_RANK0_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_WCK_RANK0_BYTE2',
        'OB_DDLL_LONG_WCK_RANK0_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_WCK_RANK0_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_WCK_RANK0_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_WCK_RANK0_2           EMC_WINCR // Rank0 OB  Long WCK DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_WCK_RANK0_3           EMC_WINCR // Rank0 OB  Long WCK DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_WCK_RANK0_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_WCK_RANK0_4_0'] = {
    'addr'            : 0x690,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_WCK_RANK0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_WCK_RANK0_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_WCK_RANK0_CMD0',
        'OB_DDLL_LONG_WCK_RANK0_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_WCK_RANK0_4_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_WCK_RANK0_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_WCK_RANK0_5           EMC_WINCR // Rank0 OB  Long WCK DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_WCK_RANK1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_WCK_RANK1_0_0'] = {
    'addr'            : 0x6a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_WCK_RANK1_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_WCK_RANK1_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_WCK_RANK1_BYTE0',
        'OB_DDLL_LONG_WCK_RANK1_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_WCK_RANK1_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_WCK_RANK1_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_WCK_RANK1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_WCK_RANK1_1_0'] = {
    'addr'            : 0x6a4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_WCK_RANK1_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_WCK_RANK1_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_WCK_RANK1_BYTE2',
        'OB_DDLL_LONG_WCK_RANK1_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_WCK_RANK1_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_WCK_RANK1_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_WCK_RANK1_2           EMC_WINCR // Rank1 OB  Long WCK DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_OB_DDLL_LONG_WCK_RANK1_3           EMC_WINCR // Rank1 OB  Long WCK DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_OB_DDLL_LONG_WCK_RANK1_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_LONG_WCK_RANK1_4_0'] = {
    'addr'            : 0x6b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'OB_DDLL_LONG_WCK_RANK1_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_LONG_WCK_RANK1_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_LONG_WCK_RANK1_CMD0',
        'OB_DDLL_LONG_WCK_RANK1_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_LONG_WCK_RANK1_4_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_LONG_WCK_RANK1_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#offset 0x6B4;
#reg   PMACRO_OB_DDLL_LONG_WCK_RANK1_5           EMC_WINCR // Rank1 OB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

####  Gil Jung for WCK_END


# Register EMC_PMACRO_IB_DDLL_LONG_DQS_RANK0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_LONG_DQS_RANK0_0_0'] = {
    'addr'            : 0x6c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'IB_DDLL_LONG_DQS_RANK0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_LONG_DQS_RANK0_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_LONG_DQS_RANK0_BYTE0',
        'IB_DDLL_LONG_DQS_RANK0_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_LONG_DQS_RANK0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_LONG_DQS_RANK0_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_DDLL_LONG_DQS_RANK0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_LONG_DQS_RANK0_1_0'] = {
    'addr'            : 0x6c4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'IB_DDLL_LONG_DQS_RANK0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_LONG_DQS_RANK0_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_LONG_DQS_RANK0_BYTE2',
        'IB_DDLL_LONG_DQS_RANK0_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_LONG_DQS_RANK0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_LONG_DQS_RANK0_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_IB_DDLL_LONG_DQS_RANK0_2           EMC_WINCR // Rank0 IB  Long DQS DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_IB_DDLL_LONG_DQS_RANK0_3           EMC_WINCR // Rank0 IB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_LONG_DQS_RANK0_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_LONG_DQS_RANK0_4_0'] = {
    'addr'            : 0x6d0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'IB_DDLL_LONG_DQS_RANK0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_LONG_DQS_RANK0_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_LONG_DQS_RANK0_CMD0',
        'IB_DDLL_LONG_DQS_RANK0_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_LONG_DQS_RANK0_4_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_LONG_DQS_RANK0_4_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_LONG_DQS_RANK0_5           EMC_WINCR // Rank0 IB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_DDLL_LONG_DQS_RANK1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_LONG_DQS_RANK1_0_0'] = {
    'addr'            : 0x6e0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'IB_DDLL_LONG_DQS_RANK1_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_LONG_DQS_RANK1_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_LONG_DQS_RANK1_BYTE0',
        'IB_DDLL_LONG_DQS_RANK1_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_LONG_DQS_RANK1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_LONG_DQS_RANK1_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_DDLL_LONG_DQS_RANK1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_LONG_DQS_RANK1_1_0'] = {
    'addr'            : 0x6e4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'IB_DDLL_LONG_DQS_RANK1_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_LONG_DQS_RANK1_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_LONG_DQS_RANK1_BYTE2',
        'IB_DDLL_LONG_DQS_RANK1_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_LONG_DQS_RANK1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_LONG_DQS_RANK1_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_IB_DDLL_LONG_DQS_RANK1_2           EMC_WINCR // Rank1 IB  Long DQS DDLL value for Byte4 and  Byte5
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_IB_DDLL_LONG_DQS_RANK1_3           EMC_WINCR // Rank1 IB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_LONG_DQS_RANK1_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_LONG_DQS_RANK1_4_0'] = {
    'addr'            : 0x6f0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x200020,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'IB_DDLL_LONG_DQS_RANK1_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_LONG_DQS_RANK1_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x20,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_LONG_DQS_RANK1_CMD0',
        'IB_DDLL_LONG_DQS_RANK1_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_LONG_DQS_RANK1_4_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_LONG_DQS_RANK1_4_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_LONG_DQS_RANK1_5           EMC_WINCR // Rank1 IB  Long DQS DDLL value for Byte6 and  Byte7
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_TX_PWRD_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TX_PWRD_0_0'] = {
    'addr'            : 0x720,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x37ff37ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x37ff37ff,
    'write_mask'      : 0x37ff37ff,
    'DQ0_TX_PWRD_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_PWRD_BYTE0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_PWRD_BYTE0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_PWRD_BYTE0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_PWRD_BYTE0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_PWRD_BYTE0' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_PWRD_BYTE0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_PWRD_BYTE0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_PWRD_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_PWRD_BYTE0' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_PWRD_BYTE0' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPU_BYTE0' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPD_BYTE0' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_PWRD_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_PWRD_BYTE1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_PWRD_BYTE1' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_PWRD_BYTE1' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_PWRD_BYTE1' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_PWRD_BYTE1' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_PWRD_BYTE1' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_PWRD_BYTE1' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_PWRD_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_PWRD_BYTE1' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_PWRD_BYTE1' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPU_BYTE1' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPD_BYTE1' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_PWRD_BYTE0',
        'DQ1_TX_PWRD_BYTE0',
        'DQ2_TX_PWRD_BYTE0',
        'DQ3_TX_PWRD_BYTE0',
        'DQ4_TX_PWRD_BYTE0',
        'DQ5_TX_PWRD_BYTE0',
        'DQ6_TX_PWRD_BYTE0',
        'DQ7_TX_PWRD_BYTE0',
        'DQ8_TX_PWRD_BYTE0',
        'DQSP_TX_PWRD_BYTE0',
        'DQSN_TX_PWRD_BYTE0',
        'CMD_TX_E_WKPU_BYTE0',
        'CMD_TX_E_WKPD_BYTE0',
        'DQ0_TX_PWRD_BYTE1',
        'DQ1_TX_PWRD_BYTE1',
        'DQ2_TX_PWRD_BYTE1',
        'DQ3_TX_PWRD_BYTE1',
        'DQ4_TX_PWRD_BYTE1',
        'DQ5_TX_PWRD_BYTE1',
        'DQ6_TX_PWRD_BYTE1',
        'DQ7_TX_PWRD_BYTE1',
        'DQ8_TX_PWRD_BYTE1',
        'DQSP_TX_PWRD_BYTE1',
        'DQSN_TX_PWRD_BYTE1',
        'CMD_TX_E_WKPU_BYTE1',
        'CMD_TX_E_WKPD_BYTE1',
    ],
} # End of register: PMACRO_TX_PWRD_0_0

registers['EMC']['register_list'].append('PMACRO_TX_PWRD_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_TX_PWRD_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TX_PWRD_1_0'] = {
    'addr'            : 0x724,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x37ff37ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x37ff37ff,
    'write_mask'      : 0x37ff37ff,
    'DQ0_TX_PWRD_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_PWRD_BYTE2' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_PWRD_BYTE2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_PWRD_BYTE2' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_PWRD_BYTE2' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_PWRD_BYTE2' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_PWRD_BYTE2' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_PWRD_BYTE2' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_PWRD_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_PWRD_BYTE2' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_PWRD_BYTE2' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPU_BYTE2' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPD_BYTE2' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_PWRD_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_PWRD_BYTE3' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_PWRD_BYTE3' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_PWRD_BYTE3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_PWRD_BYTE3' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_PWRD_BYTE3' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_PWRD_BYTE3' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_PWRD_BYTE3' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_PWRD_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_PWRD_BYTE3' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_PWRD_BYTE3' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPU_BYTE3' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPD_BYTE3' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_PWRD_BYTE2',
        'DQ1_TX_PWRD_BYTE2',
        'DQ2_TX_PWRD_BYTE2',
        'DQ3_TX_PWRD_BYTE2',
        'DQ4_TX_PWRD_BYTE2',
        'DQ5_TX_PWRD_BYTE2',
        'DQ6_TX_PWRD_BYTE2',
        'DQ7_TX_PWRD_BYTE2',
        'DQ8_TX_PWRD_BYTE2',
        'DQSP_TX_PWRD_BYTE2',
        'DQSN_TX_PWRD_BYTE2',
        'CMD_TX_E_WKPU_BYTE2',
        'CMD_TX_E_WKPD_BYTE2',
        'DQ0_TX_PWRD_BYTE3',
        'DQ1_TX_PWRD_BYTE3',
        'DQ2_TX_PWRD_BYTE3',
        'DQ3_TX_PWRD_BYTE3',
        'DQ4_TX_PWRD_BYTE3',
        'DQ5_TX_PWRD_BYTE3',
        'DQ6_TX_PWRD_BYTE3',
        'DQ7_TX_PWRD_BYTE3',
        'DQ8_TX_PWRD_BYTE3',
        'DQSP_TX_PWRD_BYTE3',
        'DQSN_TX_PWRD_BYTE3',
        'CMD_TX_E_WKPU_BYTE3',
        'CMD_TX_E_WKPD_BYTE3',
    ],
} # End of register: PMACRO_TX_PWRD_1_0

registers['EMC']['register_list'].append('PMACRO_TX_PWRD_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_TX_PWRD_2           EMC_WINCR // clock gate reg for unused TX bits in byte5 and byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_TX_PWRD_3           EMC_WINCR // clock gate reg for unused TX bits in byte6 and byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_TX_PWRD_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TX_PWRD_4_0'] = {
    'addr'            : 0x730,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x37ff37ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x37ff37ff,
    'write_mask'      : 0x37ff37ff,
    'DQ0_TX_PWRD_CMD0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_PWRD_CMD0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_PWRD_CMD0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_PWRD_CMD0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_PWRD_CMD0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_PWRD_CMD0' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_PWRD_CMD0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_PWRD_CMD0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_PWRD_CMD0' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_PWRD_CMD0' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_PWRD_CMD0' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPU_CMD0' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPD_CMD0' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_PWRD_CMD1' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_PWRD_CMD1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_PWRD_CMD1' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_PWRD_CMD1' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_PWRD_CMD1' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_PWRD_CMD1' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_PWRD_CMD1' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_PWRD_CMD1' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_PWRD_CMD1' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_PWRD_CMD1' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_PWRD_CMD1' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPU_CMD1' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_E_WKPD_CMD1' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_PWRD_CMD0',
        'DQ1_TX_PWRD_CMD0',
        'DQ2_TX_PWRD_CMD0',
        'DQ3_TX_PWRD_CMD0',
        'DQ4_TX_PWRD_CMD0',
        'DQ5_TX_PWRD_CMD0',
        'DQ6_TX_PWRD_CMD0',
        'DQ7_TX_PWRD_CMD0',
        'DQ8_TX_PWRD_CMD0',
        'DQSP_TX_PWRD_CMD0',
        'DQSN_TX_PWRD_CMD0',
        'CMD_TX_E_WKPU_CMD0',
        'CMD_TX_E_WKPD_CMD0',
        'DQ0_TX_PWRD_CMD1',
        'DQ1_TX_PWRD_CMD1',
        'DQ2_TX_PWRD_CMD1',
        'DQ3_TX_PWRD_CMD1',
        'DQ4_TX_PWRD_CMD1',
        'DQ5_TX_PWRD_CMD1',
        'DQ6_TX_PWRD_CMD1',
        'DQ7_TX_PWRD_CMD1',
        'DQ8_TX_PWRD_CMD1',
        'DQSP_TX_PWRD_CMD1',
        'DQSN_TX_PWRD_CMD1',
        'CMD_TX_E_WKPU_CMD1',
        'CMD_TX_E_WKPD_CMD1',
    ],
} # End of register: PMACRO_TX_PWRD_4_0

registers['EMC']['register_list'].append('PMACRO_TX_PWRD_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_TX_PWRD_5           EMC_WINCR // clock gate reg for unused TX bits in cmd2 and cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_TX_SEL_CLK_SRC_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TX_SEL_CLK_SRC_0_0'] = {
    'addr'            : 0x740,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DQ0_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_SEL_CLK_SRC_BYTE0' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_SEL_CLK_SRC_BYTE1' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_SEL_CLK_SRC_BYTE0',
        'DQ1_TX_SEL_CLK_SRC_BYTE0',
        'DQ2_TX_SEL_CLK_SRC_BYTE0',
        'DQ3_TX_SEL_CLK_SRC_BYTE0',
        'DQ4_TX_SEL_CLK_SRC_BYTE0',
        'DQ5_TX_SEL_CLK_SRC_BYTE0',
        'DQ6_TX_SEL_CLK_SRC_BYTE0',
        'DQ7_TX_SEL_CLK_SRC_BYTE0',
        'DQ8_TX_SEL_CLK_SRC_BYTE0',
        'DQSP_TX_SEL_CLK_SRC_BYTE0',
        'DQSN_TX_SEL_CLK_SRC_BYTE0',
        'DQ0_TX_SEL_CLK_SRC_BYTE1',
        'DQ1_TX_SEL_CLK_SRC_BYTE1',
        'DQ2_TX_SEL_CLK_SRC_BYTE1',
        'DQ3_TX_SEL_CLK_SRC_BYTE1',
        'DQ4_TX_SEL_CLK_SRC_BYTE1',
        'DQ5_TX_SEL_CLK_SRC_BYTE1',
        'DQ6_TX_SEL_CLK_SRC_BYTE1',
        'DQ7_TX_SEL_CLK_SRC_BYTE1',
        'DQ8_TX_SEL_CLK_SRC_BYTE1',
        'DQSP_TX_SEL_CLK_SRC_BYTE1',
        'DQSN_TX_SEL_CLK_SRC_BYTE1',
    ],
} # End of register: PMACRO_TX_SEL_CLK_SRC_0_0

registers['EMC']['register_list'].append('PMACRO_TX_SEL_CLK_SRC_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_TX_SEL_CLK_SRC_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TX_SEL_CLK_SRC_1_0'] = {
    'addr'            : 0x744,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DQ0_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_SEL_CLK_SRC_BYTE2' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_SEL_CLK_SRC_BYTE3' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_SEL_CLK_SRC_BYTE2',
        'DQ1_TX_SEL_CLK_SRC_BYTE2',
        'DQ2_TX_SEL_CLK_SRC_BYTE2',
        'DQ3_TX_SEL_CLK_SRC_BYTE2',
        'DQ4_TX_SEL_CLK_SRC_BYTE2',
        'DQ5_TX_SEL_CLK_SRC_BYTE2',
        'DQ6_TX_SEL_CLK_SRC_BYTE2',
        'DQ7_TX_SEL_CLK_SRC_BYTE2',
        'DQ8_TX_SEL_CLK_SRC_BYTE2',
        'DQSP_TX_SEL_CLK_SRC_BYTE2',
        'DQSN_TX_SEL_CLK_SRC_BYTE2',
        'DQ0_TX_SEL_CLK_SRC_BYTE3',
        'DQ1_TX_SEL_CLK_SRC_BYTE3',
        'DQ2_TX_SEL_CLK_SRC_BYTE3',
        'DQ3_TX_SEL_CLK_SRC_BYTE3',
        'DQ4_TX_SEL_CLK_SRC_BYTE3',
        'DQ5_TX_SEL_CLK_SRC_BYTE3',
        'DQ6_TX_SEL_CLK_SRC_BYTE3',
        'DQ7_TX_SEL_CLK_SRC_BYTE3',
        'DQ8_TX_SEL_CLK_SRC_BYTE3',
        'DQSP_TX_SEL_CLK_SRC_BYTE3',
        'DQSN_TX_SEL_CLK_SRC_BYTE3',
    ],
} # End of register: PMACRO_TX_SEL_CLK_SRC_1_0

registers['EMC']['register_list'].append('PMACRO_TX_SEL_CLK_SRC_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_TX_SEL_CLK_SRC_3           EMC_WINCR // Select clock source for 0.5T and 1.0T when brick is configured as ADDR/CMD brick
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_TX_SEL_CLK_SRC_2           EMC_WINCR // Select clock source for 0.5T and 1.0T when brick is configured as ADDR/CMD brick
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_TX_SEL_CLK_SRC_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TX_SEL_CLK_SRC_4_0'] = {
    'addr'            : 0x750,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DQ0_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_SEL_CLK_SRC_CMD0' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_SEL_CLK_SRC_CMD1' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_SEL_CLK_SRC_CMD0',
        'DQ1_TX_SEL_CLK_SRC_CMD0',
        'DQ2_TX_SEL_CLK_SRC_CMD0',
        'DQ3_TX_SEL_CLK_SRC_CMD0',
        'DQ4_TX_SEL_CLK_SRC_CMD0',
        'DQ5_TX_SEL_CLK_SRC_CMD0',
        'DQ6_TX_SEL_CLK_SRC_CMD0',
        'DQ7_TX_SEL_CLK_SRC_CMD0',
        'DQ8_TX_SEL_CLK_SRC_CMD0',
        'DQSP_TX_SEL_CLK_SRC_CMD0',
        'DQSN_TX_SEL_CLK_SRC_CMD0',
        'DQ0_TX_SEL_CLK_SRC_CMD1',
        'DQ1_TX_SEL_CLK_SRC_CMD1',
        'DQ2_TX_SEL_CLK_SRC_CMD1',
        'DQ3_TX_SEL_CLK_SRC_CMD1',
        'DQ4_TX_SEL_CLK_SRC_CMD1',
        'DQ5_TX_SEL_CLK_SRC_CMD1',
        'DQ6_TX_SEL_CLK_SRC_CMD1',
        'DQ7_TX_SEL_CLK_SRC_CMD1',
        'DQ8_TX_SEL_CLK_SRC_CMD1',
        'DQSP_TX_SEL_CLK_SRC_CMD1',
        'DQSN_TX_SEL_CLK_SRC_CMD1',
    ],
} # End of register: PMACRO_TX_SEL_CLK_SRC_4_0

registers['EMC']['register_list'].append('PMACRO_TX_SEL_CLK_SRC_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_TX_SEL_CLK_SRC_5           EMC_WINCR // Select clock source for 0.5T and 1.0T when brick is configured as ADDR/CMD brick
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_BYPASS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_BYPASS_0'] = {
    'addr'            : 0x760,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xef07ef01,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xef07ef01,
    'write_mask'      : 0xef07ef01,
    'DATA_USE_PMACRO_BRLSHFT' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BYTE_TXDQ_BYPASS' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BYTE_TXDQS_BYPASS' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BYTE_RXDQS_BYPASS' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BYTE_QU_BYPASS' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BIT_TXDQS_BYPASS' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BIT_TXDQ_BYPASS' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BIT_RXDQ_BYPASS' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLLCAL_BIT_RXDQS_BYPASS' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BIT_RXDQS_BYPASS' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_USE_PMACRO_BRLSHFT' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BYTE_TXDQ_BYPASS' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BYTE_TXDQS_BYPASS' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BYTE_RXDQS_BYPASS' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BYTE_QU_BYPASS' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BIT_TXDQS_BYPASS' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BIT_TXDQ_BYPASS' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLLCAL_BIT_RXDQ_BYPASS' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA_USE_PMACRO_BRLSHFT',
        'DATA_DDLLCAL_BYTE_TXDQ_BYPASS',
        'DATA_DDLLCAL_BYTE_TXDQS_BYPASS',
        'DATA_DDLLCAL_BYTE_RXDQS_BYPASS',
        'DATA_DDLLCAL_BYTE_QU_BYPASS',
        'DATA_DDLLCAL_BIT_TXDQS_BYPASS',
        'DATA_DDLLCAL_BIT_TXDQ_BYPASS',
        'DATA_DDLLCAL_BIT_RXDQ_BYPASS',
        'DATA_DDLLCAL_BIT_RXDQS_BYPASS',
        'CMD_DDLLCAL_BIT_RXDQS_BYPASS',
        'CMD_USE_PMACRO_BRLSHFT',
        'CMD_DDLLCAL_BYTE_TXDQ_BYPASS',
        'CMD_DDLLCAL_BYTE_TXDQS_BYPASS',
        'CMD_DDLLCAL_BYTE_RXDQS_BYPASS',
        'CMD_DDLLCAL_BYTE_QU_BYPASS',
        'CMD_DDLLCAL_BIT_TXDQS_BYPASS',
        'CMD_DDLLCAL_BIT_TXDQ_BYPASS',
        'CMD_DDLLCAL_BIT_RXDQ_BYPASS',
    ],
} # End of register: PMACRO_DDLL_BYPASS_0

registers['EMC']['register_list'].append('PMACRO_DDLL_BYPASS_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_PWRD_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_PWRD_0_0'] = {
    'addr'            : 0x770,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xdededede,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xdededede,
    'write_mask'      : 0xdededede,
    'DDLL_BYTE_TXDQS_PWRD_BYTE0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXDQS_PWRD_BYTE0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_QU_PWRD_BYTE0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXRT_PWRD_BYTE0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_TXDQ_PWRD_BYTE0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_RXDQ_PWRD_BYTE0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_TXDQS_PWRD_BYTE1' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXDQS_PWRD_BYTE1' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_QU_PWRD_BYTE1' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXRT_PWRD_BYTE1' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_TXDQ_PWRD_BYTE1' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_RXDQ_PWRD_BYTE1' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_TXDQS_PWRD_BYTE2' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXDQS_PWRD_BYTE2' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_QU_PWRD_BYTE2' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXRT_PWRD_BYTE2' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_TXDQ_PWRD_BYTE2' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_RXDQ_PWRD_BYTE2' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_TXDQS_PWRD_BYTE3' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXDQS_PWRD_BYTE3' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_QU_PWRD_BYTE3' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXRT_PWRD_BYTE3' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_TXDQ_PWRD_BYTE3' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_RXDQ_PWRD_BYTE3' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_BYTE_TXDQS_PWRD_BYTE0',
        'DDLL_BYTE_RXDQS_PWRD_BYTE0',
        'DDLL_BYTE_QU_PWRD_BYTE0',
        'DDLL_BYTE_RXRT_PWRD_BYTE0',
        'DDLL_BIT_TXDQ_PWRD_BYTE0',
        'DDLL_BIT_RXDQ_PWRD_BYTE0',
        'DDLL_BYTE_TXDQS_PWRD_BYTE1',
        'DDLL_BYTE_RXDQS_PWRD_BYTE1',
        'DDLL_BYTE_QU_PWRD_BYTE1',
        'DDLL_BYTE_RXRT_PWRD_BYTE1',
        'DDLL_BIT_TXDQ_PWRD_BYTE1',
        'DDLL_BIT_RXDQ_PWRD_BYTE1',
        'DDLL_BYTE_TXDQS_PWRD_BYTE2',
        'DDLL_BYTE_RXDQS_PWRD_BYTE2',
        'DDLL_BYTE_QU_PWRD_BYTE2',
        'DDLL_BYTE_RXRT_PWRD_BYTE2',
        'DDLL_BIT_TXDQ_PWRD_BYTE2',
        'DDLL_BIT_RXDQ_PWRD_BYTE2',
        'DDLL_BYTE_TXDQS_PWRD_BYTE3',
        'DDLL_BYTE_RXDQS_PWRD_BYTE3',
        'DDLL_BYTE_QU_PWRD_BYTE3',
        'DDLL_BYTE_RXRT_PWRD_BYTE3',
        'DDLL_BIT_TXDQ_PWRD_BYTE3',
        'DDLL_BIT_RXDQ_PWRD_BYTE3',
    ],
} # End of register: PMACRO_DDLL_PWRD_0_0

registers['EMC']['register_list'].append('PMACRO_DDLL_PWRD_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
#reg   PMACRO_DDLL_PWRD_1                  EMC_WINCR // DLL  power down mode enables
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_PWRD_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_PWRD_2_0'] = {
    'addr'            : 0x778,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xf,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xdede,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xdede,
    'write_mask'      : 0xdede,
    'DDLL_BYTE_TXDQS_PWRD_CMD0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXDQS_PWRD_CMD0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_QU_PWRD_CMD0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXRT_PWRD_CMD0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_TXDQ_PWRD_CMD0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_RXDQ_PWRD_CMD0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_TXDQS_PWRD_CMD1' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXDQS_PWRD_CMD1' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_QU_PWRD_CMD1' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BYTE_RXRT_PWRD_CMD1' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_TXDQ_PWRD_CMD1' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_BIT_RXDQ_PWRD_CMD1' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_BYTE_TXDQS_PWRD_CMD0',
        'DDLL_BYTE_RXDQS_PWRD_CMD0',
        'DDLL_BYTE_QU_PWRD_CMD0',
        'DDLL_BYTE_RXRT_PWRD_CMD0',
        'DDLL_BIT_TXDQ_PWRD_CMD0',
        'DDLL_BIT_RXDQ_PWRD_CMD0',
        'DDLL_BYTE_TXDQS_PWRD_CMD1',
        'DDLL_BYTE_RXDQS_PWRD_CMD1',
        'DDLL_BYTE_QU_PWRD_CMD1',
        'DDLL_BYTE_RXRT_PWRD_CMD1',
        'DDLL_BIT_TXDQ_PWRD_CMD1',
        'DDLL_BIT_RXDQ_PWRD_CMD1',
    ],
} # End of register: PMACRO_DDLL_PWRD_2_0

registers['EMC']['register_list'].append('PMACRO_DDLL_PWRD_2_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CMD_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_CTRL_0_0'] = {
    'addr'            : 0x780,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x31313131,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x31313131,
    'write_mask'      : 0x31313131,
    'CMD_E_INPUT_CKE0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE0' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_CKE1' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE1' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE1' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_CKE2' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE2' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE2' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_CKE3' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE3' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE3' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_E_INPUT_CKE0',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE0',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE0',
        'CMD_E_INPUT_CKE1',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE1',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE1',
        'CMD_E_INPUT_CKE2',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE2',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE2',
        'CMD_E_INPUT_CKE3',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE3',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE3',
    ],
} # End of register: PMACRO_CMD_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_CMD_CTRL_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CMD_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_CTRL_1_0'] = {
    'addr'            : 0x784,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x31313131,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x31313131,
    'write_mask'      : 0x31313131,
    'CMD_E_INPUT_CKE4' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE4' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_CKE5' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE5' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE5' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_CKE6' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE6' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE6' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_CKE7' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_CKE7' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_CKE7' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_E_INPUT_CKE4',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE4',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE4',
        'CMD_E_INPUT_CKE5',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE5',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE5',
        'CMD_E_INPUT_CKE6',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE6',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE6',
        'CMD_E_INPUT_CKE7',
        'DDLLCAL_BIT_TXCMD_BYPASS_CKE7',
        'DDLLCAL_BYTE_TXCMD_BYPASS_CKE7',
    ],
} # End of register: PMACRO_CMD_CTRL_1_0

registers['EMC']['register_list'].append('PMACRO_CMD_CTRL_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CMD_CTRL_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_CTRL_2_0'] = {
    'addr'            : 0x788,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x31313131,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x31313131,
    'write_mask'      : 0x31313131,
    'CMD_E_INPUT_RESET' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_RESET' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_RESET' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_MISC0' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_MISC0' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_MISC0' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_MISC1' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_MISC1' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_MISC1' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_INPUT_MISC2' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BIT_TXCMD_BYPASS_MISC2' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_BYTE_TXCMD_BYPASS_MISC2' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_E_INPUT_RESET',
        'DDLLCAL_BIT_TXCMD_BYPASS_RESET',
        'DDLLCAL_BYTE_TXCMD_BYPASS_RESET',
        'CMD_E_INPUT_MISC0',
        'DDLLCAL_BIT_TXCMD_BYPASS_MISC0',
        'DDLLCAL_BYTE_TXCMD_BYPASS_MISC0',
        'CMD_E_INPUT_MISC1',
        'DDLLCAL_BIT_TXCMD_BYPASS_MISC1',
        'DDLLCAL_BYTE_TXCMD_BYPASS_MISC1',
        'CMD_E_INPUT_MISC2',
        'DDLLCAL_BIT_TXCMD_BYPASS_MISC2',
        'DDLLCAL_BYTE_TXCMD_BYPASS_MISC2',
    ],
} # End of register: PMACRO_CMD_CTRL_2_0

registers['EMC']['register_list'].append('PMACRO_CMD_CTRL_2_0')
# Short Trimmer reg setting:
# Pin0 setting will be used for DQ0 short trimmer
# Similarly Pin1 to Pin8 will be used for DQ1 to DQ8 short trimmer settings.
# DQ4/Pin4 will be used to drive the DM signal. So *PIN4* will control the DM short trimmers in data bricks
# Pin9 and Pin10 will be used for DQSP and DQSN respectively
# NOTE: Here DQ0 to DQ8 means the actual IO0 to IO8 pins of bricks.
#       If we have data swizzle on the brick then DQ0 will not be equal to actual bit-0 of the byte. It depends on the swizzling pattern.
#       Training engine will set these short trimmers depending on the swizzle pattern for each bits in the byte
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0'] = {
    'addr'            : 0x800,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0'] = {
    'addr'            : 0x804,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0'] = {
    'addr'            : 0x808,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_3_0'] = {
    'addr'            : 0x80c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0'] = {
    'addr'            : 0x810,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0'] = {
    'addr'            : 0x814,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0'] = {
    'addr'            : 0x818,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_3_0'] = {
    'addr'            : 0x81c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE1_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0'] = {
    'addr'            : 0x820,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0'] = {
    'addr'            : 0x824,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0'] = {
    'addr'            : 0x828,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_3_0'] = {
    'addr'            : 0x82c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE2_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0'] = {
    'addr'            : 0x830,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0'] = {
    'addr'            : 0x834,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0'] = {
    'addr'            : 0x838,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_3_0'] = {
    'addr'            : 0x83c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN9_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK0_PIN10_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE3_3_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_0           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin0 to  pin3 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_1           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_2           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin8 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE4_3           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_0           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin0 to  pin3 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_1           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_2           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin8 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE5_3           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_0           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin0 to  pin3 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_1           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_2           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin8 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE6_3           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_0           EMC_WINCR //  Rank0 OB  SHORT DQ DDLL value for pin0 to  pin3 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_1           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_2           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin8 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_BYTE7_3           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_0_0'] = {
    'addr'            : 0x880,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN0_CMD0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN1_CMD0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN2_CMD0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN3_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_1_0'] = {
    'addr'            : 0x884,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN4_CMD0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN5_CMD0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN6_CMD0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN7_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_2_0'] = {
    'addr'            : 0x888,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN8_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_3_0'] = {
    'addr'            : 0x88c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN9_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN10_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN9_CMD0',
        'OB_DDLL_SHORT_DQ_RANK0_PIN10_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_0_0'] = {
    'addr'            : 0x890,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN0_CMD1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN1_CMD1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN2_CMD1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN3_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_1_0'] = {
    'addr'            : 0x894,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN4_CMD1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN5_CMD1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN6_CMD1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN7_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_2_0'] = {
    'addr'            : 0x898,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN8_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_3_0'] = {
    'addr'            : 0x89c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK0_PIN9_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK0_PIN10_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK0_PIN9_CMD1',
        'OB_DDLL_SHORT_DQ_RANK0_PIN10_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD1_3_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_0           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin0 to  pin3 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_1           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin4 to  pin7 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_2           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin8 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD2_3           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin9 to  pin10 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_0           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin0 to  pin3 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_1           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin4 to  pin7 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_2           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin8 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK0_CMD3_3           EMC_WINCR // Rank0 OB  SHORT DQ DDLL value for pin9 to  pin10 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0'] = {
    'addr'            : 0x900,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0'] = {
    'addr'            : 0x904,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0'] = {
    'addr'            : 0x908,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_3_0'] = {
    'addr'            : 0x90c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0'] = {
    'addr'            : 0x910,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0'] = {
    'addr'            : 0x914,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0'] = {
    'addr'            : 0x918,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_3_0'] = {
    'addr'            : 0x91c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE1_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0'] = {
    'addr'            : 0x920,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0'] = {
    'addr'            : 0x924,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0'] = {
    'addr'            : 0x928,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_3_0'] = {
    'addr'            : 0x92c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE2',
        'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE2',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE2_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0'] = {
    'addr'            : 0x930,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0'] = {
    'addr'            : 0x934,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0'] = {
    'addr'            : 0x938,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_3_0'] = {
    'addr'            : 0x93c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN9_BYTE3',
        'OB_DDLL_SHORT_DQ_RANK1_PIN10_BYTE3',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE3_3_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_0           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin0 to  pin3 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_1           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_2           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin8 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE4_3           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_0           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin0 to  pin3 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_1           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_2           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin8 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE5_3           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_0           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin0 to  pin1 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_1           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_2           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin8 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE6_3           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_0           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin0 to  pin1 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_1           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin4 to  pin7 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_2           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin8 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_BYTE7_3           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin9 to  pin10 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_0_0'] = {
    'addr'            : 0x980,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN0_CMD0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN1_CMD0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN2_CMD0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN3_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_1_0'] = {
    'addr'            : 0x984,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN4_CMD0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN5_CMD0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN6_CMD0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN7_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_2_0'] = {
    'addr'            : 0x988,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN8_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_3_0'] = {
    'addr'            : 0x98c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN9_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN10_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN9_CMD0',
        'OB_DDLL_SHORT_DQ_RANK1_PIN10_CMD0',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_0_0'] = {
    'addr'            : 0x990,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN0_CMD1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN1_CMD1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN2_CMD1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN3_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_0_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_1_0'] = {
    'addr'            : 0x994,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN4_CMD1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN5_CMD1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN6_CMD1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN7_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_1_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_2_0'] = {
    'addr'            : 0x998,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN8_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_2_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_3_0'] = {
    'addr'            : 0x99c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'OB_DDLL_SHORT_DQ_RANK1_PIN9_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'OB_DDLL_SHORT_DQ_RANK1_PIN10_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'OB_DDLL_SHORT_DQ_RANK1_PIN9_CMD1',
        'OB_DDLL_SHORT_DQ_RANK1_PIN10_CMD1',
    ],
} # End of register: PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_3_0

registers['EMC']['register_list'].append('PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD1_3_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_0           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin0 to  pin1 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_1           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin4 to  pin7 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_2           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin8 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD2_3           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin9 to  pin10 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_0           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin0 to  pin1 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_1           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin4 to  pin7 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_2           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin8 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_OB_DDLL_SHORT_DQ_RANK1_CMD3_3           EMC_WINCR // Rank1 OB  SHORT DQ DDLL value for pin9 to  pin10 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0'] = {
    'addr'            : 0xa00,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0'] = {
    'addr'            : 0xa04,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0'] = {
    'addr'            : 0xa08,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0'] = {
    'addr'            : 0xa10,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0'] = {
    'addr'            : 0xa14,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0'] = {
    'addr'            : 0xa18,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0'] = {
    'addr'            : 0xa20,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0'] = {
    'addr'            : 0xa24,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0'] = {
    'addr'            : 0xa28,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0'] = {
    'addr'            : 0xa30,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN0_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK0_PIN1_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK0_PIN2_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK0_PIN3_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0'] = {
    'addr'            : 0xa34,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN4_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK0_PIN5_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK0_PIN6_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK0_PIN7_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0'] = {
    'addr'            : 0xa38,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN8_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE4_0           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE4_1           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE4_2           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE5_0           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE5_1           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE5_2           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE6_0           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE6_1           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE6_2           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE7_0           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE7_1           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_BYTE7_2           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_0_0'] = {
    'addr'            : 0xa80,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN0_CMD0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN1_CMD0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN2_CMD0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN3_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_1_0'] = {
    'addr'            : 0xa84,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN4_CMD0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN5_CMD0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN6_CMD0',
        'IB_DDLL_SHORT_DQ_RANK0_PIN7_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_2_0'] = {
    'addr'            : 0xa88,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN8_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_0_0'] = {
    'addr'            : 0xa90,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN0_CMD1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN1_CMD1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN2_CMD1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN3_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_1_0'] = {
    'addr'            : 0xa94,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK0_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN4_CMD1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN5_CMD1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN6_CMD1',
        'IB_DDLL_SHORT_DQ_RANK0_PIN7_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_2_0'] = {
    'addr'            : 0xa98,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK0_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK0_PIN8_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD1_2_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD2_0           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin0 to  pin1 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD2_1           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin4 to  pin7 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD2_2           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin8 to  pin10 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD3_0           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin0 to  pin1 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD3_1           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin4 to  pin7 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK0_CMD3_2           EMC_WINCR // Rank0 IB  SHORT DQ DDLL value for pin8 to  pin10 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0'] = {
    'addr'            : 0xb00,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0'] = {
    'addr'            : 0xb04,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0'] = {
    'addr'            : 0xb08,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0'] = {
    'addr'            : 0xb10,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0'] = {
    'addr'            : 0xb14,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0'] = {
    'addr'            : 0xb18,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0'] = {
    'addr'            : 0xb20,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0'] = {
    'addr'            : 0xb24,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE2',
        'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0'] = {
    'addr'            : 0xb28,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0'] = {
    'addr'            : 0xb30,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN0_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK1_PIN1_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK1_PIN2_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK1_PIN3_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0'] = {
    'addr'            : 0xb34,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN4_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK1_PIN5_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK1_PIN6_BYTE3',
        'IB_DDLL_SHORT_DQ_RANK1_PIN7_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0'] = {
    'addr'            : 0xb38,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN8_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE4_0           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE4_1           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE4_2           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte4 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE5_0           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE5_1           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE5_2           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte5 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE6_0           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE6_1           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE6_2           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte6 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE7_0           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin0 to  pin3 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE7_1           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin4 to  pin7 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_BYTE7_2           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin8 to  pin10 of byte7 brick
#;
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_0_0'] = {
    'addr'            : 0xb80,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN0_CMD0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN1_CMD0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN2_CMD0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN3_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_1_0'] = {
    'addr'            : 0xb84,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN4_CMD0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN5_CMD0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN6_CMD0',
        'IB_DDLL_SHORT_DQ_RANK1_PIN7_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_2_0'] = {
    'addr'            : 0xb88,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN8_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_0_0'] = {
    'addr'            : 0xb90,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN0_CMD1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN1_CMD1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN2_CMD1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN3_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_1_0'] = {
    'addr'            : 0xb94,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQ_RANK1_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN4_CMD1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN5_CMD1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN6_CMD1',
        'IB_DDLL_SHORT_DQ_RANK1_PIN7_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_2_0'] = {
    'addr'            : 0xb98,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x7,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f,
    'write_mask'      : 0x7f,
    'IB_DDLL_SHORT_DQ_RANK1_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQ_RANK1_PIN8_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD1_2_0')
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD2_0           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin0 to  pin1 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD2_1           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin4 to  pin7 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD2_2           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin8 to  pin10 of cmd2 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD3_0           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin0 to  pin1 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD3_1           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin4 to  pin7 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#reg   PMACRO_IB_DDLL_SHORT_DQ_RANK1_CMD3_2           EMC_WINCR // Rank1 IB  SHORT DQ DDLL value for pin8 to  pin10 of cmd3 brick
#;
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_VREF_DQ_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_VREF_DQ_0_0'] = {
    'addr'            : 0xbe0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x17,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f007f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f007f,
    'write_mask'      : 0x7f007f,
    'IB_VREF_DQ_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_VREF_DQ_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_VREF_DQ_BYTE0',
        'IB_VREF_DQ_BYTE1',
    ],
} # End of register: PMACRO_IB_VREF_DQ_0_0

registers['EMC']['register_list'].append('PMACRO_IB_VREF_DQ_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_VREF_DQ_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_VREF_DQ_1_0'] = {
    'addr'            : 0xbe4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x17,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f007f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f007f,
    'write_mask'      : 0x7f007f,
    'IB_VREF_DQ_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_VREF_DQ_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_VREF_DQ_BYTE2',
        'IB_VREF_DQ_BYTE3',
    ],
} # End of register: PMACRO_IB_VREF_DQ_1_0

registers['EMC']['register_list'].append('PMACRO_IB_VREF_DQ_1_0')
# NOT USED
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_VREF_DQ_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_VREF_DQ_2_0'] = {
    'addr'            : 0xbf0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x17,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f007f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f007f,
    'write_mask'      : 0x7f007f,
    'IB_VREF_DQ_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_VREF_DQ_CMD1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_VREF_DQ_CMD0',
        'IB_VREF_DQ_CMD1',
    ],
} # End of register: PMACRO_IB_VREF_DQ_2_0

registers['EMC']['register_list'].append('PMACRO_IB_VREF_DQ_2_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_VREF_DQS_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_VREF_DQS_0_0'] = {
    'addr'            : 0xba0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x17,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f007f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f007f,
    'write_mask'      : 0x7f007f,
    'IB_VREF_DQS_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_VREF_DQS_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_VREF_DQS_BYTE0',
        'IB_VREF_DQS_BYTE1',
    ],
} # End of register: PMACRO_IB_VREF_DQS_0_0

registers['EMC']['register_list'].append('PMACRO_IB_VREF_DQS_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_VREF_DQS_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_VREF_DQS_1_0'] = {
    'addr'            : 0xba4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x17,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f007f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f007f,
    'write_mask'      : 0x7f007f,
    'IB_VREF_DQS_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_VREF_DQS_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_VREF_DQS_BYTE2',
        'IB_VREF_DQS_BYTE3',
    ],
} # End of register: PMACRO_IB_VREF_DQS_1_0

registers['EMC']['register_list'].append('PMACRO_IB_VREF_DQS_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_VREF_DQS_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_VREF_DQS_2_0'] = {
    'addr'            : 0xbb0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x17,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f007f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f007f,
    'write_mask'      : 0x7f007f,
    'IB_VREF_DQS_CMD0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_VREF_DQS_CMD1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_VREF_DQS_CMD0',
        'IB_VREF_DQS_CMD1',
    ],
} # End of register: PMACRO_IB_VREF_DQS_2_0

registers['EMC']['register_list'].append('PMACRO_IB_VREF_DQS_2_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_IB_RXRT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_RXRT_0'] = {
    'addr'            : 0xcf4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff,
    'write_mask'      : 0x7ff,
    'IB_RXRT' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_RXRT',
    ],
} # End of register: PMACRO_IB_RXRT_0

registers['EMC']['register_list'].append('PMACRO_IB_RXRT_0')

# Register EMC_PMACRO_PAD_CFG_CTRL_0
# Gil Jung manually added
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PAD_CFG_CTRL_0'] = {
    'addr'            : 0xcf4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x00f00000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x00f00000,
    'write_mask'      : 0x00f00000,
    'RX_TRIM_RXRT' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'RX_TRIM_RXRT',
    ],
} # End of register: EMC_PMACRO_PAD_CFG_CTRL_0

registers['EMC']['register_list'].append('PMACRO_PAD_CFG_CTRL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_LONG_CMD_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_LONG_CMD_0_0'] = {
    'addr'            : 0xc00,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLL_LONG_CMD_CKE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_LONG_CMD_CKE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_LONG_CMD_CKE0',
        'DDLL_LONG_CMD_CKE1',
    ],
} # End of register: PMACRO_DDLL_LONG_CMD_0_0

registers['EMC']['register_list'].append('PMACRO_DDLL_LONG_CMD_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_LONG_CMD_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_LONG_CMD_1_0'] = {
    'addr'            : 0xc04,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLL_LONG_CMD_CKE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_LONG_CMD_CKE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_LONG_CMD_CKE2',
        'DDLL_LONG_CMD_CKE3',
    ],
} # End of register: PMACRO_DDLL_LONG_CMD_1_0

registers['EMC']['register_list'].append('PMACRO_DDLL_LONG_CMD_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_LONG_CMD_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_LONG_CMD_2_0'] = {
    'addr'            : 0xc08,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLL_LONG_CMD_CKE4' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_LONG_CMD_CKE5' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_LONG_CMD_CKE4',
        'DDLL_LONG_CMD_CKE5',
    ],
} # End of register: PMACRO_DDLL_LONG_CMD_2_0

registers['EMC']['register_list'].append('PMACRO_DDLL_LONG_CMD_2_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_LONG_CMD_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_LONG_CMD_3_0'] = {
    'addr'            : 0xc0c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLL_LONG_CMD_CKE6' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_LONG_CMD_CKE7' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_LONG_CMD_CKE6',
        'DDLL_LONG_CMD_CKE7',
    ],
} # End of register: PMACRO_DDLL_LONG_CMD_3_0

registers['EMC']['register_list'].append('PMACRO_DDLL_LONG_CMD_3_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_LONG_CMD_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_LONG_CMD_4_0'] = {
    'addr'            : 0xc10,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLL_LONG_CMD_RESET' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_LONG_CMD_MISC0' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_LONG_CMD_RESET',
        'DDLL_LONG_CMD_MISC0',
    ],
} # End of register: PMACRO_DDLL_LONG_CMD_4_0

registers['EMC']['register_list'].append('PMACRO_DDLL_LONG_CMD_4_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_LONG_CMD_5_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_LONG_CMD_5_0'] = {
    'addr'            : 0xc14,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLL_LONG_CMD_MISC1' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_LONG_CMD_MISC2' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_LONG_CMD_MISC1',
        'DDLL_LONG_CMD_MISC2',
    ],
} # End of register: PMACRO_DDLL_LONG_CMD_5_0

registers['EMC']['register_list'].append('PMACRO_DDLL_LONG_CMD_5_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_SHORT_CMD_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_SHORT_CMD_0_0'] = {
    'addr'            : 0xc20,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'DDLL_SHORT_CMD_CKE0' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_CKE1' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_CKE2' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_CKE3' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_SHORT_CMD_CKE0',
        'DDLL_SHORT_CMD_CKE1',
        'DDLL_SHORT_CMD_CKE2',
        'DDLL_SHORT_CMD_CKE3',
    ],
} # End of register: PMACRO_DDLL_SHORT_CMD_0_0

registers['EMC']['register_list'].append('PMACRO_DDLL_SHORT_CMD_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_SHORT_CMD_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_SHORT_CMD_1_0'] = {
    'addr'            : 0xc24,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'DDLL_SHORT_CMD_CKE4' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_CKE5' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_CKE6' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_CKE7' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_SHORT_CMD_CKE4',
        'DDLL_SHORT_CMD_CKE5',
        'DDLL_SHORT_CMD_CKE6',
        'DDLL_SHORT_CMD_CKE7',
    ],
} # End of register: PMACRO_DDLL_SHORT_CMD_1_0

registers['EMC']['register_list'].append('PMACRO_DDLL_SHORT_CMD_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DDLL_SHORT_CMD_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_SHORT_CMD_2_0'] = {
    'addr'            : 0xc28,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7f7f7f7f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7f7f7f7f,
    'write_mask'      : 0x7f7f7f7f,
    'DDLL_SHORT_CMD_RESET' : {
        'lsb'               : 0,
        'msb'               : 6,
        'size'              : 7,
        'field'             : (0x7f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_MISC0' : {
        'lsb'               : 8,
        'msb'               : 14,
        'size'              : 7,
        'field'             : (0x7f << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_MISC1' : {
        'lsb'               : 16,
        'msb'               : 22,
        'size'              : 7,
        'field'             : (0x7f << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLL_SHORT_CMD_MISC2' : {
        'lsb'               : 24,
        'msb'               : 30,
        'size'              : 7,
        'field'             : (0x7f << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_SHORT_CMD_RESET',
        'DDLL_SHORT_CMD_MISC0',
        'DDLL_SHORT_CMD_MISC1',
        'DDLL_SHORT_CMD_MISC2',
    ],
} # End of register: PMACRO_DDLL_SHORT_CMD_2_0

registers['EMC']['register_list'].append('PMACRO_DDLL_SHORT_CMD_2_0')

# Register EMC_PMACRO_CFG_PM_GLOBAL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CFG_PM_GLOBAL_0_0'] = {
    'addr'            : 0xc30,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xa,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x30f0000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x30f0000,
    'write_mask'      : 0x30f0000,
    'DISABLE_CFG_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DISABLE_CFG_BYTE1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DISABLE_CFG_BYTE2' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DISABLE_CFG_BYTE3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DISABLE_CFG_CMD0' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DISABLE_CFG_CMD1' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DISABLE_CFG_BYTE0',
        'DISABLE_CFG_BYTE1',
        'DISABLE_CFG_BYTE2',
        'DISABLE_CFG_BYTE3',
        'DISABLE_CFG_CMD0',
        'DISABLE_CFG_CMD1',
    ],
} # End of register: PMACRO_CFG_PM_GLOBAL_0_0

registers['EMC']['register_list'].append('PMACRO_CFG_PM_GLOBAL_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_VTTGEN_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_VTTGEN_CTRL_0_0'] = {
    'addr'            : 0xc34,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0xb0000,
    'array'           : False,
    'reset_mask'      : 0xf8000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf8000,
    'write_mask'      : 0xf8000,
    'ENABLE_PERBYTE_VDDA' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'VTT_VDDA_LVL' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ENABLE_PERBYTE_VDDA',
        'VTT_VDDA_LVL',
    ],
} # End of register: PMACRO_VTTGEN_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_VTTGEN_CTRL_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_VTTGEN_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_VTTGEN_CTRL_1_0'] = {
    'addr'            : 0xc38,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x106000,
    'array'           : False,
    'reset_mask'      : 0x30fc00,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x30fc00,
    'write_mask'      : 0x30fc00,
    'VTT_VDDA_CTRL' : {
        'lsb'               : 10,
        'msb'               : 15,
        'size'              : 6,
        'field'             : (0x3f << 10),
        'woffset'           : 0x0,
        'default'           : 0x18,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'VTT_VDDA_WB_CTRL' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'VTT_VDDA_CTRL',
        'VTT_VDDA_WB_CTRL',
    ],
} # End of register: PMACRO_VTTGEN_CTRL_1_0

registers['EMC']['register_list'].append('PMACRO_VTTGEN_CTRL_1_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_VTTGEN_CTRL_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_VTTGEN_CTRL_2_0'] = {
    'addr'            : 0xcf0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff0000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff0000,
    'write_mask'      : 0xff0000,
    'VTT_VDDA_LOAD' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'VTT_VDDA_LOAD',
    ],
} # End of register: PMACRO_VTTGEN_CTRL_2_0

registers['EMC']['register_list'].append('PMACRO_VTTGEN_CTRL_2_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DSR_VTTGEN_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DSR_VTTGEN_CTRL_0_0'] = {
    'addr'            : 0xc6c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0xb,
    'array'           : False,
    'reset_mask'      : 0xff0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff0f,
    'write_mask'      : 0xff0f,
    'DSR_VTT_VDDA_LVL' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DSR_VTT_VDDA_LOAD' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DSR_VTT_VDDA_LVL',
        'DSR_VTT_VDDA_LOAD',
    ],
} # End of register: PMACRO_DSR_VTTGEN_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_DSR_VTTGEN_CTRL_0_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.
# NOTE: BG_ILVL_CTRL register's bit-0 field is inverted and used to connect to the PAD. So 00 maps to 01 on pad i/p and 01 maps to 00;

# Register EMC_PMACRO_BG_BIAS_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_BG_BIAS_CTRL_0_0'] = {
    'addr'            : 0xc3c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x2,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3000,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3000,
    'write_mask'      : 0x3000,
    'XM2COMP_BG_ILVL_CTRL' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'XM2COMP_BG_ILVL_CTRL',
    ],
} # End of register: PMACRO_BG_BIAS_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_BG_BIAS_CTRL_0_0')
# This register is shadowed: see usage note at top of spec file - except for E_DPD_EMC/SEL_DPD_EMC
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_PAD_CFG_CTRL_0
# if 'EMC' not in registers:
#     registers['EMC'] = {}
#     registers['EMC']['register_list']  = []

# registers['EMC']['PMACRO_PAD_CFG_CTRL_0'] = {
#     'addr'            : 0xc40,
#     'secure'          : 0x0,
#     'dual'            : 0x0,
#     'word_count'      : 0x1,
#     'size'            : 0x12,
#     'reset_val'       : 0x10,
#     'array'           : False,
#     'reset_mask'      : 0x32e11,
#     'sw_default_val'  : 0x0,
#     'sw_default_mask' : 0x0,
#     'read_mask'       : 0x32e11,
#     'write_mask'      : 0x32e11,
#     'TX_BPS_AUTOCAL_DRVDEC' : {
#         'lsb'               : 0,
#         'msb'               : 0,
#         'size'              : 1,
#         'field'             : (0x1 << 0),
#         'woffset'           : 0x0,
#         'default'           : 0x0,
#         'sw_default'        : 0x0,
#         'parity_protection' : 1,
#         'action'            : 'rws',
#         'enums' : {
#         },
#     },
#     'IB_BYTE_USE_MAX_PBDQS' : {
#         'lsb'               : 4,
#         'msb'               : 4,
#         'size'              : 1,
#         'field'             : (0x1 << 4),
#         'woffset'           : 0x0,
#         'default'           : 0x1,
#         'sw_default'        : 0x0,
#         'parity_protection' : 1,
#         'action'            : 'rws',
#         'enums' : {
#         },
#     },
#     'E_PWRD' : {
#         'lsb'               : 9,
#         'msb'               : 9,
#         'size'              : 1,
#         'field'             : (0x1 << 9),
#         'woffset'           : 0x0,
#         'default'           : 0x0,
#         'sw_default'        : 0x0,
#         'parity_protection' : 1,
#         'action'            : 'rws',
#         'enums' : {
#         },
#     },
#     'E_DPD_EMC' : {
#         'lsb'               : 10,
#         'msb'               : 10,
#         'size'              : 1,
#         'field'             : (0x1 << 10),
#         'woffset'           : 0x0,
#         'default'           : 0x0,
#         'sw_default'        : 0x0,
#         'parity_protection' : 1,
#         'action'            : 'rw',
#         'enums' : {
#         },
#     },
#     'SEL_DPD_EMC' : {
#         'lsb'               : 11,
#         'msb'               : 11,
#         'size'              : 1,
#         'field'             : (0x1 << 11),
#         'woffset'           : 0x0,
#         'default'           : 0x0,
#         'sw_default'        : 0x0,
#         'parity_protection' : 1,
#         'action'            : 'rw',
#         'enums' : {
#         },
#     },
#     'TX_SEL_MV_CYCLE' : {
#         'lsb'               : 13,
#         'msb'               : 13,
#         'size'              : 1,
#         'field'             : (0x1 << 13),
#         'woffset'           : 0x0,
#         'default'           : 0x0,
#         'sw_default'        : 0x0,
#         'parity_protection' : 1,
#         'action'            : 'rws',
#         'enums' : {
#         },
#     },
#     'MEM_MODE' : {
#         'lsb'               : 16,
#         'msb'               : 17,
#         'size'              : 2,
#         'field'             : (0x3 << 16),
#         'woffset'           : 0x0,
#         'default'           : 0x0,
#         'sw_default'        : 0x0,
#         'parity_protection' : 1,
#         'action'            : 'rws',
#         'enums' : {
#         },
#     },
#     # Fields sorted in order of declaration in register
#     'field_list' : [
#         'TX_BPS_AUTOCAL_DRVDEC',
#         'IB_BYTE_USE_MAX_PBDQS',
#         'E_PWRD',
#         'E_DPD_EMC',
#         'SEL_DPD_EMC',
#         'TX_SEL_MV_CYCLE',
#         'MEM_MODE',
#     ],
# } # End of register: PMACRO_PAD_CFG_CTRL_0

registers['EMC']['register_list'].append('PMACRO_PAD_CFG_CTRL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CMD_PAD_RX_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_PAD_RX_CTRL_0'] = {
    'addr'            : 0xc50,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x2fef9033,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x2fef9033,
    'write_mask'      : 0x2fef9033,
    'CMD_DQ_RX_MODE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DQ_DIFF_MODE_15' : 0,
            'DQ_LSSA_MODE' : 3,
        },
    },
    'CMD_DQS_RX_MODE' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DQS_SCHMITT' : 0,
            'RESERVED' : 1,
            'DQS_DIFF_MODE_50' : 2,
            'DQS_DIFF_MODE_15' : 3,
        },
    },
    'CMD_DQS_RX_E_DIFF_MODE' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_EINPUT_FORCE_ON' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_RX_CTRL' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_RX_E_IBIAS_PWRD' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_RX_E_DIRECT_ZI' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_CMD_RX_E_DIRECT_ZI' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_RX_CTRL' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_CATR_ASYNC_DQ_SAMPLE' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DQ_RX_MODE',
        'CMD_DQS_RX_MODE',
        'CMD_DQS_RX_E_DIFF_MODE',
        'CMD_EINPUT_FORCE_ON',
        'CMD_DQS_RX_CTRL',
        'CMD_RX_E_IBIAS_PWRD',
        'CMD_DQ_RX_E_DIRECT_ZI',
        'CMD_CMD_RX_E_DIRECT_ZI',
        'CMD_DQ_RX_CTRL',
        'CMD_CATR_ASYNC_DQ_SAMPLE',
    ],
} # End of register: PMACRO_CMD_PAD_RX_CTRL_0

registers['EMC']['register_list'].append('PMACRO_CMD_PAD_RX_CTRL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DATA_PAD_RX_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DATA_PAD_RX_CTRL_0'] = {
    'addr'            : 0xc54,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x2fef9033,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x2fef9033,
    'write_mask'      : 0x2fef9033,
    'DATA_DQ_RX_MODE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DQ_DIFF_MODE_15' : 0,
            'DQ_LSSA_MODE' : 3,
        },
    },
    'DATA_DQS_RX_MODE' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
            'DQS_SCHMITT' : 0,
            'RESERVED' : 1,
            'DQS_DIFF_MODE_50' : 2,
            'DQS_DIFF_MODE_15' : 3,
        },
    },
    'DATA_DQS_RX_E_DIFF_MODE' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_EINPUT_FORCE_ON' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_RX_CTRL' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_RX_E_IBIAS_PWRD' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_RX_E_DIRECT_ZI' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_CMD_RX_E_DIRECT_ZI' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_RX_CTRL' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_CATR_ASYNC_DQ_SAMPLE' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA_DQ_RX_MODE',
        'DATA_DQS_RX_MODE',
        'DATA_DQS_RX_E_DIFF_MODE',
        'DATA_EINPUT_FORCE_ON',
        'DATA_DQS_RX_CTRL',
        'DATA_RX_E_IBIAS_PWRD',
        'DATA_DQ_RX_E_DIRECT_ZI',
        'DATA_CMD_RX_E_DIRECT_ZI',
        'DATA_DQ_RX_CTRL',
        'DATA_CATR_ASYNC_DQ_SAMPLE',
    ],
} # End of register: PMACRO_DATA_PAD_RX_CTRL_0

registers['EMC']['register_list'].append('PMACRO_DATA_PAD_RX_CTRL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CMD_RX_TERM_MODE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_RX_TERM_MODE_0'] = {
    'addr'            : 0xc58,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xe,
    'reset_val'       : 0x2000,
    'array'           : False,
    'reset_mask'      : 0x2333,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x2333,
    'write_mask'      : 0x2333,
    'CMD_DQ_RX_TERM_MODE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQSP_RX_TERM_MODE' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQSN_RX_TERM_MODE' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_E_PWRD_RX' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DQ_RX_TERM_MODE',
        'CMD_DQSP_RX_TERM_MODE',
        'CMD_DQSN_RX_TERM_MODE',
        'CMD_E_PWRD_RX',
    ],
} # End of register: PMACRO_CMD_RX_TERM_MODE_0

registers['EMC']['register_list'].append('PMACRO_CMD_RX_TERM_MODE_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DATA_RX_TERM_MODE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DATA_RX_TERM_MODE_0'] = {
    'addr'            : 0xc5c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xe,
    'reset_val'       : 0x2000,
    'array'           : False,
    'reset_mask'      : 0x2333,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x2333,
    'write_mask'      : 0x2333,
    'DATA_DQ_RX_TERM_MODE' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQSP_RX_TERM_MODE' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQSN_RX_TERM_MODE' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_E_PWRD_RX' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA_DQ_RX_TERM_MODE',
        'DATA_DQSP_RX_TERM_MODE',
        'DATA_DQSN_RX_TERM_MODE',
        'DATA_E_PWRD_RX',
    ],
} # End of register: PMACRO_DATA_RX_TERM_MODE_0

registers['EMC']['register_list'].append('PMACRO_DATA_RX_TERM_MODE_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_CMD_PAD_TX_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_PAD_TX_CTRL_0'] = {
    'addr'            : 0xc60,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x60000000,
    'array'           : False,
    'reset_mask'      : 0x7feff7fd,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7feff7fd,
    'write_mask'      : 0x7feff7fd,
    'CMD_DQ_E_IVREF' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_EBOOST_PD_MODE' : {
        'lsb'               : 2,
        'msb'               : 4,
        'size'              : 3,
        'field'             : (0x7 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_E_WKPD' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_E_WKPU' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_EBOOST_PU_MODE' : {
        'lsb'               : 7,
        'msb'               : 9,
        'size'              : 3,
        'field'             : (0x7 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_E_IVREF' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_EBOOST_PD_MODE' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQSP_TX_E_WKPD' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQSP_TX_E_WKPU' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_EBOOST_PU_MODE' : {
        'lsb'               : 17,
        'msb'               : 19,
        'size'              : 3,
        'field'             : (0x7 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQSN_TX_E_WKPD' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQSN_TX_E_WKPU' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_DRVDN_FORCEON' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_RX_E_PERBIT_DQSTRIM' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_DRVDN_FORCEON' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_DRVFORCEON' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_DRVFORCEON' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_DISABLE_CAL_UPDATE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_DISABLE_FGCG_VAUXC' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_TX_DISABLE_FGCG_VDDA' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DQ_E_IVREF',
        'CMD_DQ_TX_EBOOST_PD_MODE',
        'CMD_DQ_TX_E_WKPD',
        'CMD_DQ_TX_E_WKPU',
        'CMD_DQ_TX_EBOOST_PU_MODE',
        'CMD_DQS_E_IVREF',
        'CMD_DQS_TX_EBOOST_PD_MODE',
        'CMD_DQSP_TX_E_WKPD',
        'CMD_DQSP_TX_E_WKPU',
        'CMD_DQS_TX_EBOOST_PU_MODE',
        'CMD_DQSN_TX_E_WKPD',
        'CMD_DQSN_TX_E_WKPU',
        'CMD_DQ_TX_DRVDN_FORCEON',
        'CMD_DQ_RX_E_PERBIT_DQSTRIM',
        'CMD_DQS_TX_DRVDN_FORCEON',
        'CMD_DQ_TX_DRVFORCEON',
        'CMD_DQS_TX_DRVFORCEON',
        'CMD_DQS_TX_DISABLE_CAL_UPDATE',
        'CMD_TX_DISABLE_FGCG_VAUXC',
        'CMD_TX_DISABLE_FGCG_VDDA',
    ],
} # End of register: PMACRO_CMD_PAD_TX_CTRL_0

registers['EMC']['register_list'].append('PMACRO_CMD_PAD_TX_CTRL_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DATA_PAD_TX_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DATA_PAD_TX_CTRL_0'] = {
    'addr'            : 0xc64,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x60000000,
    'array'           : False,
    'reset_mask'      : 0x7feff7fd,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7feff7fd,
    'write_mask'      : 0x7feff7fd,
    'DATA_DQ_E_IVREF' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_EBOOST_PD_MODE' : {
        'lsb'               : 2,
        'msb'               : 4,
        'size'              : 3,
        'field'             : (0x7 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_E_WKPD' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_E_WKPU' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_EBOOST_PU_MODE' : {
        'lsb'               : 7,
        'msb'               : 9,
        'size'              : 3,
        'field'             : (0x7 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_E_IVREF' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_EBOOST_PD_MODE' : {
        'lsb'               : 12,
        'msb'               : 14,
        'size'              : 3,
        'field'             : (0x7 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQSP_TX_E_WKPD' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQSP_TX_E_WKPU' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_EBOOST_PU_MODE' : {
        'lsb'               : 17,
        'msb'               : 19,
        'size'              : 3,
        'field'             : (0x7 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQSN_TX_E_WKPD' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQSN_TX_E_WKPU' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_DRVDN_FORCEON' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_RX_E_PERBIT_DQSTRIM' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_DRVDN_FORCEON' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_DRVFORCEON' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_DRVFORCEON' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_DISABLE_CAL_UPDATE' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_TX_DISABLE_FGCG_VAUXC' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_TX_DISABLE_FGCG_VDDA' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA_DQ_E_IVREF',
        'DATA_DQ_TX_EBOOST_PD_MODE',
        'DATA_DQ_TX_E_WKPD',
        'DATA_DQ_TX_E_WKPU',
        'DATA_DQ_TX_EBOOST_PU_MODE',
        'DATA_DQS_E_IVREF',
        'DATA_DQS_TX_EBOOST_PD_MODE',
        'DATA_DQSP_TX_E_WKPD',
        'DATA_DQSP_TX_E_WKPU',
        'DATA_DQS_TX_EBOOST_PU_MODE',
        'DATA_DQSN_TX_E_WKPD',
        'DATA_DQSN_TX_E_WKPU',
        'DATA_DQ_TX_DRVDN_FORCEON',
        'DATA_DQ_RX_E_PERBIT_DQSTRIM',
        'DATA_DQS_TX_DRVDN_FORCEON',
        'DATA_DQ_TX_DRVFORCEON',
        'DATA_DQS_TX_DRVFORCEON',
        'DATA_DQS_TX_DISABLE_CAL_UPDATE',
        'DATA_TX_DISABLE_FGCG_VAUXC',
        'DATA_TX_DISABLE_FGCG_VDDA',
    ],
} # End of register: PMACRO_DATA_PAD_TX_CTRL_0

registers['EMC']['register_list'].append('PMACRO_DATA_PAD_TX_CTRL_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_BRICK_MAPPING_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_BRICK_MAPPING_0_0'] = {
    'addr'            : 0xc80,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xcccccccc,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'BRICK_MAPPING_BRICK0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_BYTE0' : 0,
            'VIRTUAL_ID_BYTE1' : 1,
            'VIRTUAL_ID_BYTE2' : 2,
            'VIRTUAL_ID_BYTE3' : 3,
            'VIRTUAL_ID_BYTE4' : 4,
            'VIRTUAL_ID_BYTE5' : 5,
            'VIRTUAL_ID_BYTE6' : 6,
            'VIRTUAL_ID_BYTE7' : 7,
            'VIRTUAL_ID_CMD0' : 8,
            'VIRTUAL_ID_CMD1' : 9,
            'VIRTUAL_ID_CMD2' : 10,
            'VIRTUAL_ID_CMD3' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'CMDIO_MAPPING_BRICK0' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_CH0_CKE0' : 0,
            'VIRTUAL_ID_CH0_CKE1' : 1,
            'VIRTUAL_ID_CH0_CKE_B0' : 2,
            'VIRTUAL_ID_CH0_CKE_B1' : 3,
            'VIRTUAL_ID_CH1_CKE0' : 4,
            'VIRTUAL_ID_CH1_CKE1' : 5,
            'VIRTUAL_ID_CH1_CKE_B0' : 6,
            'VIRTUAL_ID_CH1_CKE_B1' : 7,
            'VIRTUAL_ID_RESET' : 8,
            'VIRTUAL_ID_MISC0' : 9,
            'VIRTUAL_ID_MISC1' : 10,
            'VIRTUAL_ID_MISC2' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'BRICK_MAPPING_BRICK1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_BYTE0' : 0,
            'VIRTUAL_ID_BYTE1' : 1,
            'VIRTUAL_ID_BYTE2' : 2,
            'VIRTUAL_ID_BYTE3' : 3,
            'VIRTUAL_ID_BYTE4' : 4,
            'VIRTUAL_ID_BYTE5' : 5,
            'VIRTUAL_ID_BYTE6' : 6,
            'VIRTUAL_ID_BYTE7' : 7,
            'VIRTUAL_ID_CMD0' : 8,
            'VIRTUAL_ID_CMD1' : 9,
            'VIRTUAL_ID_CMD2' : 10,
            'VIRTUAL_ID_CMD3' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'CMDIO_MAPPING_BRICK1' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_CH0_CKE0' : 0,
            'VIRTUAL_ID_CH0_CKE1' : 1,
            'VIRTUAL_ID_CH0_CKE_B0' : 2,
            'VIRTUAL_ID_CH0_CKE_B1' : 3,
            'VIRTUAL_ID_CH1_CKE0' : 4,
            'VIRTUAL_ID_CH1_CKE1' : 5,
            'VIRTUAL_ID_CH1_CKE_B0' : 6,
            'VIRTUAL_ID_CH1_CKE_B1' : 7,
            'VIRTUAL_ID_RESET' : 8,
            'VIRTUAL_ID_MISC0' : 9,
            'VIRTUAL_ID_MISC1' : 10,
            'VIRTUAL_ID_MISC2' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'BRICK_MAPPING_BRICK2' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_BYTE0' : 0,
            'VIRTUAL_ID_BYTE1' : 1,
            'VIRTUAL_ID_BYTE2' : 2,
            'VIRTUAL_ID_BYTE3' : 3,
            'VIRTUAL_ID_BYTE4' : 4,
            'VIRTUAL_ID_BYTE5' : 5,
            'VIRTUAL_ID_BYTE6' : 6,
            'VIRTUAL_ID_BYTE7' : 7,
            'VIRTUAL_ID_CMD0' : 8,
            'VIRTUAL_ID_CMD1' : 9,
            'VIRTUAL_ID_CMD2' : 10,
            'VIRTUAL_ID_CMD3' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'CMDIO_MAPPING_BRICK2' : {
        'lsb'               : 20,
        'msb'               : 23,
        'size'              : 4,
        'field'             : (0xf << 20),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_CH0_CKE0' : 0,
            'VIRTUAL_ID_CH0_CKE1' : 1,
            'VIRTUAL_ID_CH0_CKE_B0' : 2,
            'VIRTUAL_ID_CH0_CKE_B1' : 3,
            'VIRTUAL_ID_CH1_CKE0' : 4,
            'VIRTUAL_ID_CH1_CKE1' : 5,
            'VIRTUAL_ID_CH1_CKE_B0' : 6,
            'VIRTUAL_ID_CH1_CKE_B1' : 7,
            'VIRTUAL_ID_RESET' : 8,
            'VIRTUAL_ID_MISC0' : 9,
            'VIRTUAL_ID_MISC1' : 10,
            'VIRTUAL_ID_MISC2' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'BRICK_MAPPING_BRICK3' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_BYTE0' : 0,
            'VIRTUAL_ID_BYTE1' : 1,
            'VIRTUAL_ID_BYTE2' : 2,
            'VIRTUAL_ID_BYTE3' : 3,
            'VIRTUAL_ID_BYTE4' : 4,
            'VIRTUAL_ID_BYTE5' : 5,
            'VIRTUAL_ID_BYTE6' : 6,
            'VIRTUAL_ID_BYTE7' : 7,
            'VIRTUAL_ID_CMD0' : 8,
            'VIRTUAL_ID_CMD1' : 9,
            'VIRTUAL_ID_CMD2' : 10,
            'VIRTUAL_ID_CMD3' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'CMDIO_MAPPING_BRICK3' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_CH0_CKE0' : 0,
            'VIRTUAL_ID_CH0_CKE1' : 1,
            'VIRTUAL_ID_CH0_CKE_B0' : 2,
            'VIRTUAL_ID_CH0_CKE_B1' : 3,
            'VIRTUAL_ID_CH1_CKE0' : 4,
            'VIRTUAL_ID_CH1_CKE1' : 5,
            'VIRTUAL_ID_CH1_CKE_B0' : 6,
            'VIRTUAL_ID_CH1_CKE_B1' : 7,
            'VIRTUAL_ID_RESET' : 8,
            'VIRTUAL_ID_MISC0' : 9,
            'VIRTUAL_ID_MISC1' : 10,
            'VIRTUAL_ID_MISC2' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BRICK_MAPPING_BRICK0',
        'CMDIO_MAPPING_BRICK0',
        'BRICK_MAPPING_BRICK1',
        'CMDIO_MAPPING_BRICK1',
        'BRICK_MAPPING_BRICK2',
        'CMDIO_MAPPING_BRICK2',
        'BRICK_MAPPING_BRICK3',
        'CMDIO_MAPPING_BRICK3',
    ],
} # End of register: PMACRO_BRICK_MAPPING_0_0

registers['EMC']['register_list'].append('PMACRO_BRICK_MAPPING_0_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_BRICK_MAPPING_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_BRICK_MAPPING_1_0'] = {
    'addr'            : 0xc84,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0xcccc,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'BRICK_MAPPING_BRICK4' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_BYTE0' : 0,
            'VIRTUAL_ID_BYTE1' : 1,
            'VIRTUAL_ID_BYTE2' : 2,
            'VIRTUAL_ID_BYTE3' : 3,
            'VIRTUAL_ID_BYTE4' : 4,
            'VIRTUAL_ID_BYTE5' : 5,
            'VIRTUAL_ID_BYTE6' : 6,
            'VIRTUAL_ID_BYTE7' : 7,
            'VIRTUAL_ID_CMD0' : 8,
            'VIRTUAL_ID_CMD1' : 9,
            'VIRTUAL_ID_CMD2' : 10,
            'VIRTUAL_ID_CMD3' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'CMDIO_MAPPING_BRICK4' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_CH0_CKE0' : 0,
            'VIRTUAL_ID_CH0_CKE1' : 1,
            'VIRTUAL_ID_CH0_CKE_B0' : 2,
            'VIRTUAL_ID_CH0_CKE_B1' : 3,
            'VIRTUAL_ID_CH1_CKE0' : 4,
            'VIRTUAL_ID_CH1_CKE1' : 5,
            'VIRTUAL_ID_CH1_CKE_B0' : 6,
            'VIRTUAL_ID_CH1_CKE_B1' : 7,
            'VIRTUAL_ID_RESET' : 8,
            'VIRTUAL_ID_MISC0' : 9,
            'VIRTUAL_ID_MISC1' : 10,
            'VIRTUAL_ID_MISC2' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'BRICK_MAPPING_BRICK5' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_BYTE0' : 0,
            'VIRTUAL_ID_BYTE1' : 1,
            'VIRTUAL_ID_BYTE2' : 2,
            'VIRTUAL_ID_BYTE3' : 3,
            'VIRTUAL_ID_BYTE4' : 4,
            'VIRTUAL_ID_BYTE5' : 5,
            'VIRTUAL_ID_BYTE6' : 6,
            'VIRTUAL_ID_BYTE7' : 7,
            'VIRTUAL_ID_CMD0' : 8,
            'VIRTUAL_ID_CMD1' : 9,
            'VIRTUAL_ID_CMD2' : 10,
            'VIRTUAL_ID_CMD3' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    'CMDIO_MAPPING_BRICK5' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_CH0_CKE0' : 0,
            'VIRTUAL_ID_CH0_CKE1' : 1,
            'VIRTUAL_ID_CH0_CKE_B0' : 2,
            'VIRTUAL_ID_CH0_CKE_B1' : 3,
            'VIRTUAL_ID_CH1_CKE0' : 4,
            'VIRTUAL_ID_CH1_CKE1' : 5,
            'VIRTUAL_ID_CH1_CKE_B0' : 6,
            'VIRTUAL_ID_CH1_CKE_B1' : 7,
            'VIRTUAL_ID_RESET' : 8,
            'VIRTUAL_ID_MISC0' : 9,
            'VIRTUAL_ID_MISC1' : 10,
            'VIRTUAL_ID_MISC2' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'BRICK_MAPPING_BRICK4',
        'CMDIO_MAPPING_BRICK4',
        'BRICK_MAPPING_BRICK5',
        'CMDIO_MAPPING_BRICK5',
    ],
} # End of register: PMACRO_BRICK_MAPPING_1_0

registers['EMC']['register_list'].append('PMACRO_BRICK_MAPPING_1_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_BRICK_MAPPING_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_BRICK_MAPPING_2_0'] = {
    'addr'            : 0xc88,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0xc,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'NC_BRICK_MAPPING_BRICK8' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0xc,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "VIRTUAL_ID_BOOT",
        'enums' : {
            'VIRTUAL_ID_BYTE0' : 0,
            'VIRTUAL_ID_BYTE1' : 1,
            'VIRTUAL_ID_BYTE2' : 2,
            'VIRTUAL_ID_BYTE3' : 3,
            'VIRTUAL_ID_BYTE4' : 4,
            'VIRTUAL_ID_BYTE5' : 5,
            'VIRTUAL_ID_BYTE6' : 6,
            'VIRTUAL_ID_BYTE7' : 7,
            'VIRTUAL_ID_CMD0' : 8,
            'VIRTUAL_ID_CMD1' : 9,
            'VIRTUAL_ID_CMD2' : 10,
            'VIRTUAL_ID_CMD3' : 11,
            'VIRTUAL_ID_BOOT' : 12,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'NC_BRICK_MAPPING_BRICK8',
    ],
} # End of register: PMACRO_BRICK_MAPPING_2_0

registers['EMC']['register_list'].append('PMACRO_BRICK_MAPPING_2_0')
# DDLL_OFFSET is used to verify margins of the trained DDLL values.

# Register EMC_PMACRO_DDLL_OFFSET_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_OFFSET_0'] = {
    'addr'            : 0xce4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff1ff3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff1ff3f,
    'write_mask'      : 0x7ff1ff3f,
    'DDLL_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BIT_TXDQ_EN' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BIT_TXDQS_EN' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BIT_TXCMD_EN' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BIT_RXDQ_EN' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BYTE_TXDQ_EN' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BYTE_TXDQS_EN' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BYTE_TXCMD_EN' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BYTE_RXDQS_EN' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BYTE_QU_EN' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BIT_TXDQ_EN' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BIT_TXDQS_EN' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BIT_TXCMD_EN' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BIT_RXDQ_EN' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BYTE_TXDQ_EN' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BYTE_TXDQS_EN' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BYTE_TXCMD_EN' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BYTE_RXDQS_EN' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BYTE_QU_EN' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_OFFSET_BIT_RXDQS_EN' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_OFFSET_BIT_RXDQS_EN' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_OFFSET',
        'DATA_DDLL_OFFSET_BIT_TXDQ_EN',
        'DATA_DDLL_OFFSET_BIT_TXDQS_EN',
        'DATA_DDLL_OFFSET_BIT_TXCMD_EN',
        'DATA_DDLL_OFFSET_BIT_RXDQ_EN',
        'DATA_DDLL_OFFSET_BYTE_TXDQ_EN',
        'DATA_DDLL_OFFSET_BYTE_TXDQS_EN',
        'DATA_DDLL_OFFSET_BYTE_TXCMD_EN',
        'DATA_DDLL_OFFSET_BYTE_RXDQS_EN',
        'DATA_DDLL_OFFSET_BYTE_QU_EN',
        'CMD_DDLL_OFFSET_BIT_TXDQ_EN',
        'CMD_DDLL_OFFSET_BIT_TXDQS_EN',
        'CMD_DDLL_OFFSET_BIT_TXCMD_EN',
        'CMD_DDLL_OFFSET_BIT_RXDQ_EN',
        'CMD_DDLL_OFFSET_BYTE_TXDQ_EN',
        'CMD_DDLL_OFFSET_BYTE_TXDQS_EN',
        'CMD_DDLL_OFFSET_BYTE_TXCMD_EN',
        'CMD_DDLL_OFFSET_BYTE_RXDQS_EN',
        'CMD_DDLL_OFFSET_BYTE_QU_EN',
        'DATA_DDLL_OFFSET_BIT_RXDQS_EN',
        'CMD_DDLL_OFFSET_BIT_RXDQS_EN',
    ],
} # End of register: PMACRO_DDLL_OFFSET_0

registers['EMC']['register_list'].append('PMACRO_DDLL_OFFSET_0')
# DDLL_PERIODIC_OFFSET is used to support periodic training

# Register EMC_PMACRO_DDLL_PERIODIC_OFFSET_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLL_PERIODIC_OFFSET_0'] = {
    'addr'            : 0xce8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1f,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff1ff3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff1ff3f,
    'write_mask'      : 0x7ff1ff3f,
    'DDLL_PERIODIC_OFFSET' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BIT_TXDQ_EN' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BIT_TXDQS_EN' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BIT_TXCMD_EN' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BIT_RXDQ_EN' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BYTE_TXDQ_EN' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BYTE_TXDQS_EN' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BYTE_TXCMD_EN' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BYTE_RXDQS_EN' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BYTE_QU_EN' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BIT_TXDQ_EN' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BIT_TXDQS_EN' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BIT_TXCMD_EN' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BIT_RXDQ_EN' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BYTE_TXDQ_EN' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BYTE_TXDQS_EN' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BYTE_TXCMD_EN' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BYTE_RXDQS_EN' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BYTE_QU_EN' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DDLL_PERIODIC_OFFSET_BIT_RXDQS_EN' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DDLL_PERIODIC_OFFSET_BIT_RXDQS_EN' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLL_PERIODIC_OFFSET',
        'DATA_DDLL_PERIODIC_OFFSET_BIT_TXDQ_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BIT_TXDQS_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BIT_TXCMD_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BIT_RXDQ_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BYTE_TXDQ_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BYTE_TXDQS_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BYTE_TXCMD_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BYTE_RXDQS_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BYTE_QU_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BIT_TXDQ_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BIT_TXDQS_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BIT_TXCMD_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BIT_RXDQ_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BYTE_TXDQ_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BYTE_TXDQS_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BYTE_TXCMD_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BYTE_RXDQS_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BYTE_QU_EN',
        'DATA_DDLL_PERIODIC_OFFSET_BIT_RXDQS_EN',
        'CMD_DDLL_PERIODIC_OFFSET_BIT_RXDQS_EN',
    ],
} # End of register: PMACRO_DDLL_PERIODIC_OFFSET_0

registers['EMC']['register_list'].append('PMACRO_DDLL_PERIODIC_OFFSET_0')
# This register is shadowed: see usage note at top of spec file.
#
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_BRICK_CTRL_RFU1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_BRICK_CTRL_RFU1_0'] = {
    'addr'            : 0x330,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'CMD_BRICK_CTRL_RFU1' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_RFU1' : {
        'lsb'               : 16,
        'msb'               : 31,
        'size'              : 16,
        'field'             : (0xffff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_BRICK_CTRL_RFU1',
        'DATA_BRICK_CTRL_RFU1',
    ],
} # End of register: PMACRO_BRICK_CTRL_RFU1_0

registers['EMC']['register_list'].append('PMACRO_BRICK_CTRL_RFU1_0')

# Register EMC_PMACRO_BRICK_CTRL_RFU2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_BRICK_CTRL_RFU2_0'] = {
    'addr'            : 0x334,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'CMD_BRICK_CTRL_RFU2' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_RFU2' : {
        'lsb'               : 16,
        'msb'               : 31,
        'size'              : 16,
        'field'             : (0xffff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_BRICK_CTRL_RFU2',
        'DATA_BRICK_CTRL_RFU2',
    ],
} # End of register: PMACRO_BRICK_CTRL_RFU2_0

registers['EMC']['register_list'].append('PMACRO_BRICK_CTRL_RFU2_0')

# Register EMC_PMACRO_CMD_BRICK_CTRL_FDPD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_BRICK_CTRL_FDPD_0'] = {
    'addr'            : 0x318,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x12,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ffff,
    'write_mask'      : 0x3ffff,
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT0' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT1' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT2' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT3' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT4' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT5' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT6' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT7' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT8' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT0',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT1',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT2',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT3',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT4',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT5',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT6',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT7',
        'CMD_BRICK_CTRL_FDPD_RFU_PHASE_BIT8',
    ],
} # End of register: PMACRO_CMD_BRICK_CTRL_FDPD_0

registers['EMC']['register_list'].append('PMACRO_CMD_BRICK_CTRL_FDPD_0')

# Register EMC_PMACRO_DATA_BRICK_CTRL_FDPD_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DATA_BRICK_CTRL_FDPD_0'] = {
    'addr'            : 0x31c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x12,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ffff,
    'write_mask'      : 0x3ffff,
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT0' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT1' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT2' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT3' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT4' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT5' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT6' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT7' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT8' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT0',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT1',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT2',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT3',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT4',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT5',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT6',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT7',
        'DATA_BRICK_CTRL_FDPD_RFU_PHASE_BIT8',
    ],
} # End of register: PMACRO_DATA_BRICK_CTRL_FDPD_0

registers['EMC']['register_list'].append('PMACRO_DATA_BRICK_CTRL_FDPD_0')

# Register EMC_PMACRO_TRAINING_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TRAINING_CTRL_0_0'] = {
    'addr'            : 0xcf8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfff02ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff02ff,
    'write_mask'      : 0xfff02ff,
    'CH0_TRAINING_ENABLED' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_TRAINING_TRAIN_QPOP' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_TRAINING_RX_E_DIRECT_ZI' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_TRAINING_E_WRPTR' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_TRAINING_DRV_DQS' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_TRAINING_WRLVL' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_UPDATE_MODE' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "INCR",
        'enums' : {
            'INCR' : 0,
            'INCR_DECR' : 1,
        },
    },
    'CH0_HOLD_UPDATE' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_OFFSET_VAL_MODE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'OB_DQS_DDLL_R0' : 1,
            'OB_CA_DDLL_R0' : 2,
            'IB_DQS_DDLL_R0' : 3,
            'OB_DQ_DDLL_R0' : 4,
            'IB_PBDQS_DDLL_R0' : 5,
            'OB_DQS_DDLL_R1' : 9,
            'OB_CA_DDLL_R1' : 10,
            'IB_DQS_DDLL_R1' : 11,
            'OB_DQ_DDLL_R1' : 12,
            'IB_PBDQS_DDLL_R1' : 13,
        },
    },
    'CH0_OFFSET_VAL' : {
        'lsb'               : 20,
        'msb'               : 27,
        'size'              : 8,
        'field'             : (0xff << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH0_TRAINING_ENABLED',
        'CH0_TRAINING_TRAIN_QPOP',
        'CH0_TRAINING_RX_E_DIRECT_ZI',
        'CH0_TRAINING_E_WRPTR',
        'CH0_TRAINING_DRV_DQS',
        'CH0_TRAINING_WRLVL',
        'CH0_UPDATE_MODE',
        'CH0_HOLD_UPDATE',
        'CH0_OFFSET_VAL_MODE',
        'CH0_OFFSET_VAL',
    ],
} # End of register: PMACRO_TRAINING_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_TRAINING_CTRL_0_0')

# Register EMC_PMACRO_TRAINING_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_TRAINING_CTRL_1_0'] = {
    'addr'            : 0xcfc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfff02ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfff02ff,
    'write_mask'      : 0xfff02ff,
    'CH1_TRAINING_ENABLED' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_TRAINING_TRAIN_QPOP' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_TRAINING_RX_E_DIRECT_ZI' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_TRAINING_E_WRPTR' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_TRAINING_DRV_DQS' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_TRAINING_WRLVL' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_UPDATE_MODE' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "INCR",
        'enums' : {
            'INCR' : 0,
            'INCR_DECR' : 1,
        },
    },
    'CH1_HOLD_UPDATE' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_OFFSET_VAL_MODE' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'OB_DQS_DDLL_R0' : 1,
            'OB_CA_DDLL_R0' : 2,
            'IB_DQS_DDLL_R0' : 3,
            'OB_DQ_DDLL_R0' : 4,
            'IB_PBDQS_DDLL_R0' : 5,
            'OB_DQS_DDLL_R1' : 9,
            'OB_CA_DDLL_R1' : 10,
            'IB_DQS_DDLL_R1' : 11,
            'OB_DQ_DDLL_R1' : 12,
            'IB_PBDQS_DDLL_R1' : 13,
        },
    },
    'CH1_OFFSET_VAL' : {
        'lsb'               : 20,
        'msb'               : 27,
        'size'              : 8,
        'field'             : (0xff << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH1_TRAINING_ENABLED',
        'CH1_TRAINING_TRAIN_QPOP',
        'CH1_TRAINING_RX_E_DIRECT_ZI',
        'CH1_TRAINING_E_WRPTR',
        'CH1_TRAINING_DRV_DQS',
        'CH1_TRAINING_WRLVL',
        'CH1_UPDATE_MODE',
        'CH1_HOLD_UPDATE',
        'CH1_OFFSET_VAL_MODE',
        'CH1_OFFSET_VAL',
    ],
} # End of register: PMACRO_TRAINING_CTRL_1_0

registers['EMC']['register_list'].append('PMACRO_TRAINING_CTRL_1_0')

# Register EMC_PMC_SCRATCH1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMC_SCRATCH1_0'] = {
    'addr'            : 0x440,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'SCRATCH1' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SCRATCH1',
    ],
} # End of register: PMC_SCRATCH1_0

registers['EMC']['register_list'].append('PMC_SCRATCH1_0')

# Register EMC_PMC_SCRATCH2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMC_SCRATCH2_0'] = {
    'addr'            : 0x444,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'SCRATCH2' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SCRATCH2',
    ],
} # End of register: PMC_SCRATCH2_0

registers['EMC']['register_list'].append('PMC_SCRATCH2_0')

# Register EMC_PMC_SCRATCH3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMC_SCRATCH3_0'] = {
    'addr'            : 0x448,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'SCRATCH3' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SCRATCH3',
    ],
} # End of register: PMC_SCRATCH3_0

registers['EMC']['register_list'].append('PMC_SCRATCH3_0')
# *************************************************
# EMC registers which are present inside MCH_common
# *************************************************

# Register EMC_MCH_GLOBAL_INTSTATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MCH_GLOBAL_INTSTATUS_0'] = {
    'addr'            : 0x44c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'INT_CH0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'INT_CH15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'INT_CH0',
        'INT_CH1',
        'INT_CH2',
        'INT_CH3',
        'INT_CH4',
        'INT_CH5',
        'INT_CH6',
        'INT_CH7',
        'INT_CH8',
        'INT_CH9',
        'INT_CH10',
        'INT_CH11',
        'INT_CH12',
        'INT_CH13',
        'INT_CH14',
        'INT_CH15',
    ],
} # End of register: MCH_GLOBAL_INTSTATUS_0

registers['EMC']['register_list'].append('MCH_GLOBAL_INTSTATUS_0')

# Register EMC_MCH_GLOBAL_CRITICAL_INTSTATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MCH_GLOBAL_CRITICAL_INTSTATUS_0'] = {
    'addr'            : 0x450,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'CRITICAL_INT_CH0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'CRITICAL_INT_CH15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CRITICAL_INT_CH0',
        'CRITICAL_INT_CH1',
        'CRITICAL_INT_CH2',
        'CRITICAL_INT_CH3',
        'CRITICAL_INT_CH4',
        'CRITICAL_INT_CH5',
        'CRITICAL_INT_CH6',
        'CRITICAL_INT_CH7',
        'CRITICAL_INT_CH8',
        'CRITICAL_INT_CH9',
        'CRITICAL_INT_CH10',
        'CRITICAL_INT_CH11',
        'CRITICAL_INT_CH12',
        'CRITICAL_INT_CH13',
        'CRITICAL_INT_CH14',
        'CRITICAL_INT_CH15',
    ],
} # End of register: MCH_GLOBAL_CRITICAL_INTSTATUS_0

registers['EMC']['register_list'].append('MCH_GLOBAL_CRITICAL_INTSTATUS_0')

# Register EMC_MCH_GLOBAL_NONCRITICAL_INTSTATUS_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MCH_GLOBAL_NONCRITICAL_INTSTATUS_0'] = {
    'addr'            : 0x474,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0xffff,
    'NONCRITICAL_INT_CH0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    'NONCRITICAL_INT_CH15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rwto',
            'init_enum'  : "NONE",
        'enums' : {
            'NONE' : 0,
            'INT' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'NONCRITICAL_INT_CH0',
        'NONCRITICAL_INT_CH1',
        'NONCRITICAL_INT_CH2',
        'NONCRITICAL_INT_CH3',
        'NONCRITICAL_INT_CH4',
        'NONCRITICAL_INT_CH5',
        'NONCRITICAL_INT_CH6',
        'NONCRITICAL_INT_CH7',
        'NONCRITICAL_INT_CH8',
        'NONCRITICAL_INT_CH9',
        'NONCRITICAL_INT_CH10',
        'NONCRITICAL_INT_CH11',
        'NONCRITICAL_INT_CH12',
        'NONCRITICAL_INT_CH13',
        'NONCRITICAL_INT_CH14',
        'NONCRITICAL_INT_CH15',
    ],
} # End of register: MCH_GLOBAL_NONCRITICAL_INTSTATUS_0

registers['EMC']['register_list'].append('MCH_GLOBAL_NONCRITICAL_INTSTATUS_0')

# Register EMC_ASR_CONTROL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ASR_CONTROL_0'] = {
    'addr'            : 0x470,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x8000ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x8000ffff,
    'write_mask'      : 0x8000ffff,
    'DISPLAY_STUTTER_EN' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
            'init_enum'  : "DISABLED",
        'enums' : {
            'DISABLED' : 0,
            'ENABLED' : 1,
        },
    },
    'ASR_THRESHOLD' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DISPLAY_STUTTER_EN',
        'ASR_THRESHOLD',
    ],
} # End of register: ASR_CONTROL_0

registers['EMC']['register_list'].append('ASR_CONTROL_0')

# Register EMC_RESET_PAD_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RESET_PAD_CTRL_0_0'] = {
    'addr'            : 0x454,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x16,
    'reset_val'       : 0x3f3f00,
    'array'           : False,
    'reset_mask'      : 0x3f3ff7,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3ff7,
    'write_mask'      : 0x3f3ff7,
    'XM0_RESET_A' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM0_RESET_E_INPUT' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM0_RESET_EN' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM0_RESET_RFU' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM0_RESET_DRVDN' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM0_RESET_DRVUP' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'XM0_RESET_A',
        'XM0_RESET_E_INPUT',
        'XM0_RESET_EN',
        'XM0_RESET_RFU',
        'XM0_RESET_DRVDN',
        'XM0_RESET_DRVUP',
    ],
} # End of register: RESET_PAD_CTRL_0_0

registers['EMC']['register_list'].append('RESET_PAD_CTRL_0_0')

# Register EMC_RESET_PAD_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['RESET_PAD_CTRL_1_0'] = {
    'addr'            : 0x47c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x16,
    'reset_val'       : 0x3f3f00,
    'array'           : False,
    'reset_mask'      : 0x3f3ff7,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f3ff7,
    'write_mask'      : 0x3f3ff7,
    'XM1_RESET_A' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM1_RESET_E_INPUT' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM1_RESET_EN' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM1_RESET_RFU' : {
        'lsb'               : 4,
        'msb'               : 7,
        'size'              : 4,
        'field'             : (0xf << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM1_RESET_DRVDN' : {
        'lsb'               : 8,
        'msb'               : 13,
        'size'              : 6,
        'field'             : (0x3f << 8),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM1_RESET_DRVUP' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x3f,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'XM1_RESET_A',
        'XM1_RESET_E_INPUT',
        'XM1_RESET_EN',
        'XM1_RESET_RFU',
        'XM1_RESET_DRVDN',
        'XM1_RESET_DRVUP',
    ],
} # End of register: RESET_PAD_CTRL_1_0

registers['EMC']['register_list'].append('RESET_PAD_CTRL_1_0')
# The ACT register allows SW to issue a Active command. This command may be used for post package repair incase of LP4.
# Writing into this reg will issue the ACT cmd to DRAM
#

# Register EMC_ACT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['ACT_0'] = {
    'addr'            : 0x110,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xc380ffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0xc380ffff,
    'read_mask'       : 0xc380ffff,
    'write_mask'      : 0xc380ffff,
    'SW_ACT_ROW' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SW_ACT_BANK' : {
        'lsb'               : 23,
        'msb'               : 25,
        'size'              : 3,
        'field'             : (0x7 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'SW_ACT_DEV_SELECTN' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SW_ACT_ROW',
        'SW_ACT_BANK',
        'SW_ACT_DEV_SELECTN',
    ],
} # End of register: ACT_0

registers['EMC']['register_list'].append('ACT_0')

# Register EMC_MEM_INIT_DONE_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['MEM_INIT_DONE_0'] = {
    'addr'            : 0x114,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x1,
    'read_mask'       : 0x1,
    'write_mask'      : 0x1,
    'MEM_INIT_DONE' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'MEM_INIT_DONE',
    ],
} # End of register: MEM_INIT_DONE_0

registers['EMC']['register_list'].append('MEM_INIT_DONE_0')

# Register EMC_PERIODIC_TR_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PERIODIC_TR_CTRL_1_0'] = {
    'addr'            : 0x18,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x18,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff00ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff00ff,
    'write_mask'      : 0xff00ff,
    'TR_RD2TRIM_UPDATE' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'TR_WR2TRIM_UPDATE' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'TR_RD2TRIM_UPDATE',
        'TR_WR2TRIM_UPDATE',
    ],
} # End of register: PERIODIC_TR_CTRL_1_0

registers['EMC']['register_list'].append('PERIODIC_TR_CTRL_1_0')

# Register EMC_PERIODIC_TR_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PERIODIC_TR_CTRL_0'] = {
    'addr'            : 0x1c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xa0f0000,
    'array'           : False,
    'reset_mask'      : 0x8fdff3ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x8fdff3ff,
    'write_mask'      : 0x8fdff3ff,
    'PERIODIC_TR_INTERVAL' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PERIODIC_TR_STEPS' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'TR_UPDATE_WAIT' : {
        'lsb'               : 16,
        'msb'               : 20,
        'size'              : 5,
        'field'             : (0x1f << 16),
        'woffset'           : 0x0,
        'default'           : 0xf,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PERIODIC_TR_USE_USEC' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PERIODIC_TR_EN' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PERIODIC_START_WIDTH' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0xa,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PERIODIC_TR_DISABLE_CMD_WAIT' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PERIODIC_TR_INTERVAL',
        'PERIODIC_TR_STEPS',
        'TR_UPDATE_WAIT',
        'PERIODIC_TR_USE_USEC',
        'PERIODIC_TR_EN',
        'PERIODIC_START_WIDTH',
        'PERIODIC_TR_DISABLE_CMD_WAIT',
    ],
} # End of register: PERIODIC_TR_CTRL_0

registers['EMC']['register_list'].append('PERIODIC_TR_CTRL_0')
# LP4X Pad controls
# This register is not shadowed.
# Controls the DLLCAL fsm for ch0 macros

# Register EMC_PMACRO_DDLLCAL_EN_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLLCAL_EN_0_0'] = {
    'addr'            : 0xce0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x11,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x11,
    'write_mask'      : 0x11,
    'CH0_DDLLCAL_EN' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH0_DLL_LOCK_TIMEOUT' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH0_DDLLCAL_EN',
        'CH0_DLL_LOCK_TIMEOUT',
    ],
} # End of register: PMACRO_DDLLCAL_EN_0_0

registers['EMC']['register_list'].append('PMACRO_DDLLCAL_EN_0_0')
# This register is not shadowed.
# Controls the DLLCAL fsm for ch1 macros

# Register EMC_PMACRO_DDLLCAL_EN_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLLCAL_EN_1_0'] = {
    'addr'            : 0xcec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x11,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x11,
    'write_mask'      : 0x11,
    'CH1_DDLLCAL_EN' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'CH1_DLL_LOCK_TIMEOUT' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CH1_DDLLCAL_EN',
        'CH1_DLL_LOCK_TIMEOUT',
    ],
} # End of register: PMACRO_DDLLCAL_EN_1_0

registers['EMC']['register_list'].append('PMACRO_DDLLCAL_EN_1_0')
# This register is shadowed: see usage note at top of spec file.
#  DDLLCAL_CAL is used by the DDLL master to communicate the calibration
#  value to the DDLL slaves

# Register EMC_PMACRO_DDLLCAL_CAL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLLCAL_CAL_0_0'] = {
    'addr'            : 0xd00,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x400040,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLLCAL_CAL_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x40,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CAL_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x40,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLLCAL_CAL_BYTE0',
        'DDLLCAL_CAL_BYTE1',
    ],
} # End of register: PMACRO_DDLLCAL_CAL_0_0

registers['EMC']['register_list'].append('PMACRO_DDLLCAL_CAL_0_0')
# This register is shadowed: see usage note at top of spec file.
#  DDLLCAL_CAL is used by the DDLL master to communicate the calibration
#  value to the DDLL slaves

# Register EMC_PMACRO_DDLLCAL_CAL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLLCAL_CAL_1_0'] = {
    'addr'            : 0xd04,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x400040,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLLCAL_CAL_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x40,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CAL_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x40,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLLCAL_CAL_BYTE2',
        'DDLLCAL_CAL_BYTE3',
    ],
} # End of register: PMACRO_DDLLCAL_CAL_1_0

registers['EMC']['register_list'].append('PMACRO_DDLLCAL_CAL_1_0')
# This register is shadowed: see usage note at top of spec file.
#  DDLLCAL_CAL is used by the DDLL master to communicate the calibration
#  value to the DDLL slaves
#reg    PMACRO_DDLLCAL_CAL_2           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#  DDLLCAL_CAL is used by the DDLL master to communicate the calibration
#  value to the DDLL slaves
#reg    PMACRO_DDLLCAL_CAL_3           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#  DDLLCAL_CAL is used by the DDLL master to communicate the calibration
#  value to the DDLL slaves

# Register EMC_PMACRO_DDLLCAL_CAL_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DDLLCAL_CAL_4_0'] = {
    'addr'            : 0xd10,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x400040,
    'array'           : False,
    'reset_mask'      : 0x7ff07ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff07ff,
    'write_mask'      : 0x7ff07ff,
    'DDLLCAL_CAL_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x40,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DDLLCAL_CAL_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x40,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DDLLCAL_CAL_CMD0',
        'DDLLCAL_CAL_CMD1',
    ],
} # End of register: PMACRO_DDLLCAL_CAL_4_0

registers['EMC']['register_list'].append('PMACRO_DDLLCAL_CAL_4_0')
# This register is shadowed: see usage note at top of spec file.
#  DDLLCAL_CAL is used by the DDLL master to communicate the calibration
#  value to the DDLL slaves
#reg    PMACRO_DDLLCAL_CAL_5           EMC_WINCR
#;
#   Per brick Digital DLL Status bits directly from DLL

# Register EMC_PMACRO_DIG_DLL_STATUS_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DIG_DLL_STATUS_0_0'] = {
    'addr'            : 0xd20,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DLL_OUT_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_BYTE0' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_LOCK_BYTE0' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLLCAL_IN_PROGRESS_BYTE0' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_PRIV_UPDATED_BYTE0' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_MIN_BYTE0' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_OUT_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_BYTE1' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_LOCK_BYTE1' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLLCAL_IN_PROGRESS_BYTE1' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_PRIV_UPDATED_BYTE1' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_MIN_BYTE1' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DLL_OUT_BYTE0',
        'DLL_ALARM_BYTE0',
        'DLL_LOCK_BYTE0',
        'DLLCAL_IN_PROGRESS_BYTE0',
        'DLL_PRIV_UPDATED_BYTE0',
        'DLL_ALARM_MIN_BYTE0',
        'DLL_OUT_BYTE1',
        'DLL_ALARM_BYTE1',
        'DLL_LOCK_BYTE1',
        'DLLCAL_IN_PROGRESS_BYTE1',
        'DLL_PRIV_UPDATED_BYTE1',
        'DLL_ALARM_MIN_BYTE1',
    ],
} # End of register: PMACRO_DIG_DLL_STATUS_0_0

registers['EMC']['register_list'].append('PMACRO_DIG_DLL_STATUS_0_0')
#   Per brick Digital DLL Status bits directly from DLL

# Register EMC_PMACRO_DIG_DLL_STATUS_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DIG_DLL_STATUS_1_0'] = {
    'addr'            : 0xd24,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DLL_OUT_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_BYTE2' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_LOCK_BYTE2' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLLCAL_IN_PROGRESS_BYTE2' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_PRIV_UPDATED_BYTE2' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_MIN_BYTE2' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_OUT_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_BYTE3' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_LOCK_BYTE3' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLLCAL_IN_PROGRESS_BYTE3' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_PRIV_UPDATED_BYTE3' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_MIN_BYTE3' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DLL_OUT_BYTE2',
        'DLL_ALARM_BYTE2',
        'DLL_LOCK_BYTE2',
        'DLLCAL_IN_PROGRESS_BYTE2',
        'DLL_PRIV_UPDATED_BYTE2',
        'DLL_ALARM_MIN_BYTE2',
        'DLL_OUT_BYTE3',
        'DLL_ALARM_BYTE3',
        'DLL_LOCK_BYTE3',
        'DLLCAL_IN_PROGRESS_BYTE3',
        'DLL_PRIV_UPDATED_BYTE3',
        'DLL_ALARM_MIN_BYTE3',
    ],
} # End of register: PMACRO_DIG_DLL_STATUS_1_0

registers['EMC']['register_list'].append('PMACRO_DIG_DLL_STATUS_1_0')
#   Per brick Digital DLL Status bits directly from DLL
#reg  PMACRO_DIG_DLL_STATUS_2                    EMC_WINCR  // Digital DLL Status
#;
#   Per brick Digital DLL Status bits directly from DLL
#reg  PMACRO_DIG_DLL_STATUS_3                    EMC_WINCR  // Digital DLL Status
#;
#   Per brick Digital DLL Status bits directly from DLL

# Register EMC_PMACRO_DIG_DLL_STATUS_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DIG_DLL_STATUS_4_0'] = {
    'addr'            : 0xd30,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'DLL_OUT_CMD0' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_CMD0' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_LOCK_CMD0' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLLCAL_IN_PROGRESS_CMD0' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_PRIV_UPDATED_CMD0' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_MIN_CMD0' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_OUT_CMD1' : {
        'lsb'               : 16,
        'msb'               : 26,
        'size'              : 11,
        'field'             : (0x7ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_CMD1' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_LOCK_CMD1' : {
        'lsb'               : 28,
        'msb'               : 28,
        'size'              : 1,
        'field'             : (0x1 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLLCAL_IN_PROGRESS_CMD1' : {
        'lsb'               : 29,
        'msb'               : 29,
        'size'              : 1,
        'field'             : (0x1 << 29),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_PRIV_UPDATED_CMD1' : {
        'lsb'               : 30,
        'msb'               : 30,
        'size'              : 1,
        'field'             : (0x1 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DLL_ALARM_MIN_CMD1' : {
        'lsb'               : 31,
        'msb'               : 31,
        'size'              : 1,
        'field'             : (0x1 << 31),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DLL_OUT_CMD0',
        'DLL_ALARM_CMD0',
        'DLL_LOCK_CMD0',
        'DLLCAL_IN_PROGRESS_CMD0',
        'DLL_PRIV_UPDATED_CMD0',
        'DLL_ALARM_MIN_CMD0',
        'DLL_OUT_CMD1',
        'DLL_ALARM_CMD1',
        'DLL_LOCK_CMD1',
        'DLLCAL_IN_PROGRESS_CMD1',
        'DLL_PRIV_UPDATED_CMD1',
        'DLL_ALARM_MIN_CMD1',
    ],
} # End of register: PMACRO_DIG_DLL_STATUS_4_0

registers['EMC']['register_list'].append('PMACRO_DIG_DLL_STATUS_4_0')
#   Per brick Digital DLL Status bits directly from DLL
#reg  PMACRO_DIG_DLL_STATUS_5                    EMC_WINCR  // Digital DLL Status
#;
#This register is NOT shadowed.
#Before changing the PMU_CONFIG value make SURE we set PMU_E=0
#Then set PMU_E=1 and new value for PMU_CONFIG as we have the pulse detection logic on PMU_E
#which is used to sample PMU_CONFIG in pmu_clk domain

# Register EMC_PMACRO_PMU_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PMU_CTRL_0'] = {
    'addr'            : 0x304,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x80,
    'array'           : False,
    'reset_mask'      : 0x1ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ff,
    'write_mask'      : 0x1ff,
    'PMU_CONFIG' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x80,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'PMU_E' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PMU_CONFIG',
        'PMU_E',
    ],
} # End of register: PMACRO_PMU_CTRL_0

registers['EMC']['register_list'].append('PMACRO_PMU_CTRL_0')
#This register is NOT shadowed.
#Before changing the PMU_CONFIG value make SURE we set PMU_E=0
#Then set PMU_E=1 and new value for PMU_CONFIG as we have the pulse detection logic on PMU_E
#which is used to sample PMU_CONFIG in pmu_clk domain

# Register EMC_PMACRO_XM2COMP_PMU_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_XM2COMP_PMU_CTRL_0'] = {
    'addr'            : 0x308,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x80,
    'array'           : False,
    'reset_mask'      : 0xf1ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf1ff,
    'write_mask'      : 0xf1ff,
    'XM2COMP_PMU_CONFIG' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x80,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'XM2COMP_PMU_E' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
            'init_enum'  : "DISABLE",
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'XM2COMP_PMU_SEL_ANASRC_IN' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'XM2COMP_PMU_CONFIG',
        'XM2COMP_PMU_E',
        'XM2COMP_PMU_SEL_ANASRC_IN',
    ],
} # End of register: PMACRO_XM2COMP_PMU_CTRL_0

registers['EMC']['register_list'].append('PMACRO_XM2COMP_PMU_CTRL_0')
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_FGCG_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_FGCG_CTRL_0_0'] = {
    'addr'            : 0xd40,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xb7ffb7ff,
    'array'           : False,
    'reset_mask'      : 0xf7fff7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf7fff7ff,
    'write_mask'      : 0xf7fff7ff,
    'DQ0_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_DISABLE_FGCG_BIT_BYTE0' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'BRICK_VDDA_LVL_BYTE0' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_DISABLE_FGCG_BIT_BYTE1' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'BRICK_VDDA_LVL_BYTE1' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ1_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ2_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ3_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ4_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ5_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ6_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ7_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQ8_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQSP_TX_DISABLE_FGCG_BIT_BYTE0',
        'DQSN_TX_DISABLE_FGCG_BIT_BYTE0',
        'BRICK_VDDA_LVL_BYTE0',
        'DQ0_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ1_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ2_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ3_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ4_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ5_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ6_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ7_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQ8_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQSP_TX_DISABLE_FGCG_BIT_BYTE1',
        'DQSN_TX_DISABLE_FGCG_BIT_BYTE1',
        'BRICK_VDDA_LVL_BYTE1',
    ],
} # End of register: PMACRO_PERBIT_FGCG_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_FGCG_CTRL_0_0')
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_FGCG_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_FGCG_CTRL_1_0'] = {
    'addr'            : 0xd44,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xb7ffb7ff,
    'array'           : False,
    'reset_mask'      : 0xf7fff7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf7fff7ff,
    'write_mask'      : 0xf7fff7ff,
    'DQ0_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_DISABLE_FGCG_BIT_BYTE2' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'BRICK_VDDA_LVL_BYTE2' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_DISABLE_FGCG_BIT_BYTE3' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'VBRICKVDDA_LVL_BYTE3' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ1_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ2_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ3_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ4_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ5_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ6_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ7_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQ8_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQSP_TX_DISABLE_FGCG_BIT_BYTE2',
        'DQSN_TX_DISABLE_FGCG_BIT_BYTE2',
        'BRICK_VDDA_LVL_BYTE2',
        'DQ0_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ1_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ2_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ3_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ4_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ5_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ6_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ7_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQ8_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQSP_TX_DISABLE_FGCG_BIT_BYTE3',
        'DQSN_TX_DISABLE_FGCG_BIT_BYTE3',
        'VBRICKVDDA_LVL_BYTE3',
    ],
} # End of register: PMACRO_PERBIT_FGCG_CTRL_1_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_FGCG_CTRL_1_0')
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_FGCG_CTRL_2           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_FGCG_CTRL_3           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_FGCG_CTRL_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_FGCG_CTRL_4_0'] = {
    'addr'            : 0xd50,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xb7ffb7ff,
    'array'           : False,
    'reset_mask'      : 0xf7fff7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf7fff7ff,
    'write_mask'      : 0xf7fff7ff,
    'DQ0_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_DISABLE_FGCG_BIT_CMD0' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'BRICK_VDDA_LVL_CMD0' : {
        'lsb'               : 12,
        'msb'               : 15,
        'size'              : 4,
        'field'             : (0xf << 12),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 20,
        'msb'               : 20,
        'size'              : 1,
        'field'             : (0x1 << 20),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 21,
        'msb'               : 21,
        'size'              : 1,
        'field'             : (0x1 << 21),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 22,
        'msb'               : 22,
        'size'              : 1,
        'field'             : (0x1 << 22),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 23,
        'msb'               : 23,
        'size'              : 1,
        'field'             : (0x1 << 23),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ8_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 24,
        'msb'               : 24,
        'size'              : 1,
        'field'             : (0x1 << 24),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 25,
        'msb'               : 25,
        'size'              : 1,
        'field'             : (0x1 << 25),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_TX_DISABLE_FGCG_BIT_CMD1' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'BRICK_VDDA_LVL_CMD1' : {
        'lsb'               : 28,
        'msb'               : 31,
        'size'              : 4,
        'field'             : (0xf << 28),
        'woffset'           : 0x0,
        'default'           : 0xb,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ1_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ2_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ3_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ4_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ5_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ6_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ7_TX_DISABLE_FGCG_BIT_CMD0',
        'DQ8_TX_DISABLE_FGCG_BIT_CMD0',
        'DQSP_TX_DISABLE_FGCG_BIT_CMD0',
        'DQSN_TX_DISABLE_FGCG_BIT_CMD0',
        'BRICK_VDDA_LVL_CMD0',
        'DQ0_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ1_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ2_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ3_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ4_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ5_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ6_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ7_TX_DISABLE_FGCG_BIT_CMD1',
        'DQ8_TX_DISABLE_FGCG_BIT_CMD1',
        'DQSP_TX_DISABLE_FGCG_BIT_CMD1',
        'DQSN_TX_DISABLE_FGCG_BIT_CMD1',
        'BRICK_VDDA_LVL_CMD1',
    ],
} # End of register: PMACRO_PERBIT_FGCG_CTRL_4_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_FGCG_CTRL_4_0')
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_FGCG_CTRL_5           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_RFU_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_RFU_CTRL_0_0'] = {
    'addr'            : 0xd60,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0_RFU_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_RFU_BYTE0' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_RFU_BYTE0' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_RFU_BYTE0' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_RFU_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_RFU_BYTE0' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_RFU_BYTE0' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_RFU_BYTE0' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_RFU_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_RFU_BYTE1' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_RFU_BYTE1' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_RFU_BYTE1' : {
        'lsb'               : 22,
        'msb'               : 23,
        'size'              : 2,
        'field'             : (0x3 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_RFU_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_RFU_BYTE1' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_RFU_BYTE1' : {
        'lsb'               : 28,
        'msb'               : 29,
        'size'              : 2,
        'field'             : (0x3 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_RFU_BYTE1' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_RFU_BYTE0',
        'DQ1_RFU_BYTE0',
        'DQ2_RFU_BYTE0',
        'DQ3_RFU_BYTE0',
        'DQ4_RFU_BYTE0',
        'DQ5_RFU_BYTE0',
        'DQ6_RFU_BYTE0',
        'DQ7_RFU_BYTE0',
        'DQ0_RFU_BYTE1',
        'DQ1_RFU_BYTE1',
        'DQ2_RFU_BYTE1',
        'DQ3_RFU_BYTE1',
        'DQ4_RFU_BYTE1',
        'DQ5_RFU_BYTE1',
        'DQ6_RFU_BYTE1',
        'DQ7_RFU_BYTE1',
    ],
} # End of register: PMACRO_PERBIT_RFU_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_RFU_CTRL_0_0')
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_RFU_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_RFU_CTRL_1_0'] = {
    'addr'            : 0xd64,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0_RFU_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_RFU_BYTE2' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_RFU_BYTE2' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_RFU_BYTE2' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_RFU_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_RFU_BYTE2' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_RFU_BYTE2' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_RFU_BYTE2' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_RFU_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_RFU_BYTE3' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_RFU_BYTE3' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_RFU_BYTE3' : {
        'lsb'               : 22,
        'msb'               : 23,
        'size'              : 2,
        'field'             : (0x3 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_RFU_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_RFU_BYTE3' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_RFU_BYTE3' : {
        'lsb'               : 28,
        'msb'               : 29,
        'size'              : 2,
        'field'             : (0x3 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_RFU_BYTE3' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_RFU_BYTE2',
        'DQ1_RFU_BYTE2',
        'DQ2_RFU_BYTE2',
        'DQ3_RFU_BYTE2',
        'DQ4_RFU_BYTE2',
        'DQ5_RFU_BYTE2',
        'DQ6_RFU_BYTE2',
        'DQ7_RFU_BYTE2',
        'DQ0_RFU_BYTE3',
        'DQ1_RFU_BYTE3',
        'DQ2_RFU_BYTE3',
        'DQ3_RFU_BYTE3',
        'DQ4_RFU_BYTE3',
        'DQ5_RFU_BYTE3',
        'DQ6_RFU_BYTE3',
        'DQ7_RFU_BYTE3',
    ],
} # End of register: PMACRO_PERBIT_RFU_CTRL_1_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_RFU_CTRL_1_0')
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_RFU_CTRL_2           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_RFU_CTRL_3           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_RFU_CTRL_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_RFU_CTRL_4_0'] = {
    'addr'            : 0xd70,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'DQ0_RFU_CMD0' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_RFU_CMD0' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_RFU_CMD0' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_RFU_CMD0' : {
        'lsb'               : 6,
        'msb'               : 7,
        'size'              : 2,
        'field'             : (0x3 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_RFU_CMD0' : {
        'lsb'               : 8,
        'msb'               : 9,
        'size'              : 2,
        'field'             : (0x3 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_RFU_CMD0' : {
        'lsb'               : 10,
        'msb'               : 11,
        'size'              : 2,
        'field'             : (0x3 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_RFU_CMD0' : {
        'lsb'               : 12,
        'msb'               : 13,
        'size'              : 2,
        'field'             : (0x3 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_RFU_CMD0' : {
        'lsb'               : 14,
        'msb'               : 15,
        'size'              : 2,
        'field'             : (0x3 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ0_RFU_CMD1' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ1_RFU_CMD1' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ2_RFU_CMD1' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ3_RFU_CMD1' : {
        'lsb'               : 22,
        'msb'               : 23,
        'size'              : 2,
        'field'             : (0x3 << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ4_RFU_CMD1' : {
        'lsb'               : 24,
        'msb'               : 25,
        'size'              : 2,
        'field'             : (0x3 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ5_RFU_CMD1' : {
        'lsb'               : 26,
        'msb'               : 27,
        'size'              : 2,
        'field'             : (0x3 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ6_RFU_CMD1' : {
        'lsb'               : 28,
        'msb'               : 29,
        'size'              : 2,
        'field'             : (0x3 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ7_RFU_CMD1' : {
        'lsb'               : 30,
        'msb'               : 31,
        'size'              : 2,
        'field'             : (0x3 << 30),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ0_RFU_CMD0',
        'DQ1_RFU_CMD0',
        'DQ2_RFU_CMD0',
        'DQ3_RFU_CMD0',
        'DQ4_RFU_CMD0',
        'DQ5_RFU_CMD0',
        'DQ6_RFU_CMD0',
        'DQ7_RFU_CMD0',
        'DQ0_RFU_CMD1',
        'DQ1_RFU_CMD1',
        'DQ2_RFU_CMD1',
        'DQ3_RFU_CMD1',
        'DQ4_RFU_CMD1',
        'DQ5_RFU_CMD1',
        'DQ6_RFU_CMD1',
        'DQ7_RFU_CMD1',
    ],
} # End of register: PMACRO_PERBIT_RFU_CTRL_4_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_RFU_CTRL_4_0')
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_RFU_CTRL_5           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_RFU1_CTRL_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_RFU1_CTRL_0_0'] = {
    'addr'            : 0xd80,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x3f003f,
    'DQ8_RFU_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_RFU_BYTE0' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_RFU_BYTE0' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PMU_OUT_BYTE0' : {
        'lsb'               : 6,
        'msb'               : 15,
        'size'              : 10,
        'field'             : (0x3ff << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DQ8_RFU_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_RFU_BYTE1' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_RFU_BYTE1' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PMU_OUT_BYTE1' : {
        'lsb'               : 22,
        'msb'               : 31,
        'size'              : 10,
        'field'             : (0x3ff << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ8_RFU_BYTE0',
        'DQSP_RFU_BYTE0',
        'DQSN_RFU_BYTE0',
        'PMU_OUT_BYTE0',
        'DQ8_RFU_BYTE1',
        'DQSP_RFU_BYTE1',
        'DQSN_RFU_BYTE1',
        'PMU_OUT_BYTE1',
    ],
} # End of register: PMACRO_PERBIT_RFU1_CTRL_0_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_RFU1_CTRL_0_0')
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_RFU1_CTRL_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_RFU1_CTRL_1_0'] = {
    'addr'            : 0xd84,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x3f003f,
    'DQ8_RFU_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_RFU_BYTE2' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_RFU_BYTE2' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PMU_OUT_BYTE2' : {
        'lsb'               : 6,
        'msb'               : 15,
        'size'              : 10,
        'field'             : (0x3ff << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DQ8_RFU_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_RFU_BYTE3' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_RFU_BYTE3' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PMU_OUT_BYTE3' : {
        'lsb'               : 22,
        'msb'               : 31,
        'size'              : 10,
        'field'             : (0x3ff << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ8_RFU_BYTE2',
        'DQSP_RFU_BYTE2',
        'DQSN_RFU_BYTE2',
        'PMU_OUT_BYTE2',
        'DQ8_RFU_BYTE3',
        'DQSP_RFU_BYTE3',
        'DQSN_RFU_BYTE3',
        'PMU_OUT_BYTE3',
    ],
} # End of register: PMACRO_PERBIT_RFU1_CTRL_1_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_RFU1_CTRL_1_0')
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_RFU1_CTRL_2           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_RFU1_CTRL_3           EMC_WINCR
#;
# This register is shadowed: see usage note at top of spec file.
#

# Register EMC_PMACRO_PERBIT_RFU1_CTRL_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PERBIT_RFU1_CTRL_4_0'] = {
    'addr'            : 0xd90,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3f003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x3f003f,
    'DQ8_RFU_CMD0' : {
        'lsb'               : 0,
        'msb'               : 1,
        'size'              : 2,
        'field'             : (0x3 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_RFU_CMD0' : {
        'lsb'               : 2,
        'msb'               : 3,
        'size'              : 2,
        'field'             : (0x3 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_RFU_CMD0' : {
        'lsb'               : 4,
        'msb'               : 5,
        'size'              : 2,
        'field'             : (0x3 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PMU_OUT_CMD0' : {
        'lsb'               : 6,
        'msb'               : 15,
        'size'              : 10,
        'field'             : (0x3ff << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DQ8_RFU_CMD1' : {
        'lsb'               : 16,
        'msb'               : 17,
        'size'              : 2,
        'field'             : (0x3 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSP_RFU_CMD1' : {
        'lsb'               : 18,
        'msb'               : 19,
        'size'              : 2,
        'field'             : (0x3 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQSN_RFU_CMD1' : {
        'lsb'               : 20,
        'msb'               : 21,
        'size'              : 2,
        'field'             : (0x3 << 20),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'PMU_OUT_CMD1' : {
        'lsb'               : 22,
        'msb'               : 31,
        'size'              : 10,
        'field'             : (0x3ff << 22),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ8_RFU_CMD0',
        'DQSP_RFU_CMD0',
        'DQSN_RFU_CMD0',
        'PMU_OUT_CMD0',
        'DQ8_RFU_CMD1',
        'DQSP_RFU_CMD1',
        'DQSN_RFU_CMD1',
        'PMU_OUT_CMD1',
    ],
} # End of register: PMACRO_PERBIT_RFU1_CTRL_4_0

registers['EMC']['register_list'].append('PMACRO_PERBIT_RFU1_CTRL_4_0')
# This register is shadowed: see usage note at top of spec file.
#
#reg    PMACRO_PERBIT_RFU1_CTRL_5           EMC_WINCR
#;
# This register is used to store the pmu_out value when e_offset is 1

# Register EMC_PMACRO_PMU_OUT_EOFF1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PMU_OUT_EOFF1_0_0'] = {
    'addr'            : 0xda0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x0,
    'PMU_OUT_EOFF1_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'PMU_OUT_EOFF1_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PMU_OUT_EOFF1_BYTE0',
        'PMU_OUT_EOFF1_BYTE1',
    ],
} # End of register: PMACRO_PMU_OUT_EOFF1_0_0

registers['EMC']['register_list'].append('PMACRO_PMU_OUT_EOFF1_0_0')
# This register is used to store the pmu_out value when e_offset is 1

# Register EMC_PMACRO_PMU_OUT_EOFF1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PMU_OUT_EOFF1_1_0'] = {
    'addr'            : 0xda4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x0,
    'PMU_OUT_EOFF1_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'PMU_OUT_EOFF1_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PMU_OUT_EOFF1_BYTE2',
        'PMU_OUT_EOFF1_BYTE3',
    ],
} # End of register: PMACRO_PMU_OUT_EOFF1_1_0

registers['EMC']['register_list'].append('PMACRO_PMU_OUT_EOFF1_1_0')
# This register is used to store the pmu_out value when e_offset is 1
#offset 0xDA8;
#reg    PMACRO_PMU_OUT_EOFF1_2           EMC_WINCR
#;
#
#// This register is used to store the pmu_out value when e_offset is 1
#offset 0xDAC;
#reg    PMACRO_PMU_OUT_EOFF1_3           EMC_WINCR
#;
# This register is used to store the pmu_out value when e_offset is 1

# Register EMC_PMACRO_PMU_OUT_EOFF1_4_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_PMU_OUT_EOFF1_4_0'] = {
    'addr'            : 0xdb0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x0,
    'PMU_OUT_EOFF1_CMD0' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'PMU_OUT_EOFF1_CMD1' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'PMU_OUT_EOFF1_CMD0',
        'PMU_OUT_EOFF1_CMD1',
    ],
} # End of register: PMACRO_PMU_OUT_EOFF1_4_0

registers['EMC']['register_list'].append('PMACRO_PMU_OUT_EOFF1_4_0')
# This register is used to store the pmu_out value when e_offset is 1
#offset 0xDB4;
#reg    PMACRO_PMU_OUT_EOFF1_5           EMC_WINCR
#;
# This register is used to store the pmu_out value when e_offset is 1

# Register EMC_PMACRO_COMP_PMU_OUT_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_COMP_PMU_OUT_0'] = {
    'addr'            : 0xdc0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1a,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x0,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3ff03ff,
    'write_mask'      : 0x0,
    'XM2COMP_PMU_OUT' : {
        'lsb'               : 0,
        'msb'               : 9,
        'size'              : 10,
        'field'             : (0x3ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'XM2COMP_PMU_OUT_EOFF1' : {
        'lsb'               : 16,
        'msb'               : 25,
        'size'              : 10,
        'field'             : (0x3ff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'XM2COMP_PMU_OUT',
        'XM2COMP_PMU_OUT_EOFF1',
    ],
} # End of register: PMACRO_COMP_PMU_OUT_0

registers['EMC']['register_list'].append('PMACRO_COMP_PMU_OUT_0')
#PI Controls

# Register EMC_PMACRO_DATA_PI_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DATA_PI_CTRL_0'] = {
    'addr'            : 0x9c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x16,
    'reset_val'       : 0x281010,
    'array'           : False,
    'reset_mask'      : 0x3f1f1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f1f1f,
    'write_mask'      : 0x3f1f1f,
    'DATA_DQ_TX_PI_CTRL' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQ_TX_PI_PWRD' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_PI_CTRL' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_DQS_TX_PI_PWRD' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DATA_PI_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x28,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DATA_DQ_TX_PI_CTRL',
        'DATA_DQ_TX_PI_PWRD',
        'DATA_DQS_TX_PI_CTRL',
        'DATA_DQS_TX_PI_PWRD',
        'DATA_PI_OFFSET',
    ],
} # End of register: PMACRO_DATA_PI_CTRL_0

registers['EMC']['register_list'].append('PMACRO_DATA_PI_CTRL_0')

# Register EMC_PMACRO_CMD_PI_CTRL_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CMD_PI_CTRL_0'] = {
    'addr'            : 0x790,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x16,
    'reset_val'       : 0x281010,
    'array'           : False,
    'reset_mask'      : 0x3f1f1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f1f1f,
    'write_mask'      : 0x3f1f1f,
    'CMD_DQ_TX_PI_CTRL' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQ_TX_PI_PWRD' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_PI_CTRL' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_DQS_TX_PI_PWRD' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'CMD_PI_OFFSET' : {
        'lsb'               : 16,
        'msb'               : 21,
        'size'              : 6,
        'field'             : (0x3f << 16),
        'woffset'           : 0x0,
        'default'           : 0x28,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CMD_DQ_TX_PI_CTRL',
        'CMD_DQ_TX_PI_PWRD',
        'CMD_DQS_TX_PI_CTRL',
        'CMD_DQS_TX_PI_PWRD',
        'CMD_PI_OFFSET',
    ],
} # End of register: PMACRO_CMD_PI_CTRL_0

registers['EMC']['register_list'].append('PMACRO_CMD_PI_CTRL_0')
#PER-BIT BARREL SHIFTER
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE0_0_0'] = {
    'addr'            : 0x10a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN0_BYTE0',
        'DQ_BRLSHFT_RANK0_PIN1_BYTE0',
        'DQ_BRLSHFT_RANK0_PIN2_BYTE0',
        'DQ_BRLSHFT_RANK0_PIN3_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE0_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE0_1_0'] = {
    'addr'            : 0x10a4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN4_BYTE0',
        'DQ_BRLSHFT_RANK0_PIN5_BYTE0',
        'DQ_BRLSHFT_RANK0_PIN6_BYTE0',
        'DQ_BRLSHFT_RANK0_PIN7_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE0_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE0_2_0'] = {
    'addr'            : 0x10a8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK0_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN8_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE0_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE0_3_0'] = {
    'addr'            : 0x10ac,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK0_PIN9_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN10_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN9_BYTE0',
        'DQ_BRLSHFT_RANK0_PIN10_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE0_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE1_0_0'] = {
    'addr'            : 0x10b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN0_BYTE1',
        'DQ_BRLSHFT_RANK0_PIN1_BYTE1',
        'DQ_BRLSHFT_RANK0_PIN2_BYTE1',
        'DQ_BRLSHFT_RANK0_PIN3_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE1_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE1_1_0'] = {
    'addr'            : 0x10b4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN4_BYTE1',
        'DQ_BRLSHFT_RANK0_PIN5_BYTE1',
        'DQ_BRLSHFT_RANK0_PIN6_BYTE1',
        'DQ_BRLSHFT_RANK0_PIN7_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE1_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE1_2_0'] = {
    'addr'            : 0x10b8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK0_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN8_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE1_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE1_3_0'] = {
    'addr'            : 0x10bc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK0_PIN9_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN10_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN9_BYTE1',
        'DQ_BRLSHFT_RANK0_PIN10_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE1_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE1_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE2_0_0'] = {
    'addr'            : 0x10c0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN0_BYTE2',
        'DQ_BRLSHFT_RANK0_PIN1_BYTE2',
        'DQ_BRLSHFT_RANK0_PIN2_BYTE2',
        'DQ_BRLSHFT_RANK0_PIN3_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE2_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE2_1_0'] = {
    'addr'            : 0x10c4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN4_BYTE2',
        'DQ_BRLSHFT_RANK0_PIN5_BYTE2',
        'DQ_BRLSHFT_RANK0_PIN6_BYTE2',
        'DQ_BRLSHFT_RANK0_PIN7_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE2_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE2_2_0'] = {
    'addr'            : 0x10c8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK0_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN8_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE2_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE2_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE2_3_0'] = {
    'addr'            : 0x10cc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK0_PIN9_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN10_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN9_BYTE2',
        'DQ_BRLSHFT_RANK0_PIN10_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE2_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE2_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE3_0_0'] = {
    'addr'            : 0x10d0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN0_BYTE3',
        'DQ_BRLSHFT_RANK0_PIN1_BYTE3',
        'DQ_BRLSHFT_RANK0_PIN2_BYTE3',
        'DQ_BRLSHFT_RANK0_PIN3_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE3_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE3_1_0'] = {
    'addr'            : 0x10d4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK0_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN4_BYTE3',
        'DQ_BRLSHFT_RANK0_PIN5_BYTE3',
        'DQ_BRLSHFT_RANK0_PIN6_BYTE3',
        'DQ_BRLSHFT_RANK0_PIN7_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE3_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE3_2_0'] = {
    'addr'            : 0x10d8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK0_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN8_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE3_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_BYTE3_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_BYTE3_3_0'] = {
    'addr'            : 0x10dc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK0_PIN9_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN10_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN9_BYTE3',
        'DQ_BRLSHFT_RANK0_PIN10_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK0_BYTE3_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_BYTE3_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD0_0_0'] = {
    'addr'            : 0x10e0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK0_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN0_CMD0',
        'DQ_BRLSHFT_RANK0_PIN1_CMD0',
        'DQ_BRLSHFT_RANK0_PIN2_CMD0',
        'DQ_BRLSHFT_RANK0_PIN3_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD0_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD0_1_0'] = {
    'addr'            : 0x10e4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK0_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN4_CMD0',
        'DQ_BRLSHFT_RANK0_PIN5_CMD0',
        'DQ_BRLSHFT_RANK0_PIN6_CMD0',
        'DQ_BRLSHFT_RANK0_PIN7_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD0_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD0_2_0'] = {
    'addr'            : 0x10e8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x3,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7,
    'write_mask'      : 0x7,
    'DQ_BRLSHFT_RANK0_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN8_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD0_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD0_3_0'] = {
    'addr'            : 0x10ec,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x707,
    'write_mask'      : 0x707,
    'DQ_BRLSHFT_RANK0_PIN9_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN10_CMD0' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN9_CMD0',
        'DQ_BRLSHFT_RANK0_PIN10_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD0_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD1_0_0'] = {
    'addr'            : 0x10f0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK0_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN0_CMD1',
        'DQ_BRLSHFT_RANK0_PIN1_CMD1',
        'DQ_BRLSHFT_RANK0_PIN2_CMD1',
        'DQ_BRLSHFT_RANK0_PIN3_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD1_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD1_1_0'] = {
    'addr'            : 0x10f4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK0_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN4_CMD1',
        'DQ_BRLSHFT_RANK0_PIN5_CMD1',
        'DQ_BRLSHFT_RANK0_PIN6_CMD1',
        'DQ_BRLSHFT_RANK0_PIN7_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD1_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD1_2_0'] = {
    'addr'            : 0x10f8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x3,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7,
    'write_mask'      : 0x7,
    'DQ_BRLSHFT_RANK0_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN8_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD1_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK0_CMD1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK0_CMD1_3_0'] = {
    'addr'            : 0x10fc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x707,
    'write_mask'      : 0x707,
    'DQ_BRLSHFT_RANK0_PIN9_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK0_PIN10_CMD1' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK0_PIN9_CMD1',
        'DQ_BRLSHFT_RANK0_PIN10_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK0_CMD1_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK0_CMD1_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE0_0_0'] = {
    'addr'            : 0x1100,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN0_BYTE0',
        'DQ_BRLSHFT_RANK1_PIN1_BYTE0',
        'DQ_BRLSHFT_RANK1_PIN2_BYTE0',
        'DQ_BRLSHFT_RANK1_PIN3_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE0_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE0_1_0'] = {
    'addr'            : 0x1104,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN4_BYTE0',
        'DQ_BRLSHFT_RANK1_PIN5_BYTE0',
        'DQ_BRLSHFT_RANK1_PIN6_BYTE0',
        'DQ_BRLSHFT_RANK1_PIN7_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE0_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE0_2_0'] = {
    'addr'            : 0x1108,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK1_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN8_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE0_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE0_3_0'] = {
    'addr'            : 0x110c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK1_PIN9_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN10_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN9_BYTE0',
        'DQ_BRLSHFT_RANK1_PIN10_BYTE0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE0_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE1_0_0'] = {
    'addr'            : 0x1110,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN0_BYTE1',
        'DQ_BRLSHFT_RANK1_PIN1_BYTE1',
        'DQ_BRLSHFT_RANK1_PIN2_BYTE1',
        'DQ_BRLSHFT_RANK1_PIN3_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE1_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE1_1_0'] = {
    'addr'            : 0x1114,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN4_BYTE1',
        'DQ_BRLSHFT_RANK1_PIN5_BYTE1',
        'DQ_BRLSHFT_RANK1_PIN6_BYTE1',
        'DQ_BRLSHFT_RANK1_PIN7_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE1_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE1_2_0'] = {
    'addr'            : 0x1118,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK1_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN8_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE1_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE1_3_0'] = {
    'addr'            : 0x111c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK1_PIN9_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN10_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN9_BYTE1',
        'DQ_BRLSHFT_RANK1_PIN10_BYTE1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE1_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE1_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE2_0_0'] = {
    'addr'            : 0x1120,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN0_BYTE2',
        'DQ_BRLSHFT_RANK1_PIN1_BYTE2',
        'DQ_BRLSHFT_RANK1_PIN2_BYTE2',
        'DQ_BRLSHFT_RANK1_PIN3_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE2_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE2_1_0'] = {
    'addr'            : 0x1124,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN4_BYTE2',
        'DQ_BRLSHFT_RANK1_PIN5_BYTE2',
        'DQ_BRLSHFT_RANK1_PIN6_BYTE2',
        'DQ_BRLSHFT_RANK1_PIN7_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE2_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE2_2_0'] = {
    'addr'            : 0x1128,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK1_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN8_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE2_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE2_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE2_3_0'] = {
    'addr'            : 0x112c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK1_PIN9_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN10_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN9_BYTE2',
        'DQ_BRLSHFT_RANK1_PIN10_BYTE2',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE2_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE2_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE3_0_0'] = {
    'addr'            : 0x1130,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN0_BYTE3',
        'DQ_BRLSHFT_RANK1_PIN1_BYTE3',
        'DQ_BRLSHFT_RANK1_PIN2_BYTE3',
        'DQ_BRLSHFT_RANK1_PIN3_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE3_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE3_1_0'] = {
    'addr'            : 0x1134,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ_BRLSHFT_RANK1_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN4_BYTE3',
        'DQ_BRLSHFT_RANK1_PIN5_BYTE3',
        'DQ_BRLSHFT_RANK1_PIN6_BYTE3',
        'DQ_BRLSHFT_RANK1_PIN7_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE3_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE3_2_0'] = {
    'addr'            : 0x1138,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'DQ_BRLSHFT_RANK1_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN8_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE3_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_BYTE3_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_BYTE3_3_0'] = {
    'addr'            : 0x113c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xc,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xf0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f,
    'write_mask'      : 0xf0f,
    'DQ_BRLSHFT_RANK1_PIN9_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN10_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN9_BYTE3',
        'DQ_BRLSHFT_RANK1_PIN10_BYTE3',
    ],
} # End of register: DQ_BRLSHFT_RANK1_BYTE3_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_BYTE3_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD0_0_0'] = {
    'addr'            : 0x1140,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK1_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN0_CMD0',
        'DQ_BRLSHFT_RANK1_PIN1_CMD0',
        'DQ_BRLSHFT_RANK1_PIN2_CMD0',
        'DQ_BRLSHFT_RANK1_PIN3_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD0_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD0_1_0'] = {
    'addr'            : 0x1144,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK1_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN4_CMD0',
        'DQ_BRLSHFT_RANK1_PIN5_CMD0',
        'DQ_BRLSHFT_RANK1_PIN6_CMD0',
        'DQ_BRLSHFT_RANK1_PIN7_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD0_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD0_2_0'] = {
    'addr'            : 0x1148,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x3,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7,
    'write_mask'      : 0x7,
    'DQ_BRLSHFT_RANK1_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN8_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD0_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD0_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD0_3_0'] = {
    'addr'            : 0x114c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x707,
    'write_mask'      : 0x707,
    'DQ_BRLSHFT_RANK1_PIN9_CMD0' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN10_CMD0' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN9_CMD0',
        'DQ_BRLSHFT_RANK1_PIN10_CMD0',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD0_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD0_3_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD1_0_0'] = {
    'addr'            : 0x1150,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK1_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN0_CMD1',
        'DQ_BRLSHFT_RANK1_PIN1_CMD1',
        'DQ_BRLSHFT_RANK1_PIN2_CMD1',
        'DQ_BRLSHFT_RANK1_PIN3_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD1_0_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD1_1_0'] = {
    'addr'            : 0x1154,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1b,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7070707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7070707,
    'write_mask'      : 0x7070707,
    'DQ_BRLSHFT_RANK1_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 18,
        'size'              : 3,
        'field'             : (0x7 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 26,
        'size'              : 3,
        'field'             : (0x7 << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN4_CMD1',
        'DQ_BRLSHFT_RANK1_PIN5_CMD1',
        'DQ_BRLSHFT_RANK1_PIN6_CMD1',
        'DQ_BRLSHFT_RANK1_PIN7_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD1_1_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD1_2_0'] = {
    'addr'            : 0x1158,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x3,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7,
    'write_mask'      : 0x7,
    'DQ_BRLSHFT_RANK1_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN8_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD1_2_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_DQ_BRLSHFT_RANK1_CMD1_3_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DQ_BRLSHFT_RANK1_CMD1_3_0'] = {
    'addr'            : 0x115c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0xb,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x707,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x707,
    'write_mask'      : 0x707,
    'DQ_BRLSHFT_RANK1_PIN9_CMD1' : {
        'lsb'               : 0,
        'msb'               : 2,
        'size'              : 3,
        'field'             : (0x7 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'DQ_BRLSHFT_RANK1_PIN10_CMD1' : {
        'lsb'               : 8,
        'msb'               : 10,
        'size'              : 3,
        'field'             : (0x7 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ_BRLSHFT_RANK1_PIN9_CMD1',
        'DQ_BRLSHFT_RANK1_PIN10_CMD1',
    ],
} # End of register: DQ_BRLSHFT_RANK1_CMD1_3_0

registers['EMC']['register_list'].append('DQ_BRLSHFT_RANK1_CMD1_3_0')
#// PER-BIT IB DQS settings
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_0_0'] = {
    'addr'            : 0x1200,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_1_0'] = {
    'addr'            : 0x1204,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_2_0'] = {
    'addr'            : 0x1208,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_0_0'] = {
    'addr'            : 0x1210,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_1_0'] = {
    'addr'            : 0x1214,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_2_0'] = {
    'addr'            : 0x1218,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_0_0'] = {
    'addr'            : 0x1220,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_1_0'] = {
    'addr'            : 0x1224,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_2_0'] = {
    'addr'            : 0x1228,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_0_0'] = {
    'addr'            : 0x1230,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN0_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK0_PIN1_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK0_PIN2_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK0_PIN3_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_1_0'] = {
    'addr'            : 0x1234,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN4_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK0_PIN5_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK0_PIN6_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK0_PIN7_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_2_0'] = {
    'addr'            : 0x1238,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN8_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_0_0'] = {
    'addr'            : 0x1280,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN0_CMD0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN1_CMD0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN2_CMD0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN3_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_1_0'] = {
    'addr'            : 0x1284,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN4_CMD0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN5_CMD0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN6_CMD0',
        'IB_DDLL_SHORT_DQS_RANK0_PIN7_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_2_0'] = {
    'addr'            : 0x1288,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN8_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_0_0'] = {
    'addr'            : 0x1290,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN0_CMD1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN1_CMD1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN2_CMD1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN3_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_1_0'] = {
    'addr'            : 0x1294,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK0_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN4_CMD1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN5_CMD1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN6_CMD1',
        'IB_DDLL_SHORT_DQS_RANK0_PIN7_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_2_0'] = {
    'addr'            : 0x1298,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK0_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK0_PIN8_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK0_CMD1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_0_0'] = {
    'addr'            : 0x1300,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_1_0'] = {
    'addr'            : 0x1304,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_2_0'] = {
    'addr'            : 0x1308,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_0_0'] = {
    'addr'            : 0x1310,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_1_0'] = {
    'addr'            : 0x1314,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_2_0'] = {
    'addr'            : 0x1318,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE1_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_0_0'] = {
    'addr'            : 0x1320,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_1_0'] = {
    'addr'            : 0x1324,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE2' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE2' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE2',
        'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_2_0'] = {
    'addr'            : 0x1328,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE2' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE2',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE2_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_0_0'] = {
    'addr'            : 0x1330,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN0_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK1_PIN1_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK1_PIN2_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK1_PIN3_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_1_0'] = {
    'addr'            : 0x1334,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE3' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE3' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN4_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK1_PIN5_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK1_PIN6_BYTE3',
        'IB_DDLL_SHORT_DQS_RANK1_PIN7_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_2_0'] = {
    'addr'            : 0x1338,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE3' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN8_BYTE3',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_BYTE3_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_0_0'] = {
    'addr'            : 0x1380,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN0_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN1_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN2_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN3_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN0_CMD0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN1_CMD0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN2_CMD0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN3_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_1_0'] = {
    'addr'            : 0x1384,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN4_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN5_CMD0' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN6_CMD0' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN7_CMD0' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN4_CMD0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN5_CMD0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN6_CMD0',
        'IB_DDLL_SHORT_DQS_RANK1_PIN7_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_2_0'] = {
    'addr'            : 0x1388,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN8_CMD0' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN8_CMD0',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD0_2_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_0_0'] = {
    'addr'            : 0x1390,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN0_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN1_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN2_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN3_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN0_CMD1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN1_CMD1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN2_CMD1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN3_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_0_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_0_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_1_0'] = {
    'addr'            : 0x1394,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0xffffffff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN4_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN5_CMD1' : {
        'lsb'               : 8,
        'msb'               : 15,
        'size'              : 8,
        'field'             : (0xff << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN6_CMD1' : {
        'lsb'               : 16,
        'msb'               : 23,
        'size'              : 8,
        'field'             : (0xff << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'IB_DDLL_SHORT_DQS_RANK1_PIN7_CMD1' : {
        'lsb'               : 24,
        'msb'               : 31,
        'size'              : 8,
        'field'             : (0xff << 24),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN4_CMD1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN5_CMD1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN6_CMD1',
        'IB_DDLL_SHORT_DQS_RANK1_PIN7_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_1_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_1_0')
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_2_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_2_0'] = {
    'addr'            : 0x1398,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'IB_DDLL_SHORT_DQS_RANK1_PIN8_CMD1' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IB_DDLL_SHORT_DQS_RANK1_PIN8_CMD1',
    ],
} # End of register: PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_2_0

registers['EMC']['register_list'].append('PMACRO_IB_DDLL_SHORT_DQS_RANK1_CMD1_2_0')
# Boot requirements: This register should be parameterized in the BCT and written by the BootROM during coldboot.
# Boot requirements: This register should be saved in the scratch registers and restored by the BootROM during warmboot.

# Register EMC_PMACRO_DQ7_SEL_CFG_0_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_DQ7_SEL_CFG_0_0'] = {
    'addr'            : 0x13a0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1c,
    'reset_val'       : 0x7070707,
    'array'           : False,
    'reset_mask'      : 0xf0f0f0f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf0f0f0f,
    'write_mask'      : 0xf0f0f0f,
    'DQ7_SEL_BYTE0' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7_SEL_BYTE1' : {
        'lsb'               : 8,
        'msb'               : 11,
        'size'              : 4,
        'field'             : (0xf << 8),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7_SEL_BYTE2' : {
        'lsb'               : 16,
        'msb'               : 19,
        'size'              : 4,
        'field'             : (0xf << 16),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DQ7_SEL_BYTE3' : {
        'lsb'               : 24,
        'msb'               : 27,
        'size'              : 4,
        'field'             : (0xf << 24),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DQ7_SEL_BYTE0',
        'DQ7_SEL_BYTE1',
        'DQ7_SEL_BYTE2',
        'DQ7_SEL_BYTE3',
    ],
} # End of register: PMACRO_DQ7_SEL_CFG_0_0

registers['EMC']['register_list'].append('PMACRO_DQ7_SEL_CFG_0_0')
#offset 0x13a4;
#reg   PMACRO_DQ7_SEL_CFG_1         EMC_WINCR // Mode2 CA Tr padmacro register for controls that are per-IOBRICK
#offset 0x13a8;
#reg   PMACRO_DQ7_SEL_CFG_2         EMC_WINCR // Mode2 CA Tr padmacro register for controls that are per-IOBRICK
#offset 0x13ac;
#reg   PMACRO_DQ7_SEL_CFG_3         EMC_WINCR // Mode2 CA Tr padmacro register for controls that are per-IOBRICK
# This register is shadowed: see usage note at top of spec file.

# Register EMC_PMACRO_CATR_DLY_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['PMACRO_CATR_DLY_0'] = {
    'addr'            : 0x13b0,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x4,
    'reset_val'       : 0x7,
    'array'           : False,
    'reset_mask'      : 0xf,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xf,
    'write_mask'      : 0xf,
    'ZI_TX_EN_SETTLE_DELAY' : {
        'lsb'               : 0,
        'msb'               : 3,
        'size'              : 4,
        'field'             : (0xf << 0),
        'woffset'           : 0x0,
        'default'           : 0x7,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ZI_TX_EN_SETTLE_DELAY',
    ],
} # End of register: PMACRO_CATR_DLY_0

registers['EMC']['register_list'].append('PMACRO_CATR_DLY_0')
#/// Training Support Registers in EMC ////

# Register EMC_TR_TIMING_1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['TR_TIMING_1_0'] = {
    'addr'            : 0x13b4,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x17,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x7ff7ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x7ff7ff,
    'write_mask'      : 0x7ff7ff,
    'T_NONRW2TRRW' : {
        'lsb'               : 0,
        'msb'               : 10,
        'size'              : 11,
        'field'             : (0x7ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    'T_TR2NONTR' : {
        'lsb'               : 12,
        'msb'               : 22,
        'size'              : 11,
        'field'             : (0x7ff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rws',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'T_NONRW2TRRW',
        'T_TR2NONTR',
    ],
} # End of register: TR_TIMING_1_0

registers['EMC']['register_list'].append('TR_TIMING_1_0')
#/// DVFS SEQ DEBUG  Registers in EMC ////

# Register EMC_DVFS_DEBUG_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DVFS_DEBUG_0'] = {
    'addr'            : 0x13b8,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1e,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x3cffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3cffffff,
    'write_mask'      : 0x34ffffff,
    'DVFS_SOURCE_FREQ_MHZ' : {
        'lsb'               : 0,
        'msb'               : 11,
        'size'              : 12,
        'field'             : (0xfff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DVFS_TARGET_FREQ_MHZ' : {
        'lsb'               : 12,
        'msb'               : 23,
        'size'              : 12,
        'field'             : (0xfff << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DVFS_SEQ_IN_PROGRESS' : {
        'lsb'               : 26,
        'msb'               : 26,
        'size'              : 1,
        'field'             : (0x1 << 26),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'DVFS_IN_RW_STALL' : {
        'lsb'               : 27,
        'msb'               : 27,
        'size'              : 1,
        'field'             : (0x1 << 27),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    'DVFS_SEQ_TYPE' : {
        'lsb'               : 28,
        'msb'               : 29,
        'size'              : 2,
        'field'             : (0x3 << 28),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
            'init_enum'  : "NULL",
        'enums' : {
            'NULL' : 0,
            'DVFS' : 1,
            'FULL_TR' : 2,
            'DVFS_TR' : 3,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DVFS_SOURCE_FREQ_MHZ',
        'DVFS_TARGET_FREQ_MHZ',
        'DVFS_SEQ_IN_PROGRESS',
        'DVFS_IN_RW_STALL',
        'DVFS_SEQ_TYPE',
    ],
} # End of register: DVFS_DEBUG_0

registers['EMC']['register_list'].append('DVFS_DEBUG_0')

# Register EMC_DVFS_DEBUG1_0
if 'EMC' not in registers:
    registers['EMC'] = {}
    registers['EMC']['register_list']  = []

registers['EMC']['DVFS_DEBUG1_0'] = {
    'addr'            : 0x13bc,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x10,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff,
    'write_mask'      : 0x0,
    'DVFS_STALL_US' : {
        'lsb'               : 0,
        'msb'               : 15,
        'size'              : 16,
        'field'             : (0xffff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'DVFS_STALL_US',
    ],
} # End of register: DVFS_DEBUG1_0

registers['EMC']['register_list'].append('DVFS_DEBUG1_0')
# Error collator registers
#==================================
# GLOBAL SLICE
#==================================

# Register EMC_CHANNEL_EC_FEATURE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['FEATURE_0'] = {
    'addr'            : 0x2000,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0x130001,
    'array'           : False,
    'reset_mask'      : 0xffff003f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffff003f,
    'write_mask'      : 0x0,
    'NUM_ERR' : {
        'lsb'               : 16,
        'msb'               : 31,
        'size'              : 16,
        'field'             : (0xffff << 16),
        'woffset'           : 0x0,
        'default'           : 0x13,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'c',
        'enums' : {
        },
    },
    'NUM_ERR_SLICES' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'c',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'NUM_ERR',
        'NUM_ERR_SLICES',
    ],
} # End of register: FEATURE_0

registers['EMC_CHANNEL_EC']['register_list'].append('FEATURE_0')

# Register EMC_CHANNEL_EC_SWRESET_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['SWRESET_0'] = {
    'addr'            : 0x2004,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x1,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x0,
    'write_mask'      : 0x1,
    'SWRST' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'SWRST',
    ],
} # End of register: SWRESET_0

registers['EMC_CHANNEL_EC']['register_list'].append('SWRESET_0')

# Register EMC_CHANNEL_EC_MISSIONERR_TYPE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['MISSIONERR_TYPE_0'] = {
    'addr'            : 0x2008,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x6,
    'reset_val'       : 0x5,
    'array'           : False,
    'reset_mask'      : 0x3f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x3f,
    'write_mask'      : 0x0,
    'CODE' : {
        'lsb'               : 0,
        'msb'               : 5,
        'size'              : 6,
        'field'             : (0x3f << 0),
        'woffset'           : 0x0,
        'default'           : 0x5,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'CODE',
    ],
} # End of register: MISSIONERR_TYPE_0

registers['EMC_CHANNEL_EC']['register_list'].append('MISSIONERR_TYPE_0')

# Register EMC_CHANNEL_EC_CURRENT_COUNTER_VALUE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['CURRENT_COUNTER_VALUE_0'] = {
    'addr'            : 0x200c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x9,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1ff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1ff,
    'write_mask'      : 0x0,
    'VALUE' : {
        'lsb'               : 0,
        'msb'               : 8,
        'size'              : 9,
        'field'             : (0x1ff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'VALUE',
    ],
} # End of register: CURRENT_COUNTER_VALUE_0

registers['EMC_CHANNEL_EC']['register_list'].append('CURRENT_COUNTER_VALUE_0')

# Register EMC_CHANNEL_EC_MISSIONERR_USERVALUE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['MISSIONERR_USERVALUE_0'] = {
    'addr'            : 0x2010,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x20,
    'reset_val'       : 0xdead0000,
    'array'           : False,
    'reset_mask'      : 0xffffffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xffffffff,
    'write_mask'      : 0x0,
    'VALUE' : {
        'lsb'               : 0,
        'msb'               : 31,
        'size'              : 32,
        'field'             : (0xffffffff << 0),
        'woffset'           : 0x0,
        'default'           : 0xdead0000,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'r',
            'init_enum'  : "-559087616",
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'VALUE',
    ],
} # End of register: MISSIONERR_USERVALUE_0

registers['EMC_CHANNEL_EC']['register_list'].append('MISSIONERR_USERVALUE_0')

# Register EMC_CHANNEL_EC_MISSIONERR_INDEX_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['MISSIONERR_INDEX_0'] = {
    'addr'            : 0x2014,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x5,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0x1f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x1f,
    'write_mask'      : 0x1f,
    'IDX' : {
        'lsb'               : 0,
        'msb'               : 4,
        'size'              : 5,
        'field'             : (0x1f << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'IDX',
    ],
} # End of register: MISSIONERR_INDEX_0

registers['EMC_CHANNEL_EC']['register_list'].append('MISSIONERR_INDEX_0')

# Register EMC_CHANNEL_EC_CORRECTABLE_THRESHOLD_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['CORRECTABLE_THRESHOLD_0'] = {
    'addr'            : 0x2018,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0xff,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'COUNT' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0xff,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'COUNT',
    ],
} # End of register: CORRECTABLE_THRESHOLD_0

registers['EMC_CHANNEL_EC']['register_list'].append('CORRECTABLE_THRESHOLD_0')

# Register EMC_CHANNEL_EC_MISSIONERR_INJECT_UNLOCK_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['MISSIONERR_INJECT_UNLOCK_0'] = {
    'addr'            : 0x201c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x8,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff,
    'write_mask'      : 0xff,
    'VALUE' : {
        'lsb'               : 0,
        'msb'               : 7,
        'size'              : 8,
        'field'             : (0xff << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'LOCK' : 0,
            'UNLOCK' : 225,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'VALUE',
    ],
} # End of register: MISSIONERR_INJECT_UNLOCK_0

registers['EMC_CHANNEL_EC']['register_list'].append('MISSIONERR_INJECT_UNLOCK_0')
# 0x20 to 0x2C = Reserved for future use.
#==================================
# ERROR SLICE - 0
#==================================

# Register EMC_CHANNEL_EC_ERRSLICE0_MISSIONERR_ENABLE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_MISSIONERR_ENABLE_0'] = {
    'addr'            : 0x2030,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0xfffff,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfffff,
    'write_mask'      : 0xfffff,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR11',
        'ERR10',
        'ERR9',
        'ERR8',
        'ERR7',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_MISSIONERR_ENABLE_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_MISSIONERR_ENABLE_0')

# Register EMC_CHANNEL_EC_ERRSLICE0_MISSIONERR_FORCE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_MISSIONERR_FORCE_0'] = {
    'addr'            : 0x2034,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x0,
    'write_mask'      : 0xfffff,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR11',
        'ERR10',
        'ERR9',
        'ERR8',
        'ERR7',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_MISSIONERR_FORCE_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_MISSIONERR_FORCE_0')

# Register EMC_CHANNEL_EC_ERRSLICE0_MISSIONERR_STATUS_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_MISSIONERR_STATUS_0'] = {
    'addr'            : 0x2038,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfffff,
    'write_mask'      : 0xfffff,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR11',
        'ERR10',
        'ERR9',
        'ERR8',
        'ERR7',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_MISSIONERR_STATUS_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_MISSIONERR_STATUS_0')

# Register EMC_CHANNEL_EC_ERRSLICE0_MISSIONERR_INJECT_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_MISSIONERR_INJECT_0'] = {
    'addr'            : 0x203c,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xff27f,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xff27f,
    'write_mask'      : 0xff27f,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR9',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_MISSIONERR_INJECT_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_MISSIONERR_INJECT_0')

# Register EMC_CHANNEL_EC_ERRSLICE0_LATENTERR_ENABLE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_LATENTERR_ENABLE_0'] = {
    'addr'            : 0x2040,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0xfffff,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfffff,
    'write_mask'      : 0xfffff,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x1,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
            'DISABLE' : 0,
            'ENABLE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR11',
        'ERR10',
        'ERR9',
        'ERR8',
        'ERR7',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_LATENTERR_ENABLE_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_LATENTERR_ENABLE_0')

# Register EMC_CHANNEL_EC_ERRSLICE0_LATENTERR_FORCE_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_LATENTERR_FORCE_0'] = {
    'addr'            : 0x2044,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x0,
    'write_mask'      : 0xfffff,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NOFORCE' : 0,
            'FORCE' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR11',
        'ERR10',
        'ERR9',
        'ERR8',
        'ERR7',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_LATENTERR_FORCE_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_LATENTERR_FORCE_0')

# Register EMC_CHANNEL_EC_ERRSLICE0_LATENTERR_STATUS_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_LATENTERR_STATUS_0'] = {
    'addr'            : 0x2048,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0xfffff,
    'write_mask'      : 0xfffff,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 1,
        'action'            : 'rw',
        'enums' : {
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR11',
        'ERR10',
        'ERR9',
        'ERR8',
        'ERR7',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_LATENTERR_STATUS_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_LATENTERR_STATUS_0')

# Register EMC_CHANNEL_EC_ERRSLICE0_COUNTER_RELOAD_0
if 'EMC_CHANNEL_EC' not in registers:
    registers['EMC_CHANNEL_EC'] = {}
    registers['EMC_CHANNEL_EC']['register_list']  = []

registers['EMC_CHANNEL_EC']['ERRSLICE0_COUNTER_RELOAD_0'] = {
    'addr'            : 0x2050,
    'secure'          : 0x0,
    'dual'            : 0x0,
    'word_count'      : 0x1,
    'size'            : 0x14,
    'reset_val'       : 0x0,
    'array'           : False,
    'reset_mask'      : 0xfffff,
    'sw_default_val'  : 0x0,
    'sw_default_mask' : 0x0,
    'read_mask'       : 0x0,
    'write_mask'      : 0xfffff,
    'ERR19' : {
        'lsb'               : 19,
        'msb'               : 19,
        'size'              : 1,
        'field'             : (0x1 << 19),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR18' : {
        'lsb'               : 18,
        'msb'               : 18,
        'size'              : 1,
        'field'             : (0x1 << 18),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR17' : {
        'lsb'               : 17,
        'msb'               : 17,
        'size'              : 1,
        'field'             : (0x1 << 17),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR16' : {
        'lsb'               : 16,
        'msb'               : 16,
        'size'              : 1,
        'field'             : (0x1 << 16),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR15' : {
        'lsb'               : 15,
        'msb'               : 15,
        'size'              : 1,
        'field'             : (0x1 << 15),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR14' : {
        'lsb'               : 14,
        'msb'               : 14,
        'size'              : 1,
        'field'             : (0x1 << 14),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR13' : {
        'lsb'               : 13,
        'msb'               : 13,
        'size'              : 1,
        'field'             : (0x1 << 13),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR12' : {
        'lsb'               : 12,
        'msb'               : 12,
        'size'              : 1,
        'field'             : (0x1 << 12),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR11' : {
        'lsb'               : 11,
        'msb'               : 11,
        'size'              : 1,
        'field'             : (0x1 << 11),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR10' : {
        'lsb'               : 10,
        'msb'               : 10,
        'size'              : 1,
        'field'             : (0x1 << 10),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR9' : {
        'lsb'               : 9,
        'msb'               : 9,
        'size'              : 1,
        'field'             : (0x1 << 9),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR8' : {
        'lsb'               : 8,
        'msb'               : 8,
        'size'              : 1,
        'field'             : (0x1 << 8),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR7' : {
        'lsb'               : 7,
        'msb'               : 7,
        'size'              : 1,
        'field'             : (0x1 << 7),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR6' : {
        'lsb'               : 6,
        'msb'               : 6,
        'size'              : 1,
        'field'             : (0x1 << 6),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR5' : {
        'lsb'               : 5,
        'msb'               : 5,
        'size'              : 1,
        'field'             : (0x1 << 5),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR4' : {
        'lsb'               : 4,
        'msb'               : 4,
        'size'              : 1,
        'field'             : (0x1 << 4),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR3' : {
        'lsb'               : 3,
        'msb'               : 3,
        'size'              : 1,
        'field'             : (0x1 << 3),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR2' : {
        'lsb'               : 2,
        'msb'               : 2,
        'size'              : 1,
        'field'             : (0x1 << 2),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR1' : {
        'lsb'               : 1,
        'msb'               : 1,
        'size'              : 1,
        'field'             : (0x1 << 1),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    'ERR0' : {
        'lsb'               : 0,
        'msb'               : 0,
        'size'              : 1,
        'field'             : (0x1 << 0),
        'woffset'           : 0x0,
        'default'           : 0x0,
        'sw_default'        : 0x0,
        'parity_protection' : 0,
        'action'            : 'w',
        'enums' : {
            'NORELOAD' : 0,
            'RELOAD' : 1,
        },
    },
    # Fields sorted in order of declaration in register
    'field_list' : [
        'ERR19',
        'ERR18',
        'ERR17',
        'ERR16',
        'ERR15',
        'ERR14',
        'ERR13',
        'ERR12',
        'ERR11',
        'ERR10',
        'ERR9',
        'ERR8',
        'ERR7',
        'ERR6',
        'ERR5',
        'ERR4',
        'ERR3',
        'ERR2',
        'ERR1',
        'ERR0',
    ],
} # End of register: ERRSLICE0_COUNTER_RELOAD_0

registers['EMC_CHANNEL_EC']['register_list'].append('ERRSLICE0_COUNTER_RELOAD_0')
# 0x28 to 0x30 = Reserved for future use.

##
## ADDRESS SPACES
##

addr_spaces['EMC'] = 0x00000000;
addr_spaces['EMC_CHANNEL_EC'] = 0x00002000;
